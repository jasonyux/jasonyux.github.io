<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>CSEE3827 Fundemental of Computer | Lecture Notes</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="CSEE3827 Fundemental of Computer" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An inexhaustive collection of markdown/latex(PDF) notes that I took since college." />
<meta property="og:description" content="An inexhaustive collection of markdown/latex(PDF) notes that I took since college." />
<link rel="canonical" href="/lectures/2021@columbia/CSEE3827_Fundemental_of_Computer.html/" />
<meta property="og:url" content="/lectures/2021@columbia/CSEE3827_Fundemental_of_Computer.html/" />
<meta property="og:site_name" content="Lecture Notes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-10-21T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="CSEE3827 Fundemental of Computer" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-10-21T00:00:00-04:00","datePublished":"2021-10-21T00:00:00-04:00","description":"An inexhaustive collection of markdown/latex(PDF) notes that I took since college.","headline":"CSEE3827 Fundemental of Computer","mainEntityOfPage":{"@type":"WebPage","@id":"/lectures/2021@columbia/CSEE3827_Fundemental_of_Computer.html/"},"url":"/lectures/2021@columbia/CSEE3827_Fundemental_of_Computer.html/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/lectures/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/lectures/feed.xml" title="Lecture Notes" /></head>
<body><header class="site-header">

	<div class="wrapper"><a class="site-title" rel="author" href="/lectures/">Lecture Notes</a>

		<nav class="site-nav">
			<input type="checkbox" id="nav-trigger" class="nav-trigger" />
			<label for="nav-trigger">
			<span class="menu-icon">
				<svg viewBox="0 0 18 15" width="18px" height="15px">
				<path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
				</svg>
			</span>
			</label>

			<div class="trigger">
				<a class="page-link" href="/">Home</a>
				<a class="page-link" href="/projects">Projects</a>
				<a class="page-link" href="/learning">Blog</a>
				<a class="page-link" href="/research">Research</a>
				<span class="page-link" href="#">[Education]</span>
			</div>
		</nav>
	</div>
  </header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <head>
	<script>
		MathJax = {
		  tex: {
			inlineMath: [['$', '$'], ['\\(', '\\)']],
			displayMath: [['$$', '$$'], ['\\[', '\\]']]
		  }
		};
	</script>
	<script id="MathJax-script" async
		src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>
  </head>
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">CSEE3827 Fundemental of Computer</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-10-21T00:00:00-04:00" itemprop="datePublished">
        Oct 21, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <style type="text/css">@page { margin-left: 2in; margin-right: -0.25in; }</style>

<h1 id="logistics">Logistics</h1>

<p>Syllabus:</p>

<ol>
  <li>Binary Abstraction
    <ul>
      <li>the 1’s and 0’s</li>
    </ul>
  </li>
  <li>Combinational circuits
    <ul>
      <li>operations on the binary data</li>
    </ul>
  </li>
  <li>Sequential circuits
    <ul>
      <li>storage of data</li>
    </ul>
  </li>
  <li>Instruction set architecture (ISA)
    <ul>
      <li>basically the interface between software and hardware</li>
      <li>a rudimentary programming language that hardware chips can execute</li>
    </ul>
  </li>
  <li>Processors
    <ul>
      <li>basically implementations of the ISA, using circuits</li>
    </ul>
  </li>
  <li>High Performance Processors
    <ul>
      <li>efficient, faster processors</li>
      <li><em>pipelining</em> and <em>caching</em></li>
    </ul>
  </li>
</ol>

<ul>
  <li><strong>Reflections and Practice</strong> problems (20% and 40%)
    <ul>
      <li>reflections are usually due Mondays, can include what you have learnt and what you don’t understand</li>
      <li>practice problems are for self-assessments. Grade will not be recorded, but completeness will.</li>
    </ul>
  </li>
  <li><strong>Quizzes</strong> (40%)
    <ul>
      <li>each quiz covers the <strong><em>previous week’s practice sheet</em></strong></li>
      <li>6 quizzes, one for each module</li>
      <li>live during class time</li>
    </ul>
  </li>
  <li><strong>Office Hours</strong>
    <ul>
      <li>needs to be scheduled</li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20200908222853636.png" alt="image-20200908222853636" /></p>

<h1 id="week-1---binary-integers">Week 1 - Binary Integers</h1>

<h2 id="binary-number-system">Binary Number System</h2>

<p>Our familiar decimal digits look like:</p>

<p><img src="\lectures\images\typora-user-images\image-20200908224120469.png" alt="image-20200908224120469" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>every time when we move up, we <strong>multiply by 10</strong></li>
</ul>

<p>Binary system looks like:</p>

<p><img src="\lectures\images\typora-user-images\image-20200908224209363.png" alt="image-20200908224209363" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>every time when we move up in digits, we <strong>multiply by 2</strong></li>
  <li>binary digits, $0,1$, is also called a <strong><em>bit</em></strong></li>
</ul>

<blockquote>
  <p>Extension:</p>

  <ul>
    <li>
      <p>Question:</p>

      <p>Why do computers use binary?</p>
    </li>
    <li>
      <p>Answer:</p>

      <p>This is related to how data are basically transferred. Since we use electricity, we detect voltage and transform <strong>from analogue to digital signal</strong> (continuous to discrete) to send and receive data.</p>

      <p><img src="\lectures\images\typora-user-images\image-20200908224734289.png" alt="image-20200908224734289" style="zoom:50%;" /></p>
    </li>
  </ul>
</blockquote>

<h3 id="definitions">Definitions</h3>

<ul>
  <li>
    <p><strong>Most significant bit</strong> and <strong>least significant bit</strong>:</p>

    <p><img src="\lectures\images\typora-user-images\image-20200908224943677.png" alt="image-20200908224943677" style="zoom:50%;" /></p>
  </li>
  <li>a <strong>byte</strong> is 8 bits
    <ul>
      <li>e.g.
        <ul>
          <li>$10101010$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>a <strong>nibble</strong> is basically 4 bits of $1$. Basically $1111$.</li>
  <li>
    <p>a <strong>word</strong> the nature data unit size for a machine</p>

    <ul>
      <li>e.g. 64 bits</li>
    </ul>
  </li>
</ul>

<h3 id="adding-binary-numbers">Adding Binary Numbers</h3>

<p>For example:</p>

<p><img src="\lectures\images\typora-user-images\image-20200908225431677.png" alt="image-20200908225431677" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p>notice the carry over becomes $2$, instead of $10$</p>
  </li>
  <li>
    <p>in this case, we also get an overflow since we expect a 6 bits</p>
  </li>
</ul>

<h3 id="hexadecimal-and-octal">Hexadecimal and Octal</h3>

<ul>
  <li>
    <p>Octal basically means <strong>base 8</strong></p>

    <ul>
      <li>
        <p>this means it can <strong>compress binary numbers</strong>:</p>

        <p><img src="\lectures\images\typora-user-images\image-20200908225608175.png" alt="image-20200908225608175" style="zoom:50%;" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p>Hexadecimal means <strong>base 16</strong>:</p>

    <ul>
      <li>again, also compressing data, but preferable since it is easier to read</li>
      <li>it is also exactly <em>half a byte</em> (which has 8 bits)</li>
      <li>however, since</li>
    </ul>

    <p><img src="\lectures\images\typora-user-images\image-20200908225758360.png" alt="image-20200908225758360" style="zoom:50%;" /></p>
  </li>
</ul>

<p>Hexadecimal is usually preferred since it is easier to parse for humans</p>

<p><img src="\lectures\images\typora-user-images\image-20200908225930999.png" alt="image-20200908225930999" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0x</code> is a prefix for hexadecimal</li>
</ul>

<h3 id="negative-numbers-and-2s-complement">Negative Numbers and 2’s Complement</h3>

<ul>
  <li>
    <p>2’s compliment basically means the <strong><em>MSB</em> has a negative contribution</strong></p>

    <ul>
      <li>
        <p>for example:</p>

        <p><img src="\lectures\images\typora-user-images\image-20200908230650969.png" alt="image-20200908230650969" style="zoom:50%;" /></p>
      </li>
    </ul>
  </li>
</ul>

<p>Intuitively, it means shifting half of your numbers to the left:</p>

<p><img src="\lectures\images\typora-user-images\image-20200908231110633.png" alt="image-20200908231110633" style="zoom:67%;" /></p>

<ul>
  <li>
    <p>this means that the sequence of counting changes to:</p>

    <p><img src="\lectures\images\typora-user-images\image-20200908231300283.png" alt="image-20200908231300283" style="zoom: 67%;" /></p>
  </li>
</ul>

<h4 id="negation-with-2s-compliment">Negation with 2’s Compliment</h4>

<p>This is the process that when you</p>

<ul>
  <li><strong>flip the bits and add one</strong></li>
</ul>

<p>you will get the negative version of your number.</p>

<p>For example:</p>

<p><img src="\lectures\images\typora-user-images\image-20200908231003458.png" alt="image-20200908231003458" style="zoom:50%;" /></p>

<blockquote>
  <p>This works because (suppose having a hexadecimal number):</p>

  <ul>
    <li>
      <p>if you just flip the bits and add the two number, you get: $11111 = (-16+8+4+2+1)$</p>
    </li>
    <li>
      <p>hence flipping the bit means computing $(-16+8+4+2+1)-whatever\,you\,had = -1 - whatever\,you\,had$</p>
      <ul>
        <li>therefore, you see where the additional $-1$ come from, hence to get a negative sign, you need to add the $1$ back</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p>Extension:</p>

  <ul>
    <li>If you use 1’s compliment, then you <strong>flip each number to get its negative</strong>:</li>
  </ul>

  <p><img src="\lectures\images\typora-user-images\image-20200908232814948.png" alt="image-20200908232814948" style="zoom:67%;" /></p>

  <p>​	where you <strong>take the negative sign of the non-one digit</strong></p>
</blockquote>

<h4 id="additionsubtraction-with-2s-compliment">Addition/Subtraction with 2’s Compliment</h4>

<p>Subtraction basically becomes adding a negative number</p>

<p>For example:</p>

<p><img src="\lectures\images\typora-user-images\image-20200908231551475.png" alt="image-20200908231551475" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>though you have 5 bits coming out, it is <strong>“not” an overflow</strong>, since if we only parse the 4 digits, we get the correct answer of 2</li>
</ul>

<blockquote>
  <p>This works because (assuming you don’t have an overflow):</p>

  <ul>
    <li>once adding up to the MSB, you either clear the $1$ to remove the negative sign, or you didn’t clear it meaning that the negative still persists.</li>
  </ul>
</blockquote>

<h3 id="representing-other-information">Representing Other Information</h3>

<p>Other number formats are represented:</p>

<p><img src="\lectures\images\typora-user-images\image-20200910222042468.png" alt="image-20200910222042468" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li><strong>fixed point</strong> means splitting the number of bits into two parts, one of them will represent the integer part, and the other will represent it as decimals
    <ul>
      <li>the deciding cutoff between integer and decimal part is fixed</li>
    </ul>
  </li>
  <li><strong>floating point</strong> means using</li>
</ul>

<h4 id="representing-characters-and-strings">Representing Characters and Strings</h4>

<p>A common standard is the ASCII table:</p>

<p><img src="\lectures\images\typora-user-images\image-20200910222456306.png" alt="image-20200910222456306" style="zoom:67%;" /></p>

<p>For example, converting to Hexadecimal:</p>

<p><img src="\lectures\images\typora-user-images\image-20200910222646035.png" alt="image-20200910222646035" style="zoom:67%;" /></p>

<blockquote>
  <p>How video streaming works:</p>

  <p><img src="\lectures\images\typora-user-images\image-20200910222839504.png" alt="image-20200910222839504" style="zoom:67%;" /></p>

  <p>where:</p>

  <ul>
    <li>the bitrate is of course capped by internet connections</li>
    <li>bitrate is intuitively proportional to:
      <ul>
        <li>FPS</li>
        <li>#pixel per frame</li>
        <li>#bits per pixel
          <ul>
            <li>relates to the quality of a pixel/frame</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="overflow">Overflow</h2>

<p>Overflow is when the <strong>magnitude of the of a number exceeds representing range</strong>.</p>

<ul>
  <li>this is an inherit, fundamental problem since we are representing unbounded numbers by some boundaries</li>
</ul>

<p>For example, adding $9+9$ in hexadecimal gets:</p>

<p><img src="\lectures\images\typora-user-images\image-20200908232306274.png" alt="image-20200908232306274" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>we get an overflow since we are expecting a 4 bit result, and parsing this 4 bits gives the <strong>wrong answer</strong></li>
</ul>

<h2 id="boolean-logic">Boolean Logic</h2>

<p>Every operation shown here has a physical corresponding in hardware.</p>

<h3 id="axioms">Axioms</h3>

<p>Most of the axioms can be easily understood using Venn Diagrams as an image.</p>

<ul>
  <li>
    <p>$XY=YX$, and $XX = X$</p>

    <ul>
      <li>basically $\cap$</li>
    </ul>

    <p><img src="\lectures\images\typora-user-images\image-20200910223721339.png" alt="image-20200910223721339" style="zoom:67%;" /></p>
  </li>
  <li>
    <p>$X+Y=Y+X$, and $X+X=X$</p>

    <ul>
      <li>basically $\cup$</li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20200910223858352.png" alt="image-20200910223858352" style="zoom:67%;" /></p>

<ul>
  <li>$Z(X+Y)=ZX+ZY$
    <ul>
      <li>distributing union and intersections</li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20200910224010744.png" alt="image-20200910224010744" style="zoom:67%;" /></p>

<p>In summary, you get:</p>

<p><img src="\lectures\images\typora-user-images\image-20200910224909193.png" alt="image-20200910224909193" /></p>

<p>where:</p>

<ul>
  <li>$+$ means <strong>or</strong>, which is equivalent as <strong>union</strong></li>
  <li>$\cdot$ means <strong>and</strong>, which is equivalent as <strong>intersection</strong></li>
  <li>$\bar{}$ means <strong>not</strong>, which is equivalent as <strong>not in</strong></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20200910224257722.png" alt="image-20200910224257722" /></p>

<h4 id="simplifying-boolean-expressions">Simplifying Boolean Expressions</h4>

<p>For example,</p>

<p>Consider the following expression:</p>

<p><img src="\lectures\images\typora-user-images\image-20200910225223639.png" alt="image-20200910225223639" style="zoom:67%;" /></p>

<p>Now, you can manipulate:
\(X+(\bar{X}\cdot Y) = (X+\bar{X})\cdot(X+Y) = X+Y\)
where:</p>

<ul>
  <li>it means you are either born in New York, or lived here ten years.</li>
</ul>

<hr />

<p>For example:</p>

<ul>
  <li>
    <p>Question:</p>

    <p>Simplify $X+Y(X+Z)+XZ$</p>
  </li>
  <li>
    <p>Solution:
\(X+YX+YZ+XZ = X(1+Y)+YZ+XZ= X+YZ+XZ\)
where:</p>

    <ul>
      <li>
        <p>$\cdot$ is omitted</p>
      </li>
      <li>
        <p>obviously $X+YX=X$, which you can think of using sets</p>
      </li>
    </ul>

    <p>If we continue:
\(X+YZ+XZ = X(1+Z)+YZ = X+YZ\)
where:</p>

    <ul>
      <li>the same procedure as above is done</li>
    </ul>
  </li>
</ul>

<hr />

<p>Another example:</p>

<hr />

<p><strong><em>For example:</em></strong></p>

<ul>
  <li>
    <p>Question:</p>

    <p>Simplify:
\(XYZ+X(\bar{Y}+\bar{Z})\)
where:</p>

    <ul>
      <li>again $\cdot$ is omitted</li>
    </ul>
  </li>
  <li>
    <p>Solution
\(XYZ+X(\bar{Y}+\bar{Z}) = X(YZ+\bar{Y}+\bar{Z})=X(YZ+\bar{Y}+(\bar{Z}+\bar{Z}Y))\)
since:</p>

    <ul>
      <li>$\bar{Z}=\bar{Z}\cdot 1=\bar{Z}(1+Y)=\bar{Z}+\bar{Z}Y$</li>
    </ul>

    <p>continuing:
\(X(YZ+\bar{Y}+(\bar{Z}+\bar{Z}Y))=X(Y(Z+\bar{Z})+\bar{Y}+\bar{Z})\\
= X(Y+\bar{Y}+\bar{Z})\\
= X(1+\bar{Z})\\
= X\)</p>
  </li>
</ul>

<hr />

<blockquote>
  <p>Notice:</p>

  <ul>
    <li>the precedence concurs with our normal mathematics intuition (e.g. $\cdot$ would have precedence over $+$), which you can just see it as a convention.</li>
    <li>the use of this is also enormous, as the <strong>number of operations is proportional to the number of hardware/logic gates you need.</strong></li>
  </ul>
</blockquote>

<p>We see some non-intuitive steps above, which hints at a need to <strong>systematically check whether if two given expression are the same</strong>.</p>

<ul>
  <li>obviously, a brute force approach to test each input/output pair would work</li>
</ul>

<h4 id="quiz-question">Quiz Question</h4>

<ul>
  <li>
    <p><strong>Question</strong></p>

    <p>Are the following expression the same?<br />
\(\bar{A}+C;\,\,\bar{A}+AC\)</p>
  </li>
  <li>
    <p><strong>Solution</strong></p>

    <p>This is counter-intuitive, but <strong>they are the same</strong>!
\(\begin{align*}
\bar{A}+C &amp;= \bar{A}(C+\bar{C})+C	\\
&amp;= \bar{A}C+\bar{A}\bar{C}+CA+C\bar{A} \\
&amp;= \bar{A}C+\bar{A}\bar{C}+C\bar{A}+AC	\\
&amp;=\bar{A}(C+\bar{C}+C)+AC \\
&amp;=\bar{A}(1)+AC \\
&amp;=\bar{A}+AC \\
\end{align*}\)</p>
  </li>
</ul>

<h3 id="circuits">Circuits</h3>

<p>In principle, every operation we do boils down to the three operations:</p>

<ul>
  <li><strong>and</strong> / $\cdot$
    <ul>
      <li><img src="\lectures\images\typora-user-images\image-20200910231625832.png" alt="image-20200910231625832" style="zoom:50%;" /></li>
    </ul>
  </li>
  <li><strong>not</strong> / $\bar{}$
    <ul>
      <li><img src="\lectures\images\typora-user-images\image-20200910231640389.png" alt="image-20200910231640389" style="zoom:50%;" /></li>
    </ul>
  </li>
  <li><strong>or</strong> / $+$
    <ul>
      <li><img src="\lectures\images\typora-user-images\image-20200910231611179.png" alt="image-20200910231611179" style="zoom:50%;" /></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Notice:</p>

  <ul>
    <li>though the diagram above looks simple, only involving one device, but that device also has some non-trivial implementations using transistors and etc. to change the voltage.</li>
  </ul>
</blockquote>

<p>At this point, you may wonder how the concept of set works in this context of hardware</p>

<blockquote>
  <p><strong><em>Ask a Question:</em></strong></p>

  <ul>
    <li>What is the graphical analogy of intersection in the <strong>actual</strong> bit operations? Set operations ignores the content, it doesn’t care whether it is $1$ or $0$, but logic gates will. So to me it’s almost magical how axioms derived using sets work in bit operations.</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Schematics Def</strong>:</p>

  <ul>
    <li>a schematic is a <strong>gate-level diagram/abstraction</strong> of a circuit, showing how those gates are connected to perform a certain operation.</li>
  </ul>
</blockquote>

<p>Other gates, such as <strong>XOR</strong>, will be based on those three gates.</p>

<h4 id="drawing-a-schematic-from-an-expression">Drawing a Schematic from an Expression</h4>

<p>Consider the following two expressions:</p>

<p><img src="\lectures\images\typora-user-images\image-20200910231854938.png" alt="image-20200910231854938" style="zoom:67%;" /></p>

<p>We draw their schematics.</p>

<p>For the <strong>first expression</strong></p>

<p><img src="\lectures\images\typora-user-images\image-20200910232412294.png" alt="image-20200910232412294" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>when wires cross, they are only <strong>electrically connected only if</strong> that junction is drawn with a <strong>solid dot</strong></li>
  <li>the last <strong>or gate</strong> took <strong><em>three inputs</em></strong>. In reality, some of the gates can accept multiple inputs (probable due to their associativity property)</li>
</ul>

<p>For the <strong>second expression</strong></p>

<p><img src="\lectures\images\typora-user-images\image-20200910232529140.png" alt="image-20200910232529140" style="zoom:67%;" /></p>

<blockquote>
  <p>Notice:</p>

  <ul>
    <li>for performance issues, obviously the total <em>number of gate</em> matters, as information has to transfer through them.
      <ul>
        <li>this is in fact known as <strong>gate size</strong></li>
      </ul>
    </li>
    <li>also, the <em>depth</em> of gates matters as well, which means the <strong>maximum number</strong> of gates that an information has to go through/longest path
      <ul>
        <li>this is also known as <strong>gate delay</strong>/<strong>critical path</strong></li>
      </ul>
    </li>
    <li>sometimes there is a trade-off between the two</li>
  </ul>
</blockquote>

<h1 id="week-2--canonical-forms">Week 2- Canonical Forms</h1>

<p>Canonical Forms are basically standard forms of writing an expression.</p>

<p>There are basically three canonical forms for an expression.</p>

<ul>
  <li>Truth Table</li>
  <li>Logical Gates Schematics</li>
  <li>Sum of Minterms/Product of Maxterms</li>
</ul>

<h2 id="truth-table">Truth Table</h2>

<p>Typically,  you write truth tables in <strong>numerical orders</strong>.</p>

<p>For example, if you have an expression $X+YZ$, the truth table can look like:</p>

<p><img src="\lectures\images\typora-user-images\image-20200915222738579.png" alt="image-20200915222738579" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>you basically cut the table in half and put the $1$’s and $0$’s, then start filling with $0$</li>
</ul>

<hr />

<p><strong><em>For example</em></strong>,</p>

<ul>
  <li>
    <p>Question:</p>

    <p>Use a truth table to prove that
\(\bar{XY} \neq \bar{X}\bar{Y}\)</p>
  </li>
  <li>
    <p>Solution:</p>

    <p><img src="\lectures\images\typora-user-images\image-20200915223131601.png" alt="image-20200915223131601" style="zoom:67%;" /></p>
  </li>
</ul>

<hr />

<h2 id="logic-gates">Logic Gates</h2>

<p>Obviously, in the end we need to implement the expression with logic gates:</p>

<p><img src="\lectures\images\typora-user-images\image-20200915223347069.png" alt="image-20200915223347069" style="zoom:67%;" /></p>

<p>which means:</p>

<ul>
  <li><strong>sometimes</strong> you can <strong><em>figure out the expression given the truth table only</em></strong></li>
</ul>

<p>In fact, there are also other operators that are useful in reality, but not yet mentioned before:</p>

<p><img src="\lectures\images\typora-user-images\image-20200915223720669.png" alt="image-20200915223720669" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p><strong>BUF</strong> stands for buffer, which currently does nothing</p>
  </li>
  <li>
    <p>used for strengthening electrical signals</p>
  </li>
  <li>
    <p>we basically express those “not”s with a little circle/bubble</p>

    <ul>
      <li>
        <p>which is why <strong>BUF</strong> looks like <strong>NOT</strong> gate with bubble taken away</p>
      </li>
      <li>
        <p>this means that you can also <strong>abbreviate</strong> expressions containing “not”s such as:</p>

        <p><img src="\lectures\images\typora-user-images\image-20200915223935862.png" alt="image-20200915223935862" /></p>
      </li>
    </ul>
  </li>
</ul>

<p>Lastly, we have those <strong>X</strong> gates</p>

<ul>
  <li><strong>X</strong> stands for <strong>exclusive</strong></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20200915224506193.png" alt="image-20200915224506193" /></p>

<p>where:</p>

<ul>
  <li>
    <p><strong>XOR</strong> means, it is true when there is exclusively/only one <em>true</em></p>
  </li>
  <li>
    <p><strong>XNOR</strong> would be the complement/inverse of <strong>XOR</strong></p>
  </li>
</ul>

<blockquote>
  <p>Note:</p>

  <ul class="task-list">
    <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />The gates defined above, by definition, can have more than 2 inputs.</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Extension</strong>:</p>

  <ul>
    <li>Due to properties of a transistor, the <strong>NAND</strong> gate is actually the physically smallest gate you can have.</li>
  </ul>
</blockquote>

<h3 id="replacing-gates-with-nand">Replacing Gates with NAND</h3>

<p>You can implement a</p>

<ul>
  <li><strong>NOT</strong> gate using a <strong>NAND</strong> gate:</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20200915224909015.png" alt="image-20200915224909015" /></p>

<ul>
  <li><strong>AND</strong> gate built from only <strong>NAND</strong> gates:</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20200915225007703.png" alt="image-20200915225007703" /></p>

<ul>
  <li>
    <p><strong>OR</strong> gate with only <strong>NAND</strong> gates:</p>

    <p><img src="\lectures\images\typora-user-images\image-20200915225438417.png" alt="image-20200915225438417" style="zoom:67%;" /></p>

    <p>where:</p>

    <ul>
      <li>you basically converted $\bar{X}\,or\,\bar{Y}=\bar{(X\,and\, Y)}=NAND(X,Y)$</li>
    </ul>
  </li>
</ul>

<p>Again, sometimes people do this in reality because <strong>NAND</strong> gates are physically really small.</p>

<h3 id="de-morgans-theorem">De Morgan’s Theorem</h3>

<p><img src="\lectures\images\typora-user-images\image-20200915225822117.png" alt="image-20200915225822117" /></p>

<p>So simply put, distributing <strong>NOT</strong> operator changes:</p>

<ul>
  <li><strong>AND</strong> to <strong>OR</strong></li>
  <li><strong>OR</strong> to <strong>AND</strong></li>
</ul>

<p>To remember De Morgan’s Theorem</p>

<p><img src="\lectures\images\typora-user-images\image-20200915230110634.png" alt="image-20200915230110634" /></p>

<p>where:</p>

<ul>
  <li>you first <strong>push the bubble through the gate</strong></li>
  <li>change the gate from <strong>AND</strong> to <strong>OR</strong>, or vice versa</li>
</ul>

<p>This means that you can use this theorem to <strong>convert schematics directly</strong> into their equivalent form.</p>

<ul>
  <li>if there are no bubbles, you can insert pairs of them and then convert</li>
</ul>

<hr />

<p><strong><em>For example:</em></strong></p>

<ul>
  <li>
    <p>Question:</p>

    <p>Convert the following schematic to only include <strong>NAND</strong> gates.</p>

    <p><img src="\lectures\images\typora-user-images\image-20200915230507053.png" alt="image-20200915230507053" style="zoom:67%;" /></p>
  </li>
  <li>
    <p>Solution:</p>

    <p><img src="\lectures\images\typora-user-images\image-20200915230526868.png" alt="image-20200915230526868" style="zoom:67%;" /></p>

    <p>where:</p>

    <ul>
      <li>you start by putting some <strong>NAND</strong> gates, and then try to convert the other non-trivial ones to <strong>NAND</strong></li>
    </ul>
  </li>
</ul>

<h2 id="maxtermminterms">Maxterm/Minterms</h2>

<p>Some terminologies:</p>

<ul>
  <li><strong>Complement</strong>
    <ul>
      <li>basically the <strong><em>not</em></strong> operator</li>
    </ul>
  </li>
  <li><strong>Literal</strong></li>
  <li><strong>Implicant</strong>
    <ul>
      <li>a product term (basically <strong>and</strong>)</li>
      <li>e.g.
        <ul>
          <li>$A\bar{B}C$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Minterm</strong>
    <ul>
      <li>a product <strong><em>(and) of each variable or its complement</em></strong>
        <ul>
          <li>in fact, each variable is complemented if the value assigned to it is 0, and uncomplemented if it is 1</li>
        </ul>
      </li>
      <li>e.g. for inputs $A,B,C,D$
        <ul>
          <li>$A\bar{B}CD$, and etc</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Maxterm</strong>
    <ul>
      <li>a sum <strong><em>(or) of each variable or its complement</em></strong></li>
      <li>e.g. for inputs $A,B,C,D$
        <ul>
          <li>$A+\bar{B}+C+D$, and etc</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Theorem:</p>

  <ul>
    <li>Each row of a truth table has an associate 1-minterm, <strong>such that the minterm is 1/true <em>only</em> in that row/case</strong>.</li>
  </ul>
</blockquote>

<p>For example:</p>

<p><img src="\lectures\images\typora-user-images\image-20200915231723683.png" alt="image-20200915231723683" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p>the name of a minterm $m_i$ depends on the <strong><em>sequence of your truth table</em></strong> (e.g. which row it is on)</p>
  </li>
  <li>
    <p>finding a minterm is trivial as you can just flip all the $0$ entry to be $1$</p>
  </li>
  <li>
    <p>finding a minterm could involve writing out a Truth table and figuring it out</p>
  </li>
</ul>

<p>Similarly, for maxterms:</p>

<blockquote>
  <p>Theorem</p>

  <ul>
    <li>Each row of a truth table has an associate 0-maxterm, <strong>such that the maxterm is 0/false <em>only</em> in that row/case</strong></li>
  </ul>
</blockquote>

<p>For example:</p>

<p><img src="\lectures\images\typora-user-images\image-20200915234011591.png" alt="image-20200915234011591" /></p>

<h3 id="sum-of-1-minterms">Sum of 1-Minterms</h3>

<p>Since Minterms are only <strong><em>true at that specific condition</em></strong>, you can <strong>decompose any expressions into sum of some minterms.</strong></p>

<p>An sample usage is:
\(XOR(x,y)=\bar{x}y+x\bar{y}\)</p>

<hr />

<p><strong><em>For example</em></strong></p>

<ul>
  <li>
    <p>Question:</p>

    <p>Find an equivalent expression of the below:</p>

    <p><img src="\lectures\images\typora-user-images\image-20200915232300505.png" alt="image-20200915232300505" style="zoom:67%;" /></p>
  </li>
  <li>
    <p>Solution:</p>

    <p><img src="\lectures\images\typora-user-images\image-20200915232312683.png" alt="image-20200915232312683" style="zoom:67%;" /></p>

    <p>where:</p>

    <ul>
      <li>$f(x,y,z)=m_1+m_3+m_4+m_5=\sum m(1,3,4,5)$</li>
    </ul>
  </li>
</ul>

<hr />

<p>This means that you can pretty easily <strong><em>construct a function</em></strong> once you know the behavior of outputs and inputs.</p>

<h3 id="product-of-0-maxterms">Product of 0-Maxterms</h3>

<p>Since maxterms/0-maxterms evaluate to <strong><em>$0$ only in that case and $1$ in all the other case</em></strong>:</p>

<ul>
  <li>any Boolean function can be expressed as a <strong>product (AND) of its 0-maxterms</strong></li>
</ul>

<p>For example:</p>

<p><img src="\lectures\images\typora-user-images\image-20200918001812247.png" alt="image-20200918001812247" /></p>

<p>where:</p>

<ul>
  <li>the idea is reverse as compared to the sum of minterms, here we drive <strong>all the others to $0$</strong> once we hit a $0$.</li>
</ul>

<h3 id="sum-of-products-and-product-of-sums">Sum of Products and Product of Sums</h3>

<p>In short, you have:</p>

<p><img src="\lectures\images\typora-user-images\image-20200918003255309.png" alt="image-20200918003255309" /></p>

<p>where:</p>

<ul>
  <li><strong>SoP</strong> means sum of products</li>
  <li><strong>PoS</strong> means product of sums</li>
  <li><strong>SoMin</strong> means sum of minterms</li>
  <li>
    <p><strong>PoMax</strong> means product of maxterms</p>
  </li>
  <li>a <strong>star</strong> denote expressions that are unique, namely <strong>PoMax</strong> and <strong>SoMin</strong> is <strong>unique for each function</strong>
    <ul>
      <li>which is why they are canonical terms</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Note:</p>

  <ul>
    <li>$x+y$ is neither a SoMin nor PoMax, because we have <strong>three variables/literals</strong>, but the expression only involves two.
      <ul>
        <li>this is because <strong>a min/maxterm</strong> needs <strong><em>each variable/literal to be involved exactly once</em></strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="converting-between-sop-and-pos">Converting between SoP and PoS</h4>

<p>Basically, to convert between sum of product expression to a product of sum, you need to <strong><em>first add a negation</em></strong>, so that <strong>and</strong> and <strong>or</strong> can be switched:</p>

<p>For example, converting any <strong>SoP</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20200918004528729.png" alt="image-20200918004528729" /></p>

<p>In general, you always need to add a <strong>negation</strong> so that <strong>and</strong> and <strong>or</strong> can be flipped, <strong><em>hence you can convert.</em></strong></p>

<p><img src="\lectures\images\typora-user-images\image-20200918004601318.png" alt="image-20200918004601318" /></p>

<p>where:</p>

<ul>
  <li>the caveat is of course that the <strong>result you get would be opposite</strong>.</li>
</ul>

<h2 id="karnaugh-map-k-maps">Karnaugh Map (K-maps)</h2>

<p>A truth table redrawn, such that <strong>adjacency becomes meaningful</strong>.</p>

<p>In the end, it helps you convert certain circuits/outputs and inputs to an expression.</p>

<p><img src="\lectures\images\typora-user-images\image-20200918005542914.png" alt="image-20200918005542914" /></p>

<p>where:</p>

<ul>
  <li>the <strong>four results</strong> becomes a matrix</li>
  <li>basically just redrawing a truth table</li>
</ul>

<h3 id="simplification-via-k-map">Simplification via K-map</h3>

<p>A property of a K-map is:</p>

<ul>
  <li>When two cells <strong>share an edge and are both $1$,</strong> those two terms can be combined to form a single, simpler term.</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20200918010148761.png" alt="image-20200918010148761" /></p>

<p>where:</p>

<ul>
  <li>this <strong>works</strong> simply because their can <strong>only be 2 possible values for a variable</strong>. If a continuous row is $1$, then it means that variable determines the state</li>
  <li>always try to get <strong><em>prime implicants</em></strong> covering all entries, but <strong>not</strong> <strong><em>essential prime implicants</em></strong></li>
</ul>

<h3 id="rules-on-a-k-map">Rules on a K-map</h3>

<p>In the end, it helps you construct the function by using a <strong>Sum of products</strong></p>

<ol>
  <li>Add circles until all $1$s on the k-map are circled
    <ul>
      <li>for each circle, there is a corresponding expression</li>
    </ul>
  </li>
  <li>Circle contiguous groups of $1$s (since the system is binary, sizes of circle must be power of $2$).
    <ul>
      <li>the bigger the circle, the simpler the term</li>
    </ul>
  </li>
  <li>Get Prime Implicants
    <ul>
      <li>a <strong>Prime Implicant</strong> is a circle that can <strong><em>not be drawn any bigger</em></strong>. Namely, you produce the <em>simplest minterm</em></li>
    </ul>
  </li>
  <li>Get Essential Prime Implicants
    <ul>
      <li>an <strong>Essential Prime Implicant</strong> is a circle that <strong><em>uniquely covers a $1$.</em></strong>
        <ul>
          <li>basically, removing that circle causes some $1$ to be uncovered</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p><strong>Note:</strong></p>

  <ul class="task-list">
    <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />The above works the same if you are doing a <strong>Product of Sums</strong>, where you just <strong>circle the 0s</strong>.</li>
  </ul>
</blockquote>

<h3 id="3-variable-karnaugh-map">3-Variable Karnaugh Map</h3>

<p>Theoretically, you need to go in 3-dimension. However, this can be simplified by using a gray ordering:</p>

<ul>
  <li><strong>gray ordering</strong> on edges means ordering of bits such that exactly <strong><em>value of one bit change at a time</em></strong></li>
</ul>

<blockquote>
  <p>This is because, if you actually imagine a 2x2x2 cube, every neighboring cell has the property that they have only one bit difference</p>
</blockquote>

<p>This also means that, since we are technically in 2-D:</p>

<ul>
  <li><strong>two terms are adjacent</strong> if they differ only in one variable (namely this map <strong><em>wraps around</em></strong>)</li>
</ul>

<blockquote>
  <p>Because in 2x2x2 cube, each cell has 3-neighboring cell. This can be achieved via horizontal wrapping so that edge cells have 3 neighboring cells.</p>
</blockquote>

<p>For example, your k-map looks like:</p>

<p><img src="\lectures\images\typora-user-images\image-20200918012051160.png" alt="image-20200918012051160" /></p>

<p>where:</p>

<ul>
  <li>the <strong>top row has only one bit change at a time</strong>
    <ul>
      <li>instead of $01 \to 10$, which changed two bits</li>
    </ul>
  </li>
</ul>

<p>And the circling becomes:</p>

<p><img src="\lectures\images\typora-user-images\image-20200918012153988.png" alt="image-20200918012153988" /></p>

<p>where:</p>

<ul>
  <li><strong>purple</strong> (size 4) and <strong>blue</strong> (size 2) is the optimal grouping
    <ul>
      <li>$\bar{A}B+\bar{C}$</li>
    </ul>
  </li>
  <li>two <strong>green</strong> (size 2) and <strong>blue</strong> (size 2) is a correct grouping, but not optimal
    <ul>
      <li>$\bar{A}B+\bar{BC}+B\bar{C}$</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Notice:</p>

  <ul>
    <li>
      <p>The <strong>number of variables in an <em>term</em></strong> corresponds to $k:2^{k}\times size = 2^{n}$</p>

      <p>where</p>

      <ul>
        <li>$size$ is the size of a circle, which has to be a power of 2</li>
        <li>$n$ is the total number of variables</li>
      </ul>
    </li>
    <li>
      <p><em>For example, the purple circle above has size 4, and the corresponding term only involved 1 term.</em></p>
    </li>
  </ul>
</blockquote>

<h3 id="k-map-design-example-full-adder">K-Map Design Example: Full Adder</h3>

<p>Basically we want to do <strong>addition for two bits</strong>, and then in the end implement multi-bit addition.</p>

<p>First, we think about an actual addition:</p>

<p><img src="\lectures\images\typora-user-images\image-20200922222031412.png" alt="image-20200922222031412" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>we see that we always need a <strong>carry-in</strong> and a <strong>carry-out</strong> in addition to out inputs</li>
</ul>

<p><strong>STEP 1:</strong> Therefore, this would be the look of our <strong>design/interface</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20200922222209461.png" alt="image-20200922222209461" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>we don’t know how to build the <strong>full adder part yet</strong></li>
</ul>

<p><strong>STEP 2:</strong> But, we do know the inputs, hence we can build a <strong>truth table:</strong></p>

<p><img src="\lectures\images\typora-user-images\image-20200922222402467.png" alt="image-20200922222402467" style="zoom:67%;" /></p>

<p><strong>STEP 3:</strong> Use K-map to build and simplify the <strong>logic expression</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20200922223208478.png" alt="image-20200922223208478" style="zoom:67%;" /></p>

<p>where</p>

<ul>
  <li>
    <p>the <strong>sum</strong> is actually an <strong>XOR</strong> combination: $a\,XOR\,b\,XOR\,c_{in}$</p>
  </li>
  <li>
\[(a\,XOR\,b)\,XOR\,c_{in}\]

    <p><img src="\lectures\images\typora-user-images\image-20200922223429644.png" alt="image-20200922223429644" style="zoom: 67%;" /></p>
  </li>
</ul>

<h3 id="k-map-design-example-voting-circuit">K-Map Design Example: Voting Circuit</h3>

<p>Suppose we have four voters voting on 2 choices, we could build a circuit to decide a <strong>tie</strong> or there is a <strong>winner</strong></p>

<ul>
  <li>if $T=1$, it means there is a tie, $T=0$ if otherwise</li>
  <li>if $W=1$, it means choice $1$ wins, and $W=0$ means choice $0$ wins.
    <ul>
      <li>notice that if you have a <strong>tie, $W$ does not matter anymore</strong></li>
    </ul>
  </li>
</ul>

<p><strong>STEP 1: Skipped</strong></p>

<p>**STEP 2: ** the truth table design:</p>

<p><img src="\lectures\images\typora-user-images\image-20200922224636761.png" alt="image-20200922224636761" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>$X$ <strong>don’t cares</strong> comes in naturally</li>
  <li>if you have a <strong>don’t care</strong>, then there is <strong><em>usually a “validator” output, which in this case is $T$</em></strong></li>
</ul>

<p><strong>STEP 3:</strong> the K-map and the actual logic expression:</p>

<p><img src="\lectures\images\typora-user-images\image-20200922225129541.png" alt="image-20200922225129541" style="zoom:67%;" /></p>

<p>and the <strong>tie $T$</strong> K-map is skipped for your own practice.</p>

<h3 id="dont-cares">Don’t Cares</h3>

<p>Don’t cares also appear in truth table outputs where the <strong>output value is unimportant</strong> or the <strong>corresponding input combination can never be achieved</strong>.</p>

<ul>
  <li>basically, we do not care whether if that output is 1 or 0, both are fine.</li>
</ul>

<p>However, since such outputs (don’t cares) can be <strong>treated as either 0’s or 1’s at the designer’s discretion</strong>, we can use it to simplify our K-maps.</p>

<ul>
  <li>For example:</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20200926143143774.png" alt="image-20200926143143774" /></p>

<h1 id="week-3---delay-model">Week 3 - Delay Model</h1>

<p>First realize that computation takes time, because:</p>

<ul>
  <li>electricity travels with a velocity</li>
  <li>flipping from $0$ to $1$ also has time lag due to electrical properties such as capacitance.</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20200922225617727.png" alt="image-20200922225617727" style="zoom:67%;" /></p>

<h2 id="delay-time">Delay Time</h2>

<p>Hence we need to use some sort of a <strong>delay model:</strong></p>

<ul>
  <li><strong>propagation delay</strong> $t_{pd}$
    <ul>
      <li>the <strong><em>maximum</em></strong> delay from any input wire to any output wire</li>
    </ul>
  </li>
  <li><strong>contamination delay</strong> $t_{cd}$
    <ul>
      <li>the <strong><em>minimum</em></strong> delay from any input wire to any output wire</li>
    </ul>
  </li>
</ul>

<p>Obviously, in reality, for most <strong><em>computations</em></strong>, all we care is the <strong><em>propagation delay</em></strong>. But when it comes that we are dealing with computer <strong><em>memories</em></strong>, we might need to deal with <strong><em>contamination delay</em></strong>.</p>

<h2 id="critical-long-path--short-path">Critical (Long) Path &amp; Short Path</h2>

<ul>
  <li><strong>critical path</strong>
    <ul>
      <li>is the longest delay from any input to any output</li>
    </ul>
  </li>
  <li><strong>short path</strong>
    <ul>
      <li>is the shortest delay from any input to any output</li>
    </ul>
  </li>
</ul>

<p>For example:</p>

<p><img src="\lectures\images\typora-user-images\image-20200922230739229.png" alt="image-20200922230739229" /></p>

<p>where:</p>

<ul>
  <li>critical path uses $t_{pd}$ and short path uses $t_{cd}$</li>
</ul>

<h2 id="glitches">Glitches</h2>

<p>A glitch is a <strong>transient</strong> unwanted <strong>pulse</strong> on a circuit’s output.</p>

<p><img src="\lectures\images\typora-user-images\image-20200922230856928.png" alt="image-20200922230856928" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>this means that we <strong>cannot</strong> read the value <strong>during the glitch time</strong>, somehow we need to make sure to avoid it</li>
  <li><strong><em>triggered when one critical input falls before others being able to recover it</em></strong>
    <ul>
      <li>see the example in the next section</li>
    </ul>
  </li>
</ul>

<h3 id="glitch-example">Glitch Example</h3>

<p>Consider having $A=0$, $B$ had a glitch, and $C=1$ for the following schematics:</p>

<p><img src="\lectures\images\typora-user-images\image-20200922231750155.png" alt="image-20200922231750155" style="zoom:67%;" /></p>

<p>and suppose we have a transient $B$, such that we would have a <strong>timing diagram:</strong></p>

<p><img src="\lectures\images\typora-user-images\image-20200922232146458.png" alt="image-20200922232146458" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>the horizontal axis would be <strong>time</strong>, since it is a <strong>timing diagram</strong></li>
  <li>and we see that there are delays, which <strong>propagates</strong> throughout the diagram</li>
  <li><strong>glitch happens since your <em>shortest path</em> switches/glitches to $0$ before any other path recovers</strong></li>
</ul>

<p>==Consider the other case where $B$ rises from $0$ to $1$. In this case, no glitch happens.==</p>

<h3 id="preventing-single-input-glitches">Preventing Single Input Glitches</h3>

<p>The idea is to somehow:</p>

<ul>
  <li>keep the behavior of the original circuit
    <ul>
      <li>have the same k-map</li>
    </ul>
  </li>
  <li>add an “input” that is <strong>independent</strong> of the glitching bit to smooth the signal</li>
</ul>

<p><strong>STEP 1:</strong> reverse engineer the necessary part of the K-map:</p>

<p><img src="\lectures\images\typora-user-images\image-20200922233157659.png" alt="image-20200922233157659" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>we realize that the glitch was with $B$ jumping between the blue circle</li>
  <li>in order to <strong>not change the original schematic</strong>, we simply <strong>add a circle on top of the original design</strong>
    <ul>
      <li>notice this <strong>blue circle is independent of $B$</strong></li>
    </ul>
  </li>
</ul>

<p><strong>STEP 2:</strong> add the additional circle to the schematic:</p>

<p><img src="\lectures\images\typora-user-images\image-20200922233359071.png" alt="image-20200922233359071" style="zoom:67%;" /></p>

<p>and we have fixed the glitch as the <strong>blue part</strong> will be <strong>glitch-free</strong> and keeps the <strong>original design intact</strong>.</p>

<h1 id="week-4---combinational-building-blocks">Week 4 - Combinational Building Blocks</h1>

<h2 id="ripple-carry-adder">Ripple Carry Adder</h2>

<p>The most basic algorithm for addition</p>

<p><img src="\lectures\images\typora-user-images\image-20200929221920180.png" alt="image-20200929221920180" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>you have a <strong>critical path being $O(n)$,</strong> where $n$ is the $n-$bit adder we are having.
    <ul>
      <li>basically from the right most adder to the left most adder/output</li>
    </ul>
  </li>
</ul>

<h2 id="overflow-detection">Overflow Detection</h2>

<p>Though it is simple when you have an unsigned bit, for a sign bit(s) additions, we need to look at their <strong>MSBs (A,B)</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20200929222959972.png" alt="image-20200929222959972" style="zoom:80%;" /></p>

<p>where:</p>

<ul>
  <li>if you have <strong>a positive number and a negative number</strong>, in a 2s-complement system you can <strong>never overflow</strong></li>
  <li>if you have both positive or both negative, only the <strong>red parts</strong> are giving wrong answers, <strong>hence overflow</strong>.</li>
</ul>

<p>By inspection, we see that:</p>

<p><img src="\lectures\images\typora-user-images\image-20200929223131304.png" alt="image-20200929223131304" style="zoom: 80%;" /></p>

<p>Therefore, our <strong>overflow detection for ripple carry adder would be the adding the $XOR$</strong></p>

<p><img src="\lectures\images\typora-user-images\image-20200929223251433.png" alt="image-20200929223251433" /></p>

<h2 id="addersubtractor-variant">Adder/Subtractor Variant</h2>

<p>Consider we would like to have a unit being able to do both add and subtract:</p>

<ul>
  <li>
    <p>$sub=0$ means $A+B$</p>
  </li>
  <li>
    <p>$sub=1$ means $A-B=A+(-B)$</p>

    <ul>
      <li>
        <p>this will be done by <strong>negation</strong>, namely flip all the bits and add one</p>
      </li>
      <li>
        <p>to flip the bits:</p>

        <p><img src="\lectures\images\typora-user-images\image-20200929224546272.png" alt="image-20200929224546272" style="zoom:67%;" /></p>

        <p>where:</p>

        <ul>
          <li>we see that this is basically a $XOR$ gate.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Therefore, our implementation looks like:</p>

<p><img src="\lectures\images\typora-user-images\image-20200929225438165.png" alt="image-20200929225438165" style="zoom:80%;" /></p>

<p><strong><em>However, notice that the order of flipping and adding matters:</em></strong></p>

<ul>
  <li>
    <p>$1011 - 0100 - 0101$ (flip then add; the correct way)</p>
  </li>
  <li>
    <p>$1011 - 1100 - 0011$ (add then flip)</p>
  </li>
</ul>

<h2 id="carry-lookahead-adder">Carry Lookahead Adder</h2>

<p>This has a <strong>shorter critical path, but uses more gates</strong>.</p>

<p>Consider the <strong>Carry outs</strong>:
\(\begin{align*}
C_{i+1}&amp;=A_iB_i+A_iC_i + B_iC_i	\\
&amp;= A_iB_i + C_i(A_i + B_i)	\\
&amp;= G_i + C_i P_i
\end{align*}\)
where:</p>

<ul>
  <li><strong>Generate $G$</strong>: sets carry out regardless of carry in</li>
  <li>
    <p><strong>Propagate $P$</strong>: sets carry out if there is a carry in</p>
  </li>
  <li>basically <strong><em>pre-determines if there would be a carry out</em></strong></li>
</ul>

<p><strong>This will have a delay time of $O(log_2(n))$</strong></p>

<h3 id="expanding-the-carry-logic">Expanding the Carry Logic</h3>

<p><img src="\lectures\images\typora-user-images\image-20200929230600594.png" alt="image-20200929230600594" style="zoom: 80%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p>we have made the carries only dependent on $A$ and $B$ inputs, but <strong>not the previous carry-ins</strong>.</p>
  </li>
  <li>
    <p>this will generate a parallel <strong><em>tree</em></strong> of gates, but they adds the <strong><em>width</em></strong> rather than <strong><em>depth</em></strong></p>
  </li>
</ul>

<h3 id="schematic-of-the-adder">Schematic of the Adder</h3>

<p><img src="https://www.nandland.com/vhdl/modules/images/carry-lookahead-adder-4-bit.png" alt="Carry Lookahead Adder in VHDL and Verilog with Full-Adders" /></p>

<p>where:</p>

<ul>
  <li>the <strong>critical path reduced from $O(n)\to O(log_2(n))$</strong></li>
</ul>

<h2 id="decoders">Decoders</h2>

<p>Decoders are like adders, where of course you have many implementations of decoders based on size of inputs and needs.</p>

<p>The general functionality is:</p>

<ul>
  <li>$k$ bit input</li>
  <li>$2^k$ bits output</li>
  <li><strong>one-hot</strong> outputs: only one output will be $1$, all others are $0$
    <ul>
      <li>you can imagine this as <strong><em>minterms</em></strong>, so that <strong>each unique combination has a unique output</strong></li>
    </ul>
  </li>
  <li><strong>the input</strong> determines which output will be $1$</li>
</ul>

<p>General Design:</p>

<p><img src="\lectures\images\typora-user-images\image-20200929231627156.png" alt="image-20200929231627156" style="zoom:80%;" /></p>

<p>For example:</p>

<p><img src="\lectures\images\typora-user-images\image-20200929231544315.png" alt="image-20200929231544315" style="zoom:80%;" /></p>

<p>where:</p>

<ul>
  <li>you turned a number into a <strong><em>spatial value</em></strong></li>
</ul>

<h3 id="24-decoder">2:4 Decoder</h3>

<p>How do we implement a $2:4$ Decoder?</p>

<p>First, a $1:2$ decoder would be:</p>

<p><img src="\lectures\images\typora-user-images\image-20200929232459689.png" alt="image-20200929232459689" /></p>

<p>Then, we compose a $2:4$ Decoder:</p>

<p><img src="\lectures\images\typora-user-images\image-20200929232042799.png" alt="image-20200929232042799" style="zoom:80%;" /></p>

<h3 id="38-decoder">3:8 Decoder</h3>

<p>Now, you can <strong>implement this recursively</strong> based on the $2:4$ Decoder and the $1:2$ Decoder:</p>

<p><img src="\lectures\images\typora-user-images\image-20200929232353258.png" alt="image-20200929232353258" style="zoom:80%;" /></p>

<p>where:</p>

<ul>
  <li>the concept of <strong><em>minterms</em></strong> apply nicely, so that <strong>each wire/output corresponds to a unique combination of their inputs.</strong>
    <ul>
      <li>therefore, they can be used easily for building on to produce a larger decoder</li>
    </ul>
  </li>
</ul>

<h3 id="logic-implementation-using-decoder">Logic Implementation Using Decoder</h3>

<p>Consider the following truth table:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002000443161.png" alt="image-20201002000443161" /></p>

<p>We can <strong>use a decoder to implement it</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002000344972.png" alt="image-20201002000344972" /></p>

<p>where:</p>

<ul>
  <li>we are basically using the <strong>sum of minterms</strong> representation of the expression
    <ul>
      <li>and we know that sum of minterms are not physically ideal themselves</li>
    </ul>
  </li>
  <li>since decoders actually implements minterms for all outputs (i.e. 8) of them, they are redundant because we only need 4 in the end (in this case)</li>
</ul>

<p>So this is usually not a resource efficient approach</p>

<h2 id="encoders">Encoders</h2>

<p>Reversing the decoder: $2^k$ bits one-hot input, $k$ bits output.</p>

<p>But what if you are not given one-hot inputs, but any random bit patterns?</p>

<p>One way to “deal” with it is to use a <strong>priority encoder</strong></p>

<h3 id="42-priority-encoder">4:2 Priority Encoder</h3>

<p>Basically, a priority encoder only <strong>deal with $1$ at the MSB</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002001306381.png" alt="image-20201002001306381" /></p>

<p>where:</p>

<ul>
  <li>outputs are $O_1$ and $O_0$
    <ul>
      <li>so <strong>that $O_1O_0$ tells you the position of the MSB of $1$.</strong></li>
    </ul>
  </li>
  <li>a validator/valid bit is $V$, which tells us whether if output is correct</li>
  <li>inputs are $I_3,I_2,I_1,I_0$</li>
</ul>

<p>The corresponding expression for the three outputs (including $V$) would be:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002001700535.png" alt="image-20201002001700535" /></p>

<h2 id="multiplexer-mux">Multiplexer (Mux)</h2>

<p><strong>Select between one of $N$ inputs/wires</strong>, which one to use.</p>

<ul>
  <li>this in fact takes $log_2n$ delay</li>
</ul>

<p>For example:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002002407432.png" alt="image-20201002002407432" /></p>

<p>where:</p>

<ul>
  <li><strong>$S$ selects which input to be let through</strong></li>
</ul>

<p>If we write out the truth table logic for this case, we have:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002002532331.png" alt="image-20201002002532331" /></p>

<p>And you can figure out the schematic implementation from it. But there is **a natural way to implement it with a decoder ** (see <a href="#4:1 Mux">4:1 Mux</a>).</p>

<h3 id="41-mux">4:1 Mux</h3>

<p>Basically, this means we need</p>

<p><img src="\lectures\images\typora-user-images\image-20201002002710218.png" alt="image-20201002002710218" /></p>

<p>where:</p>

<ul>
  <li>two select bits $S$ are needed</li>
</ul>

<p>A natural implementation would be <strong>using a decoder</strong> for the select bit:</p>

<ul>
  <li>so that basically the value of $S_1S_0$ determine which one-hot value to have:</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201002002929171.png" alt="image-20201002002929171" /></p>

<p>where:</p>

<ul>
  <li>$S=S_1S_0$ is 2 bits.</li>
</ul>

<h3 id="logical-implementation-using-mux">Logical Implementation using Mux</h3>

<p>Again, this is not a resource efficient way to do it, but it is achievable.</p>

<p>Consider the following truth table:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002003321361.png" alt="image-20201002003321361" /></p>

<p>And using MUX, we can have <strong>a 8 input Mux</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002003411885.png" alt="image-20201002003411885" /></p>

<p>where:</p>

<ul>
  <li>$S=ABC$</li>
</ul>

<p>Or a <strong>4 input Mux:</strong></p>

<p><img src="\lectures\images\typora-user-images\image-20201002003710761.png" alt="image-20201002003710761" /></p>

<p>where:</p>

<ul>
  <li>$S=AB$</li>
</ul>

<p>If we continue, we can also build a <strong>2 Input Mux</strong> by having $S=A$.</p>

<h2 id="shifters">Shifters</h2>

<p>Basically, they implement the bitwise shift operation, so that I can <strong>shift input bits to the left or to the right</strong>.</p>

<p>In general, there are two variants:</p>

<ul>
  <li>Barrel: control bit indicate how far to left or right</li>
  <li>L/R with enable: control bit enables shifting, another bit indicate direction</li>
</ul>

<p>And to deal with the bits falling off, you may either:</p>

<ul>
  <li>just fill with either $1$ or $0$</li>
  <li>wrap around</li>
</ul>

<h3 id="4-bit-barrel-left-shifter-with-wraparound">4-bit Barrel Left Shifter with Wraparound</h3>

<p>Basically, consider a <strong>2-bit $dist$ control bit</strong> to tell you how far to shift.</p>

<ul>
  <li>this can be implemented using 4-Input Mux</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201002005137365.png" alt="image-20201002005137365" /></p>

<h1 id="week-5">Week 5</h1>

<h2 id="holding-state-bistable-elements">Holding State: Bistable Elements</h2>

<p>Here, we are trying to implement a circuit that can retain $1$ or $0$:</p>

<p>The below two circuits are identical:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002010648176.png" alt="image-20201002010648176" style="zoom:80%;" /></p>

<p>where:</p>

<ul>
  <li>the <strong>right hand side one is the more conventional one</strong></li>
</ul>

<p>Hence, just <strong>by feeding $1$ or $0$ into $Q$, we would be able to hold its state:</strong></p>

<p><img src="\lectures\images\typora-user-images\image-20201002010811557.png" alt="image-20201002010811557" style="zoom:80%;" /></p>

<p>However, the problem is that <strong>both $Q$ and $\overline{Q}$ are (the same) outputs</strong>. So we <strong>cannot control their states, as they are basically “<code class="language-plaintext highlighter-rouge">final</code>” variables.</strong></p>

<h2 id="rs-latch">RS Latch</h2>

<p>RS Latch means <strong>Reset-Set Latch</strong>. It stores a <strong>single</strong> <strong>state, called $Q$.</strong></p>

<p>This latch would be a way to <strong>control your state, while persisting it</strong>.</p>

<ul>
  <li>We will have two inputs: $S$ and $R$ to control the behavior of $Q$, such that:</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201002012153156.png" alt="image-20201002012153156" style="zoom:80%;" /></p>

<p>and it will have the following implementation:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002012253322.png" alt="image-20201002012253322" style="zoom:80%;" /></p>

<p>with the following abstraction:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002012309550.png" alt="image-20201002012309550" style="zoom:80%;" /></p>

<p>To understand how it works, look at its subsections.</p>

<h3 id="rs-latch---set">RS Latch - Set</h3>

<p>The set command that has:</p>

<ul>
  <li>$S=1$
    <ul>
      <li>$Set=1$ will <strong>set $Q \to 1$.</strong></li>
    </ul>
  </li>
  <li>$R=0$</li>
</ul>

<p>Basically, we want to show that in this case, you will have:</p>

<ul>
  <li>$Q=1$</li>
  <li>$\bar{Q}=0$</li>
</ul>

<p>Basically, this row:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002011900421.png" alt="image-20201002011900421" style="zoom:80%;" /></p>

<p>Now, consider <strong>putting in the $S$ and $R$ value in the circuit</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201002011624227.png" alt="image-20201002011624227" style="zoom:80%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p>the green $0$ indicate that those are <strong><em>implied by the truth table</em></strong></p>

    <p><img src="\lectures\images\typora-user-images\image-20201002011730722.png" alt="image-20201002011730722" style="zoom:67%;" /></p>

    <p>so that <strong>whenever $S=1$, the result $\overline{Q}$ has to be $0$.</strong> And the rest follows.</p>
  </li>
</ul>

<h3 id="rs-latch---reset">RS Latch - Reset</h3>

<p>The reset command that has:</p>

<ul>
  <li>$S=0$</li>
  <li>$R=1$
    <ul>
      <li>$Reset=1$ will <strong>reset $Q \to 0$.</strong></li>
    </ul>
  </li>
</ul>

<p>Basically, we want to show that in this case, you will have:</p>

<ul>
  <li>$Q=0$</li>
  <li>$\bar{Q}=1$</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201006222447920.png" alt="image-20201006222447920" style="zoom:80%;" /></p>

<p>And this schematic becomes:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006222528207.png" alt="image-20201006222528207" /></p>

<p>where:</p>

<ul>
  <li>the green $0$ indicate that those are <strong><em>implied by the truth table</em></strong></li>
</ul>

<h3 id="rs-latch---hold">RS Latch - Hold</h3>

<p>This represents the <strong>persistence</strong> usage of RS Latch, it holds the previous value:</p>

<p>The hold command that has:</p>

<ul>
  <li>$S=0$</li>
  <li>$R=0$</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201006222659479.png" alt="image-20201006222659479" style="zoom:80%;" /></p>

<p>Therefore, the schematic:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006222948051.png" alt="image-20201006222948051" style="zoom:80%;" /></p>

<p>where:</p>

<ul>
  <li>the value of $Q$ is essentially the <strong>previous value of $Q$,</strong> which is the only source/chance of having a value.</li>
</ul>

<h3 id="rs-latch---invalid-state">RS Latch - Invalid State</h3>

<p>This is the undesirable state, which could cause a bug to your $Q$.</p>

<p>Consider:</p>

<ul>
  <li>$S=1$</li>
  <li>$R=1$
    <ul>
      <li>so basically set and reset</li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201006224224837.png" alt="image-20201006224224837" style="zoom: 80%;" /></p>

<p>Then you have a bug:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006224248353.png" alt="image-20201006224248353" style="zoom: 80%;" /></p>

<p>where:</p>

<ul>
  <li>obviously you cannot have $Q=\bar{Q}$.</li>
</ul>

<h2 id="d-latch">D Latch</h2>

<p>Still only stores one bit state $Q$, but it <strong>avoids the invalid case of RS Latch.</strong></p>

<ul>
  <li>basically, makes that input combination <strong><em>never achievable</em></strong>.</li>
</ul>

<p>There will be two inputs, still:</p>

<ul>
  <li>$CLK$ which means clock/enable/control</li>
  <li>$D$ which means data input.</li>
</ul>

<p>This means that:</p>

<ul>
  <li>$CLK=1$ means <strong>$D$ is enabled to be passed through</strong> to $Q$. (Transparent)</li>
  <li>$CLK=0$ means $Q$ <strong>holds its previous value</strong> regardless of $D$. (Opaque)</li>
</ul>

<p>Commonly, its schematic:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006224602535.png" alt="image-20201006224602535" style="zoom:80%;" /></p>

<h3 id="d-latch---updatetransparent">D Latch - Update/Transparent</h3>

<p>Basically, when:</p>

<ul>
  <li>$CLK=1$, you are allowed to pass in $D$.</li>
</ul>

<p>So:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006225129482.png" alt="image-20201006225129482" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>we utilized an RS Latch to implement the D Latch.</li>
  <li>and $D=Q$</li>
</ul>

<p>So the schematic looks like:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006225209915.png" alt="image-20201006225209915" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>notice that $1$ AND $anything$ gives $anything$.</li>
</ul>

<h3 id="d-latch---holdopaque">D Latch - Hold/Opaque</h3>

<p>Basically, you are not allowing $D$ to set/through:</p>

<ul>
  <li>$CLK=0$
    <ul>
      <li>basically, this forces both $R$ and $S$ to be $0$.</li>
    </ul>
  </li>
</ul>

<p>This correspond to:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006225533512.png" alt="image-20201006225533512" style="zoom: 67%;" /></p>

<p>And the schematic:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006225556089.png" alt="image-20201006225556089" style="zoom: 67%;" /></p>

<h3 id="d-latch-toggle-frequency">D Latch Toggle Frequency</h3>

<p>This is <strong>one problem</strong> of this D Latch. Consider this setup:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006230448664.png" alt="image-20201006230448664" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>we place in $\bar{Q}_{prev}$ into $D$. Therefore this schematic will cycle.</li>
  <li>however, since there are <strong>many gates involved ($t_{pd}$)</strong>, how do we know the <strong>rate of change of</strong> $Q$?
    <ul>
      <li>in other words, <strong><em>if there is a large influx/change of $D$, we might not be able to predict/control what $Q$ would be.</em></strong></li>
    </ul>
  </li>
</ul>

<h2 id="d-flip-flop">D Flip-Flop</h2>

<p>Still holds a single bit $Q$.</p>

<p><strong>Same input</strong>, the same:</p>

<ul>
  <li>$CLK$</li>
  <li>$D$</li>
</ul>

<p>But its mechanism is different:</p>

<ul>
  <li>it <strong>samples $D$</strong> on <strong>rising edge</strong> of $CLK$, so ($0 \to 1$ only)
    <ul>
      <li>therefore, it will not continuously allow updates, which prevents unpredictability of $Q$.</li>
      <li>you hence have a <strong>controlled rate of change/sampling rate</strong> of $Q$, by the bit $CLK$
        <ul>
          <li>so we can avoid glitches as well</li>
          <li>this is in fact the Hertz that a CPU has. For example, a <strong>2GHz CPU means it can sample $2<em>2</em>10^{30}$ times per second</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>otherwise</strong>, $Q$ holds its previous value</li>
</ul>

<p>It;s actual design uses two D Latches, $L1$ and $L2$:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006231702599.png" alt="image-20201006231702599" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>$L1$ and $L2$ just denotes that we <strong>have two D Latches connected.</strong></li>
  <li>the <strong>actual output read</strong> is of course the ones on the <strong>rightest hand side</strong></li>
</ul>

<p>and its symbols are:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006232540815.png" alt="image-20201006232540815" /></p>

<h3 id="d-flip-flop---rising-clk">D Flip-Flop - Rising CLK</h3>

<p>Consider first the case when $CLK=0$:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006231911397.png" alt="image-20201006231911397" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>$L1$ and $L2$ just means that we are using 2 latches to implement this.</li>
  <li>the data $D$ is <strong>stuck at $N1$</strong></li>
</ul>

<p>Now, if we switch $CLK=1$, we have:</p>

<p><img src="\lectures\images\typora-user-images\image-20201006232003945.png" alt="image-20201006232003945" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>now, the data $D$ stuck at $N1$ <strong>passes through to $Q$.</strong></li>
</ul>

<p><strong>Therefore, when $CLK$ rises, then $D$ passes through to $Q$.</strong></p>

<h3 id="d-flip-flop---timing-diagram">D Flip-Flop - Timing Diagram</h3>

<p>Here, we assume that gates have no delay:</p>

<p><img src="\lectures\images\typora-user-images\image-20201013223139860.png" alt="image-20201013223139860" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>obviously, when $CLK=0$, $N_1$ will listen exactly to $D$.</li>
</ul>

<p>and completing the other part:</p>

<p><img src="\lectures\images\typora-user-images\image-20201013223325850.png" alt="image-20201013223325850" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>now, when you have $CLK=1$, except for the beginning part, you will just have $N_1$ having its previous output out.</li>
</ul>

<p>Similarly, looking at $Q$, you have:</p>

<p><img src="\lectures\images\typora-user-images\image-20201013223742289.png" alt="image-20201013223742289" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>when $CLK=1$, the output of $Q$ will basically <strong>let previous $N_1$</strong> through</li>
</ul>

<p>Lastly, when $CLK=0$:</p>

<p><img src="\lectures\images\typora-user-images\image-20201013223854556.png" alt="image-20201013223854556" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>when $CLK=0$, $Q$ will be its previous value</li>
</ul>

<p>in fact, the output of $Q$ is <strong>clearly dependent on the sampling edges</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201013224058904.png" alt="image-20201013224058904" style="zoom:50%;" /></p>

<h1 id="week-6">Week 6</h1>

<h2 id="d-latch-vs-d-flip-flop">D Latch vs D Flip-Flop</h2>

<p><img src="\lectures\images\typora-user-images\image-20201013224521829.png" alt="image-20201013224521829" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>you see Flip-Flop responding to half of the time where a Latch responded</li>
</ul>

<h2 id="additional-flip-flop-controls">Additional Flip-Flop Controls</h2>

<ul>
  <li><strong>Enable</strong> Flip-Flops
    <ul>
      <li>basically, you can have $EN$ input that <strong>controls when new data is passed or held back</strong> in addition to $CLK$</li>
      <li>$EN=1$ means $D$ passed through to $Q$ on clock edge</li>
      <li>$EN=0$ means flip-flop state does not change</li>
    </ul>
  </li>
  <li><strong>Resettable</strong> flip-flop
    <ul>
      <li>have additional input to <strong>force state to particular value</strong></li>
      <li>$PRE=1$ (active high) or $\overline{PRE}=0$ (active low)
        <ul>
          <li>A signal is ‘<strong>active low</strong>’ means that signal will be <strong>performing its function when its logic level is 0</strong>.</li>
          <li>A signal is ‘<strong>active</strong> <strong>high</strong>’ means that signal will be <strong>performing its function when its logic level is 1</strong>.</li>
        </ul>
      </li>
      <li>$CLR=1$ or $\overline{CLR}=0$</li>
      <li>and there are also variations to those, as you can make:
        <ul>
          <li>synchronous resets, which happen at clock edge only</li>
          <li>asynchronous resets, which happens immediately</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="examples-of-using-flip-flops">Examples of Using Flip-Flops</h2>

<h3 id="parity-machine-design">Parity Machine Design</h3>

<ul>
  <li>
    <p><strong>Question:</strong></p>

    <p>$even=1$ when there has been an even number of $1$s on $x$ since last $\overline{RST}$:</p>
  </li>
  <li>
    <p><strong>Solution:</strong></p>

    <p>we need to start with a $1$</p>

    <p><img src="\lectures\images\typora-user-images\image-20201013225513443.png" alt="image-20201013225513443" style="zoom:50%;" /></p>

    <p>where:</p>

    <ul>
      <li>basically, all we needed to figure out was the $D$ input, which we figured out to be $even(XOR)x$</li>
      <li>$CLK$ is something <strong>not for us to control</strong>, it is the sampling rate controlled externally</li>
      <li>$\overline{RST} = 0$ gives $PRE=1$. So after last reset, we <strong>assume that there is zero/an even number of $1$.</strong>
        <ul>
          <li>it is actually a choice based on the designer, viewed as the <strong>initial condition</strong></li>
          <li>this is basically to satisfy the requirement “since last $\overline{RST}$”</li>
        </ul>
      </li>
      <li>last but not least, that little circle below the $\overline{PRE}$ is just a convention</li>
    </ul>
  </li>
</ul>

<h3 id="pattern-recognizer-state-transition-diagram">Pattern Recognizer: State Transition Diagram</h3>

<ul>
  <li>
    <p><strong>Question:</strong></p>

    <p>$y=1$ whenever the last four bits on $x$ have been $1101$</p>
  </li>
  <li>
    <p><strong>Solution:</strong></p>

    <ol>
      <li>First, let us start with a DFA:</li>
    </ol>

    <p><img src="\lectures\images\typora-user-images\image-20201013231330702.png" alt="image-20201013231330702" style="zoom:50%;" /></p>

    <ol>
      <li>Now, to make things towards our design, we could have:</li>
    </ol>

    <p><img src="\lectures\images\typora-user-images\image-20201013231853449.png" alt="image-20201013231853449" style="zoom: 67%;" /></p>

    <ol>
      <li>Then, this means we just need to have:</li>
    </ol>

    <p><img src="\lectures\images\typora-user-images\image-20201013232153697.png" alt="image-20201013232153697" /></p>

    <ol>
      <li>Now, we can just represent <strong>each state as the triplet flip-flop result $Q$</strong>:</li>
    </ol>

    <p><img src="\lectures\images\typora-user-images\image-20201013232501691.png" alt="image-20201013232501691" style="zoom:67%;" /></p>

    <p>where:</p>

    <ul>
      <li>the <strong>key idea/implementation step</strong> would be:
        <ul>
          <li>the triplet $Q_2 Q_1 Q_0$ would represent a <strong>state</strong>
            <ul>
              <li>$000$ would be our <strong>start state</strong>, which we can customize using $\overline{PRE}$</li>
            </ul>
          </li>
          <li>input $X$ would represent the <strong>alphabet</strong></li>
          <li>a <strong>transition</strong> would be having a gate logic on making $\delta(Q_2 Q_1 Q_0,X) \to Q_2’Q_1’Q_0’$
            <ul>
              <li>and <strong>since $D_i$ are exactly the elements that can change $Q_i$</strong>, we are basically figuring out $\delta(Q_2 Q_1 Q_0,X) \to D_2 D_1 D_0$ in the above table</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>practically, it means <strong>how to generate the triplet output $D_2 D_1 D_0$ from the quartet input $Q_2 Q_1 Q_0 X$</strong></li>
    </ul>

    <ol>
      <li>
        <p>Now, we just need to figure out the expression using a K-Map:</p>

        <ul>
          <li>
            <p>since there are <strong>three outputs</strong>, we will just have three K-Maps:</p>

            <p><img src="\lectures\images\typora-user-images\image-20201016003737927.png" alt="image-20201016003737927" style="zoom: 67%;" /></p>
          </li>
        </ul>
      </li>
    </ol>

    <p><img src="\lectures\images\typora-user-images\image-20201016004632938.png" alt="image-20201016004632938" /></p>

    <p><img src="\lectures\images\typora-user-images\image-20201016005139460.png" alt="image-20201016005139460" style="zoom:50%;" /></p>

    <ol>
      <li>
        <p>Lastly, we figure out the actual output we need, which is, whenever you are at state $100$, it is true.</p>

        <ul>
          <li>obviously this refers to the <strong>accepting state</strong></li>
          <li>and we can simply have $OUT=Y=Q_2$ in this case, because only that state has $Q_2 =1$</li>
        </ul>
      </li>
      <li>
        <p>Assembling all the above in a schematic, which now becomes trivial as we have figured out all the logics:</p>

        <ul>
          <li><strong>accept state</strong> $\to Y=1$ is just $Q_2$</li>
          <li><strong>start state</strong> $\to 000$ can be set by $\overline{PRE}$ or $CLR$</li>
          <li><strong>transition</strong> $\to$ the logical expressions we have figured out on step (5).</li>
          <li><strong>input string</strong> $\to X$, which we read bit by bit (actual rate and content is controlled by the $CLK$).</li>
        </ul>

        <p><img src="\lectures\images\typora-user-images\image-20201016010956145.png" alt="image-20201016010956145" style="zoom: 50%;" /></p>

        <p>where:</p>

        <ul>
          <li>for saving the spaghetti wires, we assumed that all the $CLR$ and $CLK$ are connected.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="template-for-designing-state-transition-diagram">Template for Designing State Transition Diagram</h3>

<p>Basically you can approach this by thinking about the DFA:</p>

<ol>
  <li>
    <p>Identity the input (alphabet)</p>
  </li>
  <li>Draw the DFA</li>
  <li>Write out the state transition table
    <ul>
      <li>which contains $r_i, a, r_t, accept$, where $r_i$ is the from state, and $r_t$ is the target state, and $a$ is the symbol processed</li>
    </ul>
  </li>
  <li>Select state encodings</li>
  <li>Augment the transition table with state encodings</li>
  <li>Figure out the logical expression for the transitions</li>
  <li>Figure out the logical expression for the output</li>
  <li>Draw the schematic
    <ul>
      <li>don’t forget to <strong>configure start state and the $CLK$</strong></li>
    </ul>
  </li>
</ol>

<h3 id="pattern-recognizer-implementation-shift-register">Pattern Recognizer Implementation: Shift Register</h3>

<p>Another design would only work in specific cases, and it happens that it fits well in the question where the last 4 bit is $1101$:</p>

<ul>
  <li>this utilized the design that a Flip-Flop can hold its <strong>last state</strong>:</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201016013514783.png" alt="image-20201016013514783" style="zoom:50%;" /></p>

<p>Therefore, a <strong>shift register</strong> design is natural to this question:</p>

<p><img src="\lectures\images\typora-user-images\image-20201016013316629.png" alt="image-20201016013316629" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>notice that the <strong>“order” is reversed</strong>, where $1101$ as the last four bit will become $1011$ in the diagram.</li>
  <li>this <strong><em>only works for specific questions</em></strong></li>
  <li>the above is also called a <strong>shift register</strong>, you basically have <strong>each bit shifting in</strong>
    <ul>
      <li>essentially the <strong><em>same as the vending machine mechanism</em></strong></li>
    </ul>
  </li>
</ul>

<h3 id="clk-counter-frequency-divider">CLK Counter: Frequency Divider</h3>

<p>This is a tricky one, where we can implement a FSM that has <strong>output simulating the $CLK$ but with a different frequency.</strong></p>

<p>Consider the task to divide a given frequency by 3:</p>

<p><img src="\lectures\images\typora-user-images\image-20201017183434163.png" alt="image-20201017183434163" /></p>

<p>where:</p>

<ul>
  <li>we see only one rise for <strong>every three periods</strong> of $CLK$.</li>
</ul>

<p>This is solved by a state transition that can be thought of only dependent on the rising $CLK$ and its previous state:</p>

<p><img src="\lectures\images\typora-user-images\image-20201017183614181.png" alt="image-20201017183614181" /></p>

<p>Then the <strong>transition table</strong> becomes trivial:</p>

<p><img src="\lectures\images\typora-user-images\image-20201017183908840.png" alt="image-20201017183908840" /></p>

<p>using a <strong><em>binary encoding</em></strong> for each state</p>

<p><img src="\lectures\images\typora-user-images\image-20201017183655757.png" alt="image-20201017183655757" /></p>

<p>then the output is trivially:
\(Y=\overline{S_0}\overline{S_1}\)</p>

<ul>
  <li>since $Y=1$ only at state $S_0$, which has <strong>encoding</strong> $00$.</li>
</ul>

<p>and the <strong>circuit</strong> becomes:</p>

<p><img src="\lectures\images\typora-user-images\image-20201017183823662.png" alt="image-20201017183823662" /></p>

<h2 id="multibit-storage-registers">Multibit Storage: Registers</h2>

<p>For example, if we need to store a $4$ bit number:</p>

<p>Basically, since each bit takes its place, <strong>we will just have $4$ Flip-Flops</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201016013148135.png" alt="image-20201016013148135" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>the condensed symbol on the right is often used</li>
  <li><strong>register is basically a bunch of flip flops</strong></li>
</ul>

<h2 id="finite-state-machines-abstraction">Finite State Machines Abstraction</h2>

<p>Therefore, the fundamental building blocks of a finite state machine would be:</p>

<ul>
  <li>a <strong>register</strong> (flip-flops) representing the <strong>state</strong></li>
  <li>a <strong>next state logic</strong> representing the <strong>transition</strong></li>
  <li>an <strong>output logic</strong> representing the <strong>logic for accepting states</strong></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201016013919247.png" alt="image-20201016013919247" style="zoom:50%;" /></p>

<p><img src="\lectures\images\typora-user-images\image-20201016013928582.png" alt="image-20201016013928582" style="zoom:50%;" /></p>

<p>and usually, you will have:</p>

<p><img src="\lectures\images\typora-user-images\image-20201016014133881.png" alt="image-20201016014133881" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>if the input for the <strong>output logic</strong> is just dependent on current states, then it is called a <strong>Moore Finite State Machine</strong>
    <ul>
      <li>basically the standard DFAs</li>
    </ul>
  </li>
  <li>if the input for the <strong>output logic</strong> is dependent on current states <strong>and input</strong>, then it is called a <strong>Mealy Finite State Machine</strong></li>
</ul>

<h2 id="moore-vs-mealy-fsm">Moore vs. Mealy FSM</h2>

<p>Again, they have exactly the same building blocks but its accepting behavior is different. Therefore, you <strong>can always transform a Moore FSM to a Mealy FSM.</strong></p>

<ul>
  <li>
    <p><strong>Moore FSM:</strong></p>

    <ul>
      <li>outputs depend only on current state</li>
    </ul>

    <p><img src="\lectures\images\typora-user-images\image-20201016014540624.png" alt="image-20201016014540624" style="zoom:50%;" /></p>

    <ul>
      <li>this would be the standard <strong>state based design</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>Mealy FSM:</strong></p>

    <ul>
      <li>
        <p>outputs depend on current state and inputs</p>

        <p><img src="\lectures\images\typora-user-images\image-20201016014603891.png" alt="image-20201016014603891" style="zoom: 50%;" /></p>
      </li>
      <li>
        <p>this would be an <strong>edge/transition based design</strong></p>
      </li>
      <li>
        <p>the timing for updating output might be different from</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="example-mealy-parity-check-machine">Example: Mealy Parity Check Machine</h3>

<p>The task is to check if there has been an even number of $1$:</p>

<p>The state transition diagram will becomes:</p>

<p><img src="\lectures\images\typora-user-images\image-20201016015015329.png" alt="image-20201016015015329" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>notice the <strong>“transition” becomes a tuple</strong> $(input,output)$</li>
  <li>this means we know the output <strong>without technically reaching the accepting state</strong></li>
</ul>

<p>Implementation:</p>

<p><img src="\lectures\images\typora-user-images\image-20201106003646495.png" alt="image-20201106003646495" /></p>

<p>where:</p>

<ul>
  <li><strong>notice that</strong> the output is “out-of-sync” of the clock, such that <strong>output could update technically <em>before</em> $Q$ updates</strong></li>
</ul>

<h2 id="traffic-light-design">Traffic Light Design</h2>

<p>This is the really canonical design you need to know.</p>

<p>Consider the traffic at a crossing:</p>

<p><img src="\lectures\images\typora-user-images\image-20201020223117321.png" alt="image-20201020223117321" /></p>

<p>where:</p>

<ul>
  <li>we have the following rules: whenever a street has at least one car $T=1$, and let the light $L$ be green. Once there is no car at $T$, the light transitions to yellow and then red.</li>
</ul>

<p>Basically, this is the <strong>interface</strong> we need to implement:</p>

<p><img src="\lectures\images\typora-user-images\image-20201020222210801.png" alt="image-20201020222210801" style="zoom: 67%;" /></p>

<ul>
  <li>
    <p><strong>Solution:</strong></p>

    <p>First, we do the <strong>state transition diagram</strong>:</p>

    <p><img src="\lectures\images\typora-user-images\image-20201020222709697.png" alt="image-20201020222709697" style="zoom:50%;" /></p>

    <p>where:</p>

    <ul>
      <li>the obvious problem of this is that, if there is always some traffic on $A$, or $B$, then the <strong>light will never switch</strong>. But this is a <strong>simplified model</strong> anyway.</li>
    </ul>

    <p>Now, we need to do the state transition table:</p>

    <ul>
      <li>
        <p>here, we changed the encoding to be <strong>one-hot encoding</strong>, where basically 4 bits encodes to 2 bits, representing its position:</p>

        <p><img src="\lectures\images\typora-user-images\image-20201020223407620.png" alt="image-20201020223407620" style="zoom:80%;" /></p>
      </li>
    </ul>

    <p>Next, we implement the <strong>transition logic, which now becomes easy</strong>, because there is exactly only <strong>one 1 in each column:</strong></p>

    <p><img src="\lectures\images\typora-user-images\image-20201020223739323.png" alt="image-20201020223739323" style="zoom:50%;" /></p>

    <p>but also notice that:</p>

    <ul>
      <li>those logical expressions correspond <strong>exactly to the transition diagram we had</strong>
        <ul>
          <li>e.g. for $D_3$, it means we enter $Q_3$ whenever we where in $Q_2$ and had $T_B=0$, which is <strong>exactly what we had on the diagram</strong>.</li>
        </ul>
      </li>
    </ul>

    <p>Last but not least, the output logic table is, according to the state diagram:</p>

    <p><img src="\lectures\images\typora-user-images\image-20201020224131928.png" alt="image-20201020224131928" style="zoom:50%;" /></p>

    <p>And the <strong>output logic becomes</strong>:</p>

    <p><img src="\lectures\images\typora-user-images\image-20201020224218435.png" alt="image-20201020224218435" style="zoom:50%;" /></p>
  </li>
</ul>

<h1 id="week-7">Week 7</h1>

<p>==TODO: Look at the class PowerPoint and do the MIPS tutorial==</p>

<h2 id="synchronous-logic-design">Synchronous Logic Design</h2>

<p>In general, it means having:</p>

<ol>
  <li>
    <p><strong>Flip-flops (or registers) contain the state</strong> of the system</p>
  </li>
  <li>
    <p>State <strong>changes synchronously at clock edge</strong> (system synchronized to clock)</p>
  </li>
</ol>

<p>This could be either the FSM machine we had, or, another similar design would be, a <strong>Pipeline</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201020224705695.png" alt="image-20201020224705695" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p>remember, registers are just the group of flip-flops</p>
  </li>
  <li>
    <p>Pipeline and a FSM essentially is just the same thing, just that you <strong>have two registers instead of one</strong></p>
  </li>
</ul>

<h2 id="timing-constraints">Timing Constraints</h2>

<h3 id="flip-flop-input-timing-constraints">Flip-Flop Input Timing Constraints</h3>

<p>Basically, we need to make sure that data do not come in <strong>during the rise</strong> of the $CLK$.</p>

<p><img src="\lectures\images\typora-user-images\image-20201020224919913.png" alt="image-20201020224919913" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li><strong>setup time</strong> $t_{setup}$: time before clock edge that data must be stable</li>
  <li><strong>hold time</strong> $t_{hold}$: time after clock edge that data must be stable</li>
  <li>the particular time for the above <strong><em>depends on how a flip-flop is designed/implemented</em></strong></li>
</ul>

<h3 id="flip-flop-output-timing-constraints">Flip-Flop Output Timing Constraints</h3>

<p>However, since <strong>flip-flops themselves also have delays</strong>, we also need to make sure that data is read in the correct time:</p>

<p><img src="\lectures\images\typora-user-images\image-20201020234606427.png" alt="image-20201020234606427" /></p>

<p>where:</p>

<ul>
  <li><strong>propagation delay</strong> $t_{pcq}$: time after the clock edge, such that <strong>after it</strong> the (new) $Q$ is <strong>guaranteed to be stable</strong></li>
  <li><strong>contamination delay $t_{ccq}$</strong>: time after the clock edge, such that <strong>before it</strong> the (old) $Q$ is <strong>guaranteed to be stable</strong></li>
</ul>

<h3 id="total-setup-time-constraint">Total Setup Time Constraint</h3>

<p>Basically, we want to have your <strong>data ready, at latest, before your</strong> $t_{setup}$:</p>

<ul>
  <li>this is again to comply with the flip-flop input timing constraint</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201020235100069.png" alt="image-20201020235100069" style="zoom: 50%;" /></p>

<p>This means:
\(T_{clock}&gt; t_{pcq} + t_{pd}+t_{setup}\)
where:</p>

<ul>
  <li>
    <p>your <strong>lasted data will be guaranteed to be latest and correct</strong> only after the above period of time.</p>
  </li>
  <li>
    <p>the <strong>best case scenario</strong> is of course that you <strong>can get data passed in each clock</strong>, but if you have a huge CL design, then you might need to slow down/split the sampling.</p>
  </li>
</ul>

<p>Or, you want to <strong>minimize your combinational logic delay</strong> such that:
\(t_{pd} &lt; T_{clock}-( t_{pcq} +t_{setup})\)</p>

<h3 id="total-hold-time-constraint">Total Hold Time Constraint</h3>

<p>Basically, we <strong>don’t want $D$ to be changed too soon</strong> as well, i.e. the <strong><em>new data don’t come in too fast</em></strong>:</p>

<ul>
  <li>so you make sure the <strong>least delay of a (next) data only comes in <em>after</em> the hold time</strong>:</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201020230239606.png" alt="image-20201020230239606" style="zoom:50%;" /></p>

<p>and:
\(t_{hold} &lt; t_{ccq}+t_{cd}\)
or, you need to try to design your combinational logic to be:
\(t_{cd} &gt; t_{hold}-t_{ccq}\)</p>

<h3 id="clock-skew">Clock Skew</h3>

<p>This is the problem that <strong>clock themselves does not arrive at all registers the same time</strong>.</p>

<ul>
  <li>this could make data be read-in at different times, and could be catastrophic</li>
  <li><strong>skew $t_{skew}$:</strong> the time difference between two clocks.</li>
</ul>

<h3 id="total-setup-time-constraint-w-skew">Total Setup Time Constraint w/ Skew</h3>

<p>Again, we need to make sure that <strong>data, at latest, comes in before the setup time of the second register w/ skew</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201020230955069.png" alt="image-20201020230955069" style="zoom: 50%;" /></p>

<p>and the <strong>constraint</strong> equation would be:
\(T_{clock}&gt; t_{pcq} + t_{pd}+t_{setup}+t_{skew}\)</p>

<h3 id="total-hold-time-constraint-w-skew">Total Hold Time Constraint w/ Skew</h3>

<p>Again, you need to make sure the <strong>latest data does not come in too fast</strong>:</p>

<ul>
  <li>again, it means <strong>your least delay must be longer than the sampling time of $CLK2$ $+$ $Skew$:</strong></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201020232142207.png" alt="image-20201020232142207" style="zoom:50%;" /></p>

<p>So we have:
\(t_{hold} + t_{skew}&lt; t_{ccq}+t_{cd}\)
as the <strong>constraint</strong>.</p>

<h1 id="week-8">Week 8</h1>

<p>Short Tutorial on MIPS: https://minnie.tuhs.org/CompArch/Resources/mips_quick_tutorial.html</p>

<p>Extensive Tutorial on MIPS: http://ellard.org/dan/www/Courses/cs50-asm.ps</p>

<h2 id="mips">MIPS</h2>

<p>Basically, MIPS will be a language that you can communicate with your processor. However, not all processers have interfaces for MIPS. Therefore, we might need to use a software simulation.</p>

<p>In general, this is what happens <strong>when you program</strong>:</p>

<ul>
  <li>C $\to$ Assembly Code $\to$ Machine Code</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201027222336775.png" alt="image-20201027222336775" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>You <strong>write MIPS code</strong> (<strong>human readable assembly code</strong>), which will be first translated to <strong>assembly code</strong> on the bottom right
    <ul>
      <li>essentially, two codes are the same, but the top right is more human</li>
    </ul>
  </li>
  <li>Then, <strong>assembly code</strong> (e.g. MIPS code) is <strong><em>converted into executable machine code</em></strong> by a utility program referred to as an <strong>assembler</strong>. The conversion process is referred to as <em>assembly</em>, as in <em>assembling</em> the source code.
    <ul>
      <li>An <strong>assembler</strong> program creates object code by translating combinations of mnemonics and syntax for operations and addressing modes into their numerical equivalents.</li>
    </ul>
  </li>
</ul>

<h3 id="risc-vs-cics-architecture">RISC vs. CICS Architecture</h3>

<ul>
  <li>An <strong>instruction set, also called ISA</strong> (instruction set architecture), is part of a computer that pertains to programming, which is more or less machine language. The instruction set provides commands to the processor, to tell it what it needs to do (<strong>an implementation of an ISA would be a CPU</strong>).
    <ul>
      <li>The instruction set consists of addressing modes, instructions, native data types, registers, memory architecture, interrupt, and exception handling, and external I/O.</li>
    </ul>
  </li>
</ul>

<p><strong>MIPS is a Reduced Instruction Set Computer (RISC)</strong>. Others include ARM, PowerPC, SPARC, HP-PA, and Alpha.A</p>

<ul>
  <li>RISC is a computer with a small, highly optimized set of instructions (see definition above), rather than the more specialized set often found in other types of architecture, such as in a complex instruction set computer (CISC).</li>
</ul>

<p><strong>Complex Instruction Set Computer (CISC)</strong> is one alternative. <strong>Intel’s x86</strong> is the most prominent example; also Motorola 68000 and DEC VAX.</p>

<p>RISC’s underlying principles, due to Hennessy and Patterson:</p>

<ul>
  <li>Simplicity favors regularity</li>
  <li>Make the common case fast</li>
  <li>Smaller is faster (e.g. less delay time)</li>
  <li>Good design demands good compromises</li>
</ul>

<p><strong>Difference between RISC and CISC</strong>:</p>

<p><img src="https://2.bp.blogspot.com/-PAHTUSBJA8s/Wzck5pNEhbI/AAAAAAAAAN4/NvbTkpo17dwrH6LM6XmKZEJtkYUINBxLQCLcBGAs/s1600/Capture.PNG" alt="Difference Between RISC and CISC Architectures and its Applications -  PRO-Coder" style="zoom: 80%;" /></p>

<p>where:</p>

<ul>
  <li><strong>one key difference for us</strong> is that, to deal with data in the memory, you need to explicitly <code class="language-plaintext highlighter-rouge">load</code> and then <code class="language-plaintext highlighter-rouge">store</code> using RISC (e.g. MIPS), whereas for CISC, it will probably be just one line.</li>
</ul>

<h3 id="example-gcd-algorithm">Example: GCD Algorithm</h3>

<p>The algorithm is as follows (not as efficient as the one had for AP, which uses <code class="language-plaintext highlighter-rouge">MOD</code>):</p>

<p><img src="\lectures\images\typora-user-images\image-20201028001937947.png" alt="image-20201028001937947" style="zoom: 67%;" /></p>

<p>And the set of instructions would be as follows”</p>

<ol>
  <li>Call the two numbers a and b</li>
  <li>If a and b are equal, stop: a is the greatest common divisor</li>
  <li>Subtract the smaller from the larger</li>
  <li>Repeat steps 2–4</li>
</ol>

<p>Then the <strong>actual MIPS code for the above</strong> look like</p>

<p><img src="\lectures\images\typora-user-images\image-20201028002121255.png" alt="image-20201028002121255" style="zoom:50%;" /></p>

<h4 id="mips-opcode">MIPS Opcode</h4>

<p><img src="\lectures\images\typora-user-images\image-20201027224835017.png" alt="image-20201027224835017" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">beq</code> means <strong>branch on equal</strong></li>
  <li><code class="language-plaintext highlighter-rouge">bne</code> means <strong>branch not equal</strong>
    <ul>
      <li>e.g. <code class="language-plaintext highlighter-rouge">bne $v0, $zero, .L1</code> means, if you find value <strong><em>at register</em></strong> <code class="language-plaintext highlighter-rouge">$v0, $zero</code> not equal, go to the code with label <code class="language-plaintext highlighter-rouge">.L1</code></li>
    </ul>
  </li>
</ul>

<h4 id="mips-arithmetic">MIPS Arithmetic</h4>

<p><img src="\lectures\images\typora-user-images\image-20201027235016562.png" alt="image-20201027235016562" style="zoom: 50%;" /></p>

<h4 id="mips-operands">MIPS Operands</h4>

<p><img src="\lectures\images\typora-user-images\image-20201027235128342.png" alt="image-20201027235128342" style="zoom:50%;" /></p>

<h4 id="mips-labels">MIPS Labels</h4>

<p><img src="\lectures\images\typora-user-images\image-20201027235226320.png" alt="image-20201027235226320" style="zoom: 67%;" /></p>

<h4 id="mips-comments">MIPS Comments</h4>

<p><img src="\lectures\images\typora-user-images\image-20201027225059208.png" alt="image-20201027225059208" style="zoom: 50%;" /></p>

<h4 id="mips-control-flow">MIPS Control Flow</h4>

<p><img src="\lectures\images\typora-user-images\image-20201027225202137.png" alt="image-20201027225202137" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li><strong>by default, like all other programs, it runs from top to bottom</strong>, if you do not use control flow (e.g. <code class="language-plaintext highlighter-rouge">beq</code>, which is like <code class="language-plaintext highlighter-rouge">if</code> statements.)</li>
</ul>

<h3 id="mips-isa-overview">MIPS ISA Overview</h3>

<p>MIPS is a 32-bit architecture (which means only works with 32-bits at a time). (there is also a 64-bit version, but not what we are using). This means we can <strong>only use/have the following</strong>:</p>

<ul>
  <li><strong>registers are 32-bit wide</strong></li>
  <li><strong>all instructions</strong> are 32-bits wide
    <ul>
      <li>e.g. each line of code must be 32-bits wide</li>
    </ul>
  </li>
  <li><strong>word size (data size)</strong> is 32-bits
    <ul>
      <li>i.e., natural hardware operand size is 32-bits</li>
    </ul>
  </li>
</ul>

<p>As explained above, MIPS is a <strong>load/store architecture</strong></p>

<ul>
  <li>instructions manipulate operands in <strong><em>registers or immediates</em></strong>
    <ul>
      <li>immediates are basically places for constants, which will be addressed in <a href="#Immediate Operands">Immediate Operands</a></li>
    </ul>
  </li>
  <li>to <strong>manipulate data in memory</strong>, programmer must write <strong>load/store instructions that copy data from memory to register</strong> (and back)</li>
  <li>much easier to implement in hardware (H&amp;P: simplicity ⇒ speed)</li>
</ul>

<blockquote>
  <p>For CISC, such as an intel-86 processor, which does not need to load the data, they tend to operate much faster. However, the hardware is more difficult to implement.</p>
</blockquote>

<h3 id="mips-register-set">MIPS Register Set</h3>

<ul>
  <li>Registers have <code class="language-plaintext highlighter-rouge">$</code> before <strong>name</strong> (used by programmers), and name indicates the purpose.
    <ul>
      <li>the numbers will be translated at compile time</li>
    </ul>
  </li>
  <li>Register usage governed by convention.  Only ​<code class="language-plaintext highlighter-rouge">$0</code> behaves differently.</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201027225742415.png" alt="image-20201027225742415" style="zoom:80%;" /></p>

<p>where:</p>

<ul>
  <li>you have registers $0-31$ (i.e. <strong>there are 32 registers you can manipulate</strong>), and <strong>each of them can store 4 Bytes=32 bits (i.e. 32 Flip-Flops)</strong></li>
  <li>though it appears that <strong>each type data seems to be bounded</strong> (e.g. only 4 registers for storing function arguments), but in fact, <strong>you can just use pointers (which is exactly 8 bytes=32 bits) inside those registers</strong>, and those pointers could point to an array of arguments</li>
</ul>

<h3 id="3-operant-mips-instruction">3-Operant MIPS Instruction</h3>

<p>3-Operand would mean (here):</p>

<ul>
  <li>2 inputs/source registers</li>
  <li>1 output/destination register</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201027230710787.png" alt="image-20201027230710787" style="zoom: 67%;" /></p>

<h3 id="immediate-operands">Immediate Operands</h3>

<ul>
  <li><strong>Immediate</strong> - a small constant encoded directly in instruction, so you can use directly when coding
    <ul>
      <li>basically, immediate just means constant</li>
      <li>they are used often since they spare a register</li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201027230924833.png" alt="image-20201027230924833" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">addi</code> has an <code class="language-plaintext highlighter-rouge">i</code>, which specifically means <code class="language-plaintext highlighter-rouge">immediate</code> as specified above</li>
</ul>

<blockquote>
  <p><strong>Note:</strong></p>

  <ul>
    <li>immediates get <strong>16-bit field in instruction (built-in)</strong>, consequently they can range from -32768 to 32767</li>
  </ul>
</blockquote>

<p>However, what if you need to use constant with in 32-bit?</p>

<ul>
  <li>
    <p>then you need to <strong>use one register</strong> with the following <strong>two steps</strong>:</p>

    <ol>
      <li>
        <p>load half of the data (16-bits) into the upper half of the register</p>
      </li>
      <li>
        <p>fill in the lower half, by <code class="language-plaintext highlighter-rouge">OR</code>ing the above data with another 16 bits data.</p>

        <p><img src="\lectures\images\typora-user-images\image-20201027231350877.png" alt="image-20201027231350877" style="zoom: 67%;" /></p>

        <ul>
          <li>remember, the <code class="language-plaintext highlighter-rouge">ori</code> works because, if you OR <code class="language-plaintext highlighter-rouge">1100</code> and <code class="language-plaintext highlighter-rouge">11</code>, you just get filled with <code class="language-plaintext highlighter-rouge">1111</code></li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>in the end, you get the value</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0xCAFE0B0E
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p><strong>This means that if you want to store a <code class="language-plaintext highlighter-rouge">long</code></strong>, which would be 64-bits, you would need to have <strong>two registers</strong>, each storing half of the data.</p>
</blockquote>

<h3 id="pseudo-instruction">Pseudo-Instruction</h3>

<p>Basically, they are expressions that are expanded by assembler</p>

<ul>
  <li>so that instead of writing all the code out, some work gets done by the assembler</li>
  <li>however, this means that a processer, when directly pseudo instructions like this, will have no idea what it is talking about.
    <ul>
      <li>a processor only knows/implements real instructions as specified by the ISA</li>
    </ul>
  </li>
</ul>

<p><strong><em>For example:</em></strong></p>

<ul>
  <li>
    <p>the below code will do the same thing as the two steps done above</p>

    <p><img src="\lectures\images\typora-user-images\image-20201027231907288.png" alt="image-20201027231907288" style="zoom:67%;" /></p>

    <p>where:</p>

    <ul>
      <li>the example must be pseudo code, since this command itself exceeded length 32 bits.</li>
    </ul>
  </li>
</ul>

<h3 id="memory-operands">Memory Operands</h3>

<p>Basically, if you don’t have enough space in registers for data, you <strong>could store in memory, and then have a pointer to it</strong>.</p>

<p><img src="\lectures\images\typora-user-images\image-20201027232408974.png" alt="image-20201027232408974" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>since we are dealing with 32-bit system, it means each data/word uses <strong>4 bytes=4 memory cells</strong>.</li>
</ul>

<h4 id="address-format-in-mips">Address Format in MIPS</h4>

<p>Basically, we only have one way to represent a pointer/address:
\(\text{address} = \text{base address (in a register)} + \text{offset (in an immediate)}\)
<strong><em>For example:</em></strong></p>

<ul>
  <li>
    <p>the below <strong>address/pointer</strong> in MIPS:</p>

    <pre><code class="language-mips">4($t1)
</code></pre>

    <p>would mean:</p>

    <pre><code class="language-mips">address = reg[$t1] + 4
</code></pre>

    <p><strong>graphically</strong>:</p>

    <p><img src="\lectures\images\typora-user-images\image-20201030005315233.png" alt="image-20201030005315233" style="zoom:50%;" /></p>
  </li>
</ul>

<blockquote>
  <p><strong>Note:</strong></p>

  <ul>
    <li>There could be negative offsets as well, so that you can move back.</li>
    <li>However, since we are using an intermediate, it is signed and being 16 bits.</li>
  </ul>
</blockquote>

<h4 id="loading-and-storing-data-from-memory">Loading and Storing Data from Memory</h4>

<p>In short, to load/store, you will need:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">lw</code> = <strong>load</strong> word (from memory)</li>
  <li><code class="language-plaintext highlighter-rouge">sw</code> = <strong>store</strong> word (to memory)</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201030005809870.png" alt="image-20201030005809870" style="zoom: 50%;" /></p>

<p>where:</p>

<ul>
  <li>your register file is 128B because you have <strong>32 registers, each with capacity of 4 bytes</strong> (32 bits).</li>
</ul>

<h4 id="loading-bytes">Loading Bytes</h4>

<p>Basically, your register has 4 bytes (32 bits), but what if you just want to load <strong>one byte from your address?</strong></p>

<p>Here, MIPS give you two choices:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">lbu</code> = load byte unsigned
    <ul>
      <li>load by filling the upper remaining bits to be <code class="language-plaintext highlighter-rouge">0</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">lb</code> = load byte (signed)
    <ul>
      <li>load by filling the upper remaining bits to be the same as the MSB</li>
    </ul>
  </li>
</ul>

<p><strong><em>For example:</em></strong></p>

<ul>
  <li><img src="\lectures\images\typora-user-images\image-20201030010721988.png" alt="image-20201030010721988" style="zoom: 67%;" /></li>
</ul>

<p>where:</p>

<ul>
  <li>the data at memory was <code class="language-plaintext highlighter-rouge">0xF0</code> (which is the max of 1 byte = $2^8=16\times16$ bit)</li>
</ul>

<h3 id="control-transfer-instructions">Control Transfer Instructions</h3>

<p>We need to be able to:</p>

<ul>
  <li>jump to a different place of the program <strong>on some condition</strong> (e.g. <code class="language-plaintext highlighter-rouge">if</code>)
    <ul>
      <li>this is usually called <strong>branching</strong></li>
    </ul>
  </li>
  <li>jump to a different place of the program <strong>unconditionally</strong> (e.g. <code class="language-plaintext highlighter-rouge">goto</code>)
    <ul>
      <li>this is usually called a <strong>jump</strong></li>
    </ul>
  </li>
</ul>

<h4 id="jump-instruction">Jump Instruction</h4>

<p>This is unconditional, and hence it is simple:</p>

<pre><code class="language-mips">j mylabel
</code></pre>

<p>where:</p>

<ul>
  <li>once hit this line, it will jump to the code with <code class="language-plaintext highlighter-rouge">myLabel:</code></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201030011251452.png" alt="image-20201030011251452" style="zoom: 67%;" /></p>

<p>but another way is to:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jr</span> <span class="err">$</span><span class="n">t3</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">t3</code> would be the register containing the <strong>address of your program</strong></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201030011446102.png" alt="image-20201030011446102" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>because <strong>every instruction your are coding</strong> is itself some data, which will have an <strong>address</strong>.</li>
</ul>

<h4 id="jump-and-link">Jump and Link</h4>

<p>The above two jumps just jumps straight to that position, and will not come back.</p>

<p>However, sometimes you need to jump to some place, execute some code, and <strong>come back</strong>.</p>

<ul>
  <li>this is achieved by <strong>using <code class="language-plaintext highlighter-rouge">jal &lt;label&gt;</code></strong> = jump and link, <strong>and comes back with <code class="language-plaintext highlighter-rouge">jr $ra</code></strong></li>
  <li>so that <strong><code class="language-plaintext highlighter-rouge">jal</code> would be the instruction to use for calling a sub-function</strong></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201030011921919.png" alt="image-20201030011921919" style="zoom:50%;" /></p>

<p>where <code class="language-plaintext highlighter-rouge">jal</code> does two things:</p>

<ul>
  <li>
    <p>store the <strong>address of your next line of code into register <code class="language-plaintext highlighter-rouge">$ra</code></strong></p>
  </li>
  <li>
    <p>jump to <code class="language-plaintext highlighter-rouge">myfunc</code></p>
  </li>
</ul>

<p><strong>Therefore, it is always used with <code class="language-plaintext highlighter-rouge">jr $ra</code></strong>, so that you come back.</p>

<h4 id="control-instructions">Control Instructions</h4>

<p>Here, you basically have another condition to check:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bne</code> = branch if not equal</li>
  <li><code class="language-plaintext highlighter-rouge">beq</code> = branch if equal</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201030012320852.png" alt="image-20201030012320852" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>it takes <strong>two registers to compare for equality</strong>, and <strong>jump to <code class="language-plaintext highlighter-rouge">myloop</code> label</strong></li>
</ul>

<blockquote>
  <p><strong>Note</strong>:</p>

  <ul>
    <li>There is actually another way, which is to use <code class="language-plaintext highlighter-rouge">b &lt;mylabel&gt;</code>. This is a pseudo code in MIPS.
      <ul>
        <li>this is basically the same as jump, since the compiler expands to <code class="language-plaintext highlighter-rouge">beq $0 $0 &lt;mylabel&gt;</code></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="mips-syntax">MIPS Syntax</h2>

<p>This section is written by myself. It contains summary of the tutorial I found online.</p>

<h3 id="data-typesliterals">Data Types/Literals</h3>

<p><strong>Data types</strong>:</p>

<ul>
  <li>Instructions are all 32 bits</li>
  <li>byte(8 bits), halfword (2 bytes), word (4 bytes)</li>
  <li>a character requires 1 byte of storage</li>
  <li>an <strong>integer</strong> requires 1 word (4 bytes) of storage</li>
</ul>

<p><strong>Literals</strong>:</p>

<ul>
  <li><strong>numbers</strong> entered as it is. e.g. 4</li>
  <li><strong>characters</strong> enclosed in <strong>single quotes</strong>. e.g. ‘b’</li>
  <li><strong>strings</strong> enclosed in <strong>double quotes</strong>. e.g. “A string”</li>
</ul>

<h3 id="registers">Registers</h3>

<p>Basically, we have:</p>

<ul>
  <li>32 general-purpose registers
    <ul>
      <li>see the section <a href="#MIPS Register Set">MIPS Register Set</a></li>
    </ul>
  </li>
  <li>register preceded by <code class="language-plaintext highlighter-rouge">$</code> in assembly language instruction, which have two formats for addressing:
    <ul>
      <li>using register number e.g. <code class="language-plaintext highlighter-rouge">$0</code> through <code class="language-plaintext highlighter-rouge">$31</code></li>
      <li>using equivalent <strong>names</strong> e.g. <code class="language-plaintext highlighter-rouge">$t1</code>, <code class="language-plaintext highlighter-rouge">$sp</code></li>
    </ul>
  </li>
  <li>stack grows from high memory to low memory</li>
</ul>

<h3 id="program-structure">Program Structure</h3>

<p>Basically, a program would just be a plain text file.</p>

<ul>
  <li>you use the extension <code class="language-plaintext highlighter-rouge">.s</code> so that SPIM could run it</li>
</ul>

<p><strong>Data Declarations</strong></p>

<ul>
  <li>placed in section of program <strong>identified with assembler directive <code class="language-plaintext highlighter-rouge">.data</code></strong></li>
  <li><strong>declares variable names</strong> used in program; storage allocated in main memory (RAM)</li>
</ul>

<p><strong>Code</strong></p>

<ul>
  <li>placed in section of text <strong>identified with assembler directive <code class="language-plaintext highlighter-rouge">.text</code></strong></li>
  <li>contains <strong>program code</strong> (instructions)</li>
  <li><strong>starting point for code execution given label <code class="language-plaintext highlighter-rouge">main:</code></strong></li>
  <li>ending point of main code should use exit <code class="language-plaintext highlighter-rouge">system call</code> (see below under System Calls)</li>
</ul>

<p><strong>Comments</strong></p>

<ul>
  <li>anything following <code class="language-plaintext highlighter-rouge">#</code> on a line
    <ul>
      <li>e.g. <code class="language-plaintext highlighter-rouge"># This stuff would be considered a comment</code></li>
    </ul>
  </li>
</ul>

<p><strong><em>For example:</em></strong></p>

<pre><code class="language-assembly"># Comment giving name of program and description of function
# Template.s
# Bare-bones outline of MIPS assembly language program

.data       # variable declarations follow this line
# ...

.text       # instructions follow this line	
																	
main:                  # indicates start of code (first instruction to execute)
                       # ...
									
# End of program, leave a blank line afterwards to make SPIM happy

</code></pre>

<h4 id="data-declaration-example">Data Declaration Example</h4>

<p>Format for declarations:</p>

<pre><code class="language-assembly"># after .data:
name:	storage_type	value(s)	
</code></pre>

<p>where you can:</p>

<ul>
  <li>create storage for variable of <strong>specified type</strong> with given <strong>name</strong> an<strong>d specified value</strong></li>
  <li>value(s) usually gives initial value(s); for storage type <code class="language-plaintext highlighter-rouge">.space</code>, <strong>gives number of spaces to be allocated</strong></li>
</ul>

<p><strong><em>For example:</em></strong></p>

<pre><code class="language-assembly">#after .data	
var1:		.word	3	# create a single integer variable with initial value 3
array1:		.byte	'a','b'	# create a 2-element character array with elements initialized
				#   to  a  and  b
array2:		.space	40	# allocate 40 consecutive bytes, with storage uninitialized
				#   could be used as a 40-element character array, or a
				#   10-element integer array; a comment should indicate which!	
</code></pre>

<h3 id="common-instructions">Common Instructions</h3>

<h4 id="loadstore">Load/Store</h4>

<p>This is used because:</p>

<ul>
  <li>RAM access only allowed with <code class="language-plaintext highlighter-rouge">load</code> and <code class="language-plaintext highlighter-rouge">store</code> instructions</li>
  <li><strong>all other instructions use register</strong> operands</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">load</code>:</p>

<ul>
  <li>
    <pre><code class="language-assembly">lw	register_destination, RAM_source
#copy word (4 bytes) at source RAM location to destination register.
</code></pre>
  </li>
  <li>
    <pre><code class="language-assembly">lb	register_destination, RAM_source
#copy byte at source RAM location to low-order byte of destination register,
# and sign-extend to higher-order bytes
</code></pre>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">store</code> word:</p>

<ul>
  <li>
    <pre><code class="language-assembly">sw	register_source, RAM_destination
#store word in source register into RAM destination
</code></pre>
  </li>
  <li>
    <pre><code class="language-assembly">sb	register_source, RAM_destination
#store byte (low-order) in source register into RAM destination
</code></pre>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">load</code> immediate:</p>

<ul>
  <li>
    <pre><code class="language-assembly">li	register_destination, value
#load immediate value into destination register
</code></pre>
  </li>
</ul>

<p><strong><em>For example:</em></strong></p>

<pre><code class="language-assembly">.data
var1:	.word	23		# declare storage for var1; initial value is 23

.text
__start:
	lw	$t0, var1		# load contents of RAM location into register $t0:  $t0 = var1
	li	$t1, 5		#  $t1 = 5   ("load immediate")
	sw	$t1, var1		# store contents of register $t1 into RAM:  var1 = $t1
	done
</code></pre>

<h4 id="indirect-and-based-addressing">Indirect and Based Addressing</h4>

<p>This is basically the pointer equivalent of <code class="language-plaintext highlighter-rouge">C</code>:</p>

<p><code class="language-plaintext highlighter-rouge">load</code> address:</p>

<ul>
  <li>
    <pre><code class="language-assembly">la	$t0, var1
</code></pre>

    <ul>
      <li>copy RAM address of <code class="language-plaintext highlighter-rouge">var1</code> (presumably a label defined in the program) into register <code class="language-plaintext highlighter-rouge">$t0</code></li>
      <li>equivalent of having <code class="language-plaintext highlighter-rouge">*t0 = var1</code>, where <strong><code class="language-plaintext highlighter-rouge">var1</code> would be an address</strong></li>
    </ul>
  </li>
</ul>

<p>indirect addressing:</p>

<ul>
  <li>
    <pre><code class="language-assembly">lw	$t2, ($t0)
</code></pre>

    <ul>
      <li>load word at RAM address contained in <code class="language-plaintext highlighter-rouge">$t0</code> into <code class="language-plaintext highlighter-rouge">$t2</code></li>
      <li>equivalent of having <code class="language-plaintext highlighter-rouge">*t2 = t0</code>, where <code class="language-plaintext highlighter-rouge">t0</code> <strong>contains an address</strong> (<strong>source</strong>)</li>
    </ul>
  </li>
  <li>
    <pre><code class="language-assembly">sw	$t2, ($t0)
</code></pre>

    <ul>
      <li>store word in register <code class="language-plaintext highlighter-rouge">$t2</code> into RAM at address contained in <code class="language-plaintext highlighter-rouge">$t0</code></li>
      <li>equivalent of having <code class="language-plaintext highlighter-rouge">*t0 = t2</code>, where <code class="language-plaintext highlighter-rouge">t0</code> <strong>contains an address</strong> (<strong>destination</strong>)</li>
    </ul>
  </li>
</ul>

<p>Therefore, you could also do the <strong>pointer arithmetic</strong> equivalent in assembly:</p>

<ul>
  <li>the only difference is that <code class="language-plaintext highlighter-rouge">+1</code> in <code class="language-plaintext highlighter-rouge">C</code> of a typed pointer will advance number of bytes dependent of the type, but assembly has no idea.</li>
  <li>Therefore, assembly always advances in the unit of <code class="language-plaintext highlighter-rouge">1 Byte</code></li>
</ul>

<p><strong><em>For example</em></strong></p>

<ul>
  <li>
    <pre><code class="language-assembly">lw	$t2, 4($t0)
</code></pre>

    <ul>
      <li>load word at RAM <strong>address (<code class="language-plaintext highlighter-rouge">$t0</code>+4)</strong> into register <code class="language-plaintext highlighter-rouge">$t2</code>
        <ul>
          <li>basically advances 4 bytes from the address of <code class="language-plaintext highlighter-rouge">$t0</code></li>
          <li>e.g. 4 bytes could mean an integer</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>In general</strong>, this is useful for:</p>

<ul>
  <li><strong>arrays</strong>; access elements as offset from base address</li>
  <li><strong>stacks</strong>; easy to access elements at offset from stack pointer or frame pointer</li>
</ul>

<p><strong><em>For example</em></strong></p>

<pre><code class="language-assembly">.data
array1:		.space	12		#  declare 12 bytes of storage to hold array of 3 integers
.text
__start:	la	$t0, array1		#  load base address of array into register $t0
		li	$t1, 5		#  $t1 = 5   ("load immediate")
		sw $t1, ($t0)		#  first array element set to 5; indirect addressing
		li $t1, 13		#   $t1 = 13
		sw $t1, 4($t0)		#  second array element set to 13
		li $t1, -7		#   $t1 = -7
		sw $t1, 8($t0)		#  third array element set to -7
		done		# now you have initialized the array `array1` with three integers
</code></pre>

<h4 id="arithmetic-instructions">Arithmetic Instructions</h4>

<ul>
  <li><strong>most</strong> use <strong>3 operands</strong></li>
  <li><strong>all operands are registers</strong>; no RAM or indirect addressing</li>
  <li>operand size is word (4 bytes)
    <ul>
      <li>since each register stores 4 bytes</li>
    </ul>
  </li>
</ul>

<p>Most of the common ones are listed below:</p>

<pre><code class="language-assembly">add	$t0,$t1,$t2	#  $t0 = $t1 + $t2;   add as signed (2's complement) integers
sub	$t2,$t3,$t4	#  $t2 = $t3 - $t4
addi	$t2,$t3, 5	#  $t2 = $t3 + 5;   "add immediate" (no sub immediate)
addu	$t1,$t6,$t7	#  $t1 = $t6 + $t7;   add as unsigned integers
subu	$t1,$t6,$t7	#  $t1 = $t6 + $t7;   subtract as unsigned integers

mult	$t3,$t4		#  multiply 32-bit quantities in $t3 and $t4, and store 64-bit
#  result in special registers Lo and Hi:  (Hi,Lo) = $t3 * $t4
div	$t5,$t6		#  Lo = $t5 / $t6   (integer quotient)
#  Hi = $t5 mod $t6   (remainder)
mfhi	$t0		#  move quantity in special register Hi to $t0:   $t0 = Hi
mflo	$t1		#  move quantity in special register Lo to $t1:   $t1 = Lo
#  used to get at result of product or quotient

move	$t2,$t3	#  $t2 = $t3
</code></pre>

<p>where:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">mult</code> and <code class="language-plaintext highlighter-rouge">div</code> would be always used with <code class="language-plaintext highlighter-rouge">mfhi</code> and <code class="language-plaintext highlighter-rouge">mflo</code></strong>
    <ul>
      <li>because data goes in the special register <code class="language-plaintext highlighter-rouge">Hi</code> and <code class="language-plaintext highlighter-rouge">Lo</code></li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">move</code> is basically assigning “variables”</strong></li>
</ul>

<h4 id="control-structures">Control Structures</h4>

<p>Examples are shown in the other section, and here would be a summary of common branching syntax:</p>

<pre><code class="language-assembly">b	target		#  unconditional branch to program label target, equivalent as goto
beq	$t0,$t1,target	#  branch to target if  $t0 = $t1
blt	$t0,$t1,target	#  branch to target if  $t0 &lt; $t1
ble	$t0,$t1,target	#  branch to target if  $t0 &lt;= $t1
bgt	$t0,$t1,target	#  branch to target if  $t0 &gt; $t1
bge	$t0,$t1,target	#  branch to target if  $t0 &gt;= $t1
bne	$t0,$t1,target	#  branch to target if  $t0 &lt;&gt; $t1
</code></pre>

<p>where:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">target</code> would be a label</strong></li>
</ul>

<p>For subroutine calls (sub-function) calls, use:</p>

<ul>
  <li>
    <p>“jump and link” instruction</p>

    <pre><code class="language-assembly">jal	sub_label	#  "jump and link"
</code></pre>
  </li>
</ul>

<h4 id="using-stacks">Using Stacks</h4>

<p>This is very useful for recursive function calls, since you need to <strong>store your <code class="language-plaintext highlighter-rouge">$ra</code> in nested functions</strong> so that <code class="language-plaintext highlighter-rouge">$ra</code> will not get lost.</p>

<ul>
  <li>to do this, you need to use the <strong>stack pointer register <code class="language-plaintext highlighter-rouge">$sp</code></strong></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201031140647946.png" alt="image-20201031140647946" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>The stack <strong>grows downward</strong> in terms of memory addresses.</li>
  <li>The address of the <strong>top element</strong> of the stack <strong>is stored</strong> (by convention) in the “stack pointer” register, <code class="language-plaintext highlighter-rouge">$sp</code>.</li>
</ul>

<p>So, to use a stack:</p>

<ul>
  <li><strong>To <em>push</em> elements onto the stack</strong>:
    <ol>
      <li><strong>Move the stack pointer <code class="language-plaintext highlighter-rouge">$sp</code> down</strong> to make room for the new data.</li>
      <li>Store the elements into the stack.</li>
    </ol>
  </li>
  <li><strong>Access elements on the stack</strong>
    <ul>
      <li>You can access any element in the stack (not just the top one) if you know where it is <strong>relative to <code class="language-plaintext highlighter-rouge">$sp</code></strong></li>
    </ul>
  </li>
  <li><strong>To <em>pop</em> elements from the stack</strong>
    <ul>
      <li>pop, or “erase,” elements simply by <strong>adjusting the stack pointer upwards</strong>.</li>
    </ul>
  </li>
</ul>

<p><strong><em>For example:</em></strong></p>

<ul>
  <li>
    <p>Pushing elements in <code class="language-plaintext highlighter-rouge">$t1</code> and <code class="language-plaintext highlighter-rouge">$t2</code>:</p>

    <ul>
      <li>as they are stored in register, they <strong>must be 4 bytes data</strong></li>
    </ul>

    <pre><code class="language-assembly">sub $sp, $sp, 8
sw $t1, 4($sp)
sw $t2, 0($sp)
</code></pre>

    <p><img src="\lectures\images\typora-user-images\image-20201031141050698.png" alt="image-20201031141050698" style="zoom:50%;" /></p>
  </li>
  <li>
    <p>Accessing elements</p>

    <pre><code class="language-assembly">lw $s0, 4($sp)
</code></pre>

    <p><img src="\lectures\images\typora-user-images\image-20201031141140959.png" alt="image-20201031141140959" style="zoom: 50%;" /></p>
  </li>
  <li>
    <p>Popping elements</p>

    <pre><code class="language-assembly">addi $sp, $sp, 4
</code></pre>

    <p><img src="\lectures\images\typora-user-images\image-20201031141214515.png" alt="image-20201031141214515" style="zoom: 50%;" /></p>
  </li>
</ul>

<h4 id="system-calls">System Calls</h4>

<ul>
  <li>used to read or print values or strings from <strong>input/output window</strong>, and indicate <strong>program end</strong></li>
  <li>use <code class="language-plaintext highlighter-rouge">syscall</code> operating system routine call</li>
</ul>

<p>To use <code class="language-plaintext highlighter-rouge">syscall</code>, you need to specify the follows:</p>

<ul>
  <li>first <strong>supply</strong> appropriate values in registers <strong><code class="language-plaintext highlighter-rouge">$v0</code> and <code class="language-plaintext highlighter-rouge">$a0</code>-<code class="language-plaintext highlighter-rouge">$a1</code></strong>
    <ul>
      <li>both are used by <code class="language-plaintext highlighter-rouge">syscall</code></li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201031141522720.png" alt="image-20201031141522720" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">print_string</code> service expects the address to start <strong>a null-terminated</strong> character string.
    <ul>
      <li>The type <code class="language-plaintext highlighter-rouge">.asciiz</code> creates a null-terminated character string. (see <a href="#Example: Implement `strlen`">Example: Implement <code class="language-plaintext highlighter-rouge">strlen</code></a>)</li>
    </ul>
  </li>
  <li>The <code class="language-plaintext highlighter-rouge">read_int</code>, <code class="language-plaintext highlighter-rouge">read_float</code> and <code class="language-plaintext highlighter-rouge">read_double</code> services read <strong>an entire line of input up to and including the newline character</strong>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">read_string</code> service has the same semantics as the UNIX library routine <code class="language-plaintext highlighter-rouge">fgets</code>.
    <ul>
      <li>It reads up to <strong>n-1 characters into a buffer</strong> and <strong>terminates the string with a <code class="language-plaintext highlighter-rouge">null</code> character</strong>.</li>
      <li>If fewer than n-1 characters are in the current line, it reads up to and including the newline and terminates the string with a null character.</li>
    </ul>
  </li>
  <li>The <code class="language-plaintext highlighter-rouge">sbrk</code> service returns the address to a block of memory containing n additional bytes. This would be used for dynamic memory allocation.</li>
  <li>The <code class="language-plaintext highlighter-rouge">exit</code> service <strong>stops a program from running</strong>.</li>
</ul>

<blockquote>
  <p><strong>Note</strong>:</p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">$v0</code> is used to specify which of the <code class="language-plaintext highlighter-rouge">syscall</code> to call</li>
  </ul>
</blockquote>

<h3 id="subroutines-with-stack">Subroutines with Stack</h3>

<p>A subroutine is code that, after executing, <strong>resumes whatever invoked it</strong>.</p>

<p>This will be very useful for:</p>

<ul>
  <li>Code reuse (recurring computations, function libraries)</li>
  <li>Isolation/Abstraction (function callers don’t need to understand the implementation)</li>
  <li>Recursion</li>
</ul>

<h4 id="calling-conventions">Calling Conventions</h4>

<p>Sine registers are preserved across function calls, while some are not.</p>

<p><img src="\lectures\images\typora-user-images\image-20201103235752697.png" alt="image-20201103235752697" /></p>

<p>where:</p>

<ul>
  <li>for example, data stored in <code class="language-plaintext highlighter-rouge">$s0</code>-<code class="language-plaintext highlighter-rouge">$s7</code> should be “made intact” after a subroutine call
    <ul>
      <li>this means that the data there <strong>before a subroutine function</strong> call should be the <strong>same as the data after the call</strong></li>
      <li>for data that are not “preserved” <strong>by convention</strong>, you can just use them freely in your subroutine without restoring them</li>
      <li>since this is a <strong>convention. You can choose not to obey it</strong>. However, it will</li>
    </ul>
  </li>
</ul>

<p>This means:</p>

<p><img src="\lectures\images\typora-user-images\image-20201104002138261.png" alt="image-20201104002138261" style="zoom:80%;" /></p>

<p>where:</p>

<ul>
  <li>for <code class="language-plaintext highlighter-rouge">$ra</code> especially, within <strong>one level of <code class="language-plaintext highlighter-rouge">jal</code>, it will be fine</strong>.
    <ul>
      <li>e.g. if <strong><code class="language-plaintext highlighter-rouge">bar</code> above <em>does not</em> alter <code class="language-plaintext highlighter-rouge">$ra</code></strong>, then you <strong>don’t need to do anything in <code class="language-plaintext highlighter-rouge">bar</code></strong></li>
    </ul>
  </li>
  <li>however, if you have <strong>more than one level of subroutine</strong>, e.g. recursive call, you need to <strong>use your stack to save it</strong> before it gets altered</li>
</ul>

<h4 id="example-recursive-strlen">Example: Recursive <code class="language-plaintext highlighter-rouge">strlen</code></h4>

<p>Basically, it looks like:</p>

<p><img src="\lectures\images\typora-user-images\image-20201104002850291.png" alt="image-20201104002850291" style="zoom: 50%;" /></p>

<p>where:</p>

<ul>
  <li>here, in the <code class="language-plaintext highlighter-rouge">strlen</code>, since it is recursive, there could be <strong>more than 1 level of subroutine (itself) being called</strong>.
    <ul>
      <li>i.e. the first <code class="language-plaintext highlighter-rouge">jal</code> works as expected, since it first stores your <code class="language-plaintext highlighter-rouge">$ra</code>. But the <strong>second <code class="language-plaintext highlighter-rouge">jal</code> will overwrite the previous</strong> <code class="language-plaintext highlighter-rouge">$ra</code></li>
      <li>therefore, imagine yourself in the second <code class="language-plaintext highlighter-rouge">jal</code> function. Then you need to <strong>save where you need to return, and proceed</strong></li>
    </ul>
  </li>
  <li>in the <code class="language-plaintext highlighter-rouge">strlen_basecase</code>, since it <strong>does not call more than 1 level of subroutine or alter any preserved value</strong>, you don’t need to save anything.</li>
</ul>

<h1 id="week-9">Week 9</h1>

<h2 id="using-spim">Using SPIM</h2>

<p>Basically, the software QtSpim is used for simulating writing MIPS and talk to a CPU.</p>

<ul>
  <li>since MIPS is a RISC, most CPU you have in your laptop won’t talk to it.</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201030013630223.png" alt="image-20201030013630223" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>the address of <strong>each instruction is exactly 4 bytes</strong> apart (32 bits apart)</li>
  <li>rightest column is the <strong>program’s code you wrote</strong></li>
  <li>the second column from right is the <strong>program’s code interpreted by the compiler</strong></li>
</ul>

<blockquote>
  <p><strong>Note</strong>:</p>

  <ul>
    <li>For most editors, if you name your <strong>program ending with <code class="language-plaintext highlighter-rouge">.s</code> as extension</strong>, then you will get the correct syntax highlighting for MIPS code.</li>
  </ul>
</blockquote>

<h3 id="example-implement-strlen">Example: Implement <code class="language-plaintext highlighter-rouge">strlen</code></h3>

<p>This is basically the context:</p>

<p><img src="\lectures\images\typora-user-images\image-20201030013938188.png" alt="image-20201030013938188" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">"Hello w.."</code> is the string stored in your memory, ending with <code class="language-plaintext highlighter-rouge">\0</code>.
    <ul>
      <li>each character is 1 Byte.</li>
    </ul>
  </li>
  <li>the register <code class="language-plaintext highlighter-rouge">$a0</code> is representative of your <strong>function argument</strong>
    <ul>
      <li>assume that the pointer to that string is passed into the argument <code class="language-plaintext highlighter-rouge">$a0</code></li>
    </ul>
  </li>
  <li>and we <strong>need</strong> to <strong>return the length in a register <code class="language-plaintext highlighter-rouge">$v0</code></strong></li>
</ul>

<pre><code class="language-assembly">#inside strlen.s
.text  # directive to the assembler, that instructions starts after this line

strlen:
	li $v0, 0
	jr $ra

main:	# like most compiler, program starts with main
	# push $ra onto stack
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	
	# invoke strlen that we need to write, on the hello
	la $a0, hello	# take the pointer to hello, and put it in register $a0
	jal strlen	# call strlen function, which will take that $a0
	
	# print result to screen
	move $a0, $v0	# get the data from $v0, and put it into $a0
	li $v0, 1
	syscall	# prints the data using the argument $a0
	
	# restore $ra from stack
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	
	jr $ra

.data  # directive to the assmebler, that data comes after this line

hello:	.asciiz "Hello, world!!!"
</code></pre>

<p>and to correctly implement the <code class="language-plaintext highlighter-rouge">strlen</code> function, we need to implement <code class="language-plaintext highlighter-rouge">strlen</code>.</p>

<ul>
  <li>the idea is that we take a counter.</li>
  <li>If the next byte of string is not <code class="language-plaintext highlighter-rouge">0</code>, we:
    <ul>
      <li>increment the counter</li>
      <li>move the pointer to the next byte</li>
    </ul>
  </li>
  <li>done when we get a <code class="language-plaintext highlighter-rouge">0</code></li>
</ul>

<pre><code class="language-assembly">strlen:
	# initialize count
	li $v0, 0

# remember, program runs from top to bottom
strlen_top:	
	# load character from mem
	lbu $t0, 0($a0)

	# check if done
	beq $t0, $0, strlen_return

	# increment counter &amp; advance pointer
	addi $v0, $v0, 1
	addi $a0, $a0, 1

	# go back to the top of the loop
	b strlen_top # pseudo instruction
	
strlen_return:		
	jr $ra
</code></pre>

<p>where:</p>

<ul>
  <li>if you simply had <code class="language-plaintext highlighter-rouge">b strlen</code>, then you <strong>will have re-initialized your counter</strong></li>
</ul>

<h1 id="week-10">Week 10</h1>

<h2 id="mips-memory-layout">MIPS Memory Layout</h2>

<p><img src="\lectures\images\typora-user-images\image-20201110231726919.png" alt="image-20201110231726919" style="zoom: 50%;" /></p>

<p>where:</p>

<ul>
  <li>it is basically what we know from <code class="language-plaintext highlighter-rouge">C</code></li>
  <li>the <code class="language-plaintext highlighter-rouge">text segment</code> is indicative of the <strong><code class="language-plaintext highlighter-rouge">.text</code> declaration</strong>
    <ul>
      <li>where our code goes</li>
    </ul>
  </li>
  <li>the <code class="language-plaintext highlighter-rouge">static data</code> is indicative of the <code class="language-plaintext highlighter-rouge">.data</code> declaration
    <ul>
      <li>where our static variables go</li>
    </ul>
  </li>
  <li>the <code class="language-plaintext highlighter-rouge">stack + heap</code> is the place for dynamic data
    <ul>
      <li><code class="language-plaintext highlighter-rouge">stack</code> is used by the <code class="language-plaintext highlighter-rouge">$sp</code> (by user) , also used for general subroutines calls (by MIPS)</li>
      <li><code class="language-plaintext highlighter-rouge">heap</code> is used when you do <code class="language-plaintext highlighter-rouge">syscall</code> for memory allocation (similar as <code class="language-plaintext highlighter-rouge">malloc</code> in C)</li>
    </ul>
  </li>
</ul>

<h2 id="interpreting-a-call-stack">Interpreting a Call Stack</h2>

<p>Essentially, the <strong>information stored in a call stack</strong> would be identical to the <strong>current path</strong> in our <strong>call tree</strong>.</p>

<p>Consider a simple code that does:</p>

<pre><code class="language-pseu">main(){
	# looping 10 times
	for i=1,2,...10:
		foo()
}

foo(){
	bar()
}
</code></pre>

<p>and the call tree looks like:</p>

<p><img src="\lectures\images\typora-user-images\image-20201110233713605.png" alt="image-20201110233713605" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>at any point, you call stack stores information identical to the structure of the current path in your call tree</li>
</ul>

<h2 id="more-recursive-examples">More Recursive Examples</h2>

<h3 id="recursive-array_min-function">Recursive <code class="language-plaintext highlighter-rouge">array_min</code> function</h3>

<p>Suppose you have an array of integers, and you need to find the minimum value of the elements in the array</p>

<ul>
  <li>think about it, it would be easy to solve using <strong>tail recursion</strong></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">array_min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ptr</span><span class="p">){</span>
	<span class="k">if</span> <span class="n">len</span><span class="o">==</span><span class="mi">0</span> 
        <span class="k">return</span> <span class="n">MAXVAL</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">array_min</span><span class="p">(</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ptr</span><span class="o">+</span><span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>MIPS:</p>

<pre><code class="language-assembly">.text
array_min:
	# if len is zero
	beqz $a0, array_min_basecase

	addi $sp, $sp, -8
	sw $ra, 0($sp)
	sw $s0, 4($sp) # s0 should be kept unchanged as well, since it is preserved
	
	# recurs
	# load first int in array to s0 (because we have a pointer)
	lw $s0, 0($a1) # altered s0, which could happen recursively

	addi $a0, $a0, -1 # len=len-1
	addi $a1, $a1, 4 # ptr += 4
	
 	jal array_min # subroutine call
 	
 	# return min(s0, v0)
 	slt $t0, $s0, $v0 # if s0 is smaller, t0=1
 	bnez $t0, array_min_s0_larger
 	
array_min_return_v0:
 	# return v0
 	
 	# restore
	lw $ra, 0($sp)
	lw $s0, 4($sp)
 	addi $sp, $sp, 9
	
 	jr $ra

array_min_s0_larger:
	move $v0, $s0
	b array_min_return_v0

array_min_basecase:
	li $v0, 0x7ffffff
	jr $ra

main:
	addi $sp, $sp, -4
	sw $r0, 0($sp)

	li $a0, -43
	la $a1, test_array
	jal array_min
	move $a0, $v0
	jal print_int
	
	lw $r0, 0($sp)
	addi $sp, $sp, 4
	
	jr $ra

print_int:
	li $v0, 10
	syscall
	jr $ra
	
.data

test_array: 	.word 3,5,-9,3,1
</code></pre>

<h2 id="instruction-encodings">Instruction Encodings</h2>

<p>Basically, this talks about how we get instructions into machine code.</p>

<ul>
  <li>this gets encoded by the <strong>assembler</strong></li>
  <li>the machine code is finally <strong>read and executed</strong> by your processor</li>
</ul>

<p><strong><em>For example</em></strong></p>

<p><img src="\lectures\images\typora-user-images\image-20201113022535876.png" alt="image-20201113022535876" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>notice that <strong>each instruction</strong> has the size of 4 bytes, which is again, 32 bits.</li>
  <li>and <strong>PC</strong> stands for the program counter, which basically is the <strong>address of the current instruction</strong>
    <ul>
      <li>this is sometimes also referred to as instruction pointer (<strong>IP</strong>)</li>
    </ul>
  </li>
</ul>

<h3 id="mips-instruction-formats">MIPS Instruction Formats</h3>

<p>All MIPS instructions are <strong>encoded</strong> into one of the three formats.</p>

<ul>
  <li><strong>R-Type</strong> - register operands</li>
  <li><strong>I-Type</strong> - immediate operands</li>
  <li><strong>J-Type</strong> - for jumping</li>
</ul>

<p>where:</p>

<ul>
  <li>remember from the above that each encoding/encoded instruction is also 32 bits wide</li>
</ul>

<h4 id="r-type">R-Type</h4>

<p>The structure looks like this:</p>

<p><img src="\lectures\images\typora-user-images\image-20201113024158904.png" alt="image-20201113024158904" style="zoom: 33%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">op</code> means the code for the operation you are doing
    <ul>
      <li>works together with <code class="language-plaintext highlighter-rouge">funct</code> field</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">rs</code>/<code class="language-plaintext highlighter-rouge">rt</code> would be source registers</li>
  <li><code class="language-plaintext highlighter-rouge">rd</code> would be destination register
    <ul>
      <li>notice each of them has 5 bits, which makes sense since $2^5 = 32$ registers in total</li>
      <li>e.g. <code class="language-plaintext highlighter-rouge">$ra</code> would represent <code class="language-plaintext highlighter-rouge">register id=31</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">shamt</code> is used <strong>only</strong> for the shift instructions.
    <ul>
      <li>it will be <code class="language-plaintext highlighter-rouge">0</code> for all the other operations</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">funct</code> can be understood as a little <strong>extension</strong> to the opcode field, to tell the processor what operation</li>
</ul>

<p><strong><em>For example:</em></strong></p>

<p>Consider the assembly code:</p>

<pre><code class="language-assembly">add $s0, $s1, $s2
sub $t0, $t3, $t5
</code></pre>

<p>Has the following values:</p>

<p><img src="\lectures\images\typora-user-images\image-20201113024332905.png" alt="image-20201113024332905" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>e.g. <code class="language-plaintext highlighter-rouge">$s0</code> has register value of <code class="language-plaintext highlighter-rouge">17</code></li>
  <li>
    <p>e.g. <code class="language-plaintext highlighter-rouge">funct</code> field for <code class="language-plaintext highlighter-rouge">add</code> instruction is <code class="language-plaintext highlighter-rouge">op=3</code> <strong>WITH</strong> <code class="language-plaintext highlighter-rouge">funct=32</code></p>
  </li>
  <li>e.g. <code class="language-plaintext highlighter-rouge">shamt</code> is <code class="language-plaintext highlighter-rouge">0</code> because we are not shifting</li>
</ul>

<p>Lastly, encoding into binary:</p>

<p><img src="\lectures\images\typora-user-images\image-20201113024543119.png" alt="image-20201113024543119" style="zoom: 50%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">000000 10001 10010 10000 00000 100000</code> is in <strong>hex</strong> <code class="language-plaintext highlighter-rouge">0x 02328020</code></li>
</ul>

<h4 id="i-type">I-Type</h4>

<p>Those are basically instructions that involves <strong>immediates</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201113024919050.png" alt="image-20201113024919050" style="zoom: 33%;" /></p>

<p>where:</p>

<ul>
  <li>only <code class="language-plaintext highlighter-rouge">op</code> is enough for identifying the operation</li>
  <li>both <code class="language-plaintext highlighter-rouge">rs</code> and <code class="language-plaintext highlighter-rouge">rt</code> could be source/destination</li>
  <li><code class="language-plaintext highlighter-rouge">imm</code> would store the <strong>immediates</strong> that you have for instructions
    <ul>
      <li>e.g. <code class="language-plaintext highlighter-rouge">addi $t0, $t0, 1</code>, so <code class="language-plaintext highlighter-rouge">1</code> is stored in the <code class="language-plaintext highlighter-rouge">imm</code></li>
      <li>in fact, the <code class="language-plaintext highlighter-rouge">branch</code> instructions also pertain to this category</li>
    </ul>
  </li>
</ul>

<p><strong><em>For example:</em></strong></p>

<p><img src="\lectures\images\typora-user-images\image-20201113025217788.png" alt="image-20201113025217788" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>notice that for <code class="language-plaintext highlighter-rouge">lw</code> and <code class="language-plaintext highlighter-rouge">sw</code>, the <strong>offset for pointer</strong> is an immediate that is also stored in <code class="language-plaintext highlighter-rouge">imm</code></li>
  <li>for the line <code class="language-plaintext highlighter-rouge">lw $t2, 32($0)</code> has:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">$t2</code> = <code class="language-plaintext highlighter-rouge">rt</code> (destination)</li>
      <li><code class="language-plaintext highlighter-rouge">$0</code> = <code class="language-plaintext highlighter-rouge">rs</code> (source)</li>
    </ul>
  </li>
  <li>but the line <code class="language-plaintext highlighter-rouge">sw $s1, 4($t1)</code> has:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">$s1</code>=<code class="language-plaintext highlighter-rouge">rt</code> (source)</li>
      <li><code class="language-plaintext highlighter-rouge">$t1</code>=<code class="language-plaintext highlighter-rouge">rs</code> (source)
        <ul>
          <li>because you need to read the address contained in this register, <strong><em>not</em></strong> write to this register</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>then, the encoding becomes:</p>

<p><img src="\lectures\images\typora-user-images\image-20201113025243753.png" alt="image-20201113025243753" style="zoom:50%;" /></p>

<h4 id="j-type">J-Type</h4>

<p>When you jump:</p>

<p><img src="\lectures\images\typora-user-images\image-20201113030113150.png" alt="image-20201113030113150" style="zoom:33%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">addr</code> contains the <strong>address</strong> of the <strong>next instruction</strong></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201113030421025.png" alt="image-20201113030421025" style="zoom:50%;" /></p>

<h2 id="architecture-vs-microarchitecture">Architecture vs Microarchitecture</h2>

<ul>
  <li>MIPS (IS) Architecture means the <strong>Hardware/software interface</strong>
    <ul>
      <li>e.g. the programs we write</li>
    </ul>
  </li>
  <li>MIPS Microarchitecture means the <strong>implementation of the interface</strong>
    <ul>
      <li>e.g. the processor that executes the ISA</li>
      <li>so that when processors get better, the idea is that the same ISA would still be supported (hence no change in softwares)</li>
    </ul>
  </li>
</ul>

<p>Here, we cover two microarchitectures:</p>

<ol>
  <li><strong>Single Cycle Processor</strong></li>
  <li><strong>Pipeline Processor</strong></li>
</ol>

<p>which supports the following interface/(IS):</p>

<p><img src="\lectures\images\typora-user-images\image-20201113030752518.png" alt="image-20201113030752518" style="zoom:50%;" /></p>

<h3 id="arithmetic-logic-unit-alu">Arithmetic Logic Unit (ALU)</h3>

<p>This component will be used by the processors.</p>

<p>This component performs varies <strong>arithmetic and logical computations</strong>.</p>

<ul>
  <li>every processor will have at least one of this.</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201113031405777.png" alt="image-20201113031405777" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>each input/output will be <code class="language-plaintext highlighter-rouge">N</code> bits</li>
  <li>the <code class="language-plaintext highlighter-rouge">3</code> bits <code class="language-plaintext highlighter-rouge">F</code> is basically the control signal</li>
</ul>

<blockquote>
  <p><strong>Implementation</strong></p>

  <ul>
    <li>
      <p>Up to this point, you should be able to figure how exactly how each abstraction works, and how the circuit works:</p>

      <p><img src="\lectures\images\typora-user-images\image-20201113031550228.png" alt="image-20201113031550228" style="zoom:50%;" /></p>
    </li>
  </ul>
</blockquote>

<h3 id="state-elements-of-mips-processor">State Elements of MIPS Processor</h3>

<p>Other important components we need to know is:</p>

<p><img src="\lectures\images\typora-user-images\image-20201113031744468.png" alt="image-20201113031744468" style="zoom:50%;" /></p>

<p>where, on the high level:</p>

<ul>
  <li>the left-most <code class="language-plaintext highlighter-rouge">PC</code> contains the address of current instruction</li>
</ul>

<h4 id="instruction-memory-and-data-memory">Instruction Memory and Data Memory</h4>

<p>The idea is:</p>

<ul>
  <li><strong>Address Input</strong> produces <strong>Data Output</strong>
    <ul>
      <li>where, the <strong>data</strong> could be instructions/actual data</li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201113032027310.png" alt="image-20201113032027310" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li><strong>Instruction Memory</strong> can only read:
    <ul>
      <li>gets an address from <code class="language-plaintext highlighter-rouge">A</code></li>
      <li>output the instruction encoding at that address <strong>to</strong> <code class="language-plaintext highlighter-rouge">RD</code></li>
    </ul>
  </li>
  <li><strong>Data Memory</strong> can both <strong>read and write:</strong>
    <ul>
      <li>gets an address to read/write from <code class="language-plaintext highlighter-rouge">A</code> (controlled by the <code class="language-plaintext highlighter-rouge">WE</code>/write enable control)
        <ul>
          <li>if read <code class="language-plaintext highlighter-rouge">WE=0</code>, read content goes out <strong>to</strong> <code class="language-plaintext highlighter-rouge">RD</code></li>
          <li>if write <code class="language-plaintext highlighter-rouge">WE=1</code>, content to write goes in <strong>from</strong> <code class="language-plaintext highlighter-rouge">WD</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="register-file">Register File</h4>

<p>The storage of <strong>all the registers</strong> you are using in MIPS</p>

<ul>
  <li>contains 32, <code class="language-plaintext highlighter-rouge">32</code>-bit registers</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201113032729498.png" alt="image-20201113032729498" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>remember that the address of registers are just <code class="language-plaintext highlighter-rouge">0-31</code>, hence only needs <code class="language-plaintext highlighter-rouge">5</code> bits</li>
  <li>since the implementations takes 3 registers at most, we could:
    <ul>
      <li><strong>read</strong> two <strong>registers</strong> using <code class="language-plaintext highlighter-rouge">A1</code> and <code class="language-plaintext highlighter-rouge">A2</code> address, with read data outputted to <code class="language-plaintext highlighter-rouge">RD1</code> and <code class="language-plaintext highlighter-rouge">RD2</code></li>
      <li><strong>writing</strong> contents to a destination <strong>register</strong> with <code class="language-plaintext highlighter-rouge">A3</code> address, with data <code class="language-plaintext highlighter-rouge">WD3</code> to write to.
        <ul>
          <li>note, if you are reading and writing in the <strong>same cycle</strong>, you should always ensure that <strong>write happens after read</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="program-counter">Program Counter</h4>

<p>A register that holds a pointer (address) to the <strong>current</strong> instruction.</p>

<p><img src="\lectures\images\typora-user-images\image-20201113034347078.png" alt="image-20201113034347078" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>the <strong>next instruction</strong> would be the <code class="language-plaintext highlighter-rouge">PC'</code>
    <ul>
      <li>usually, if we have a linear execution without branching, it will just be <code class="language-plaintext highlighter-rouge">PC+4</code> to move on to the next instruction</li>
    </ul>
  </li>
</ul>

<h1 id="week-11">Week 11</h1>

<h2 id="single-cycle-processor-implementation">Single Cycle Processor Implementation</h2>

<p>The final processor will be the <strong>union of all the below instruction implementations</strong>.</p>

<ul>
  <li>there could be a more efficient way to do it, but this approach is simple and straightforward</li>
</ul>

<h3 id="executing-the-lw-instruction">Executing the <code class="language-plaintext highlighter-rouge">lw</code> Instruction</h3>

<p>First, remember we are <strong>executing</strong> something like:</p>

<p><img src="\lectures\images\typora-user-images\image-20201113034728490.png" alt="image-20201113034728490" style="zoom: 67%;" /></p>

<p>So:</p>

<ol>
  <li>
    <p><strong>Fetch</strong> this <strong>instruction</strong> using the address from the <strong>instruction memory</strong></p>

    <p><img src="\lectures\images\typora-user-images\image-20201113034826372.png" alt="image-20201113034826372" style="zoom: 50%;" /></p>

    <p>note:</p>

    <ul>
      <li>technically, fetching the instruction from instruction memory does not take a clock cycle.</li>
    </ul>
  </li>
  <li>
    <p>Read <code class="language-plaintext highlighter-rouge">rs</code> register from <strong>register file</strong>:</p>

    <ul>
      <li>the <strong>address</strong> of <code class="language-plaintext highlighter-rouge">rs</code> would be the <code class="language-plaintext highlighter-rouge">25th - 21th</code> bit of the instruction</li>
      <li>since we are dealing with <code class="language-plaintext highlighter-rouge">lw</code>, <code class="language-plaintext highlighter-rouge">rs</code> stores the target pointer to load</li>
    </ul>

    <p><img src="\lectures\images\typora-user-images\image-20201113034941036.png" alt="image-20201113034941036" style="zoom: 50%;" /></p>
  </li>
  <li>
    <p>Sign-extend the <strong>immediate</strong> (16 bits) to become 32 bits</p>

    <p><img src="\lectures\images\typora-user-images\image-20201113035235122.png" alt="image-20201113035235122" style="zoom: 50%;" /></p>
  </li>
  <li>
    <p><strong>Compute</strong> the memory address</p>

    <ul>
      <li>
        <p>calculate the base address (<code class="language-plaintext highlighter-rouge">rs</code>) + offset (from intermediate)</p>

        <p><img src="\lectures\images\typora-user-images\image-20201113035433847.png" alt="image-20201113035433847" style="zoom: 50%;" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p>Use the computed memory address to <strong>read data from Data Memory</strong>, back to register file for writing</p>

    <ul>
      <li>remember, we use the content of data to write to/save to another register <code class="language-plaintext highlighter-rouge">rt</code></li>
      <li>to write, <strong>give <code class="language-plaintext highlighter-rouge">WE=1</code></strong></li>
      <li>the target register to write is stored in <code class="language-plaintext highlighter-rouge">rt</code>, with <code class="language-plaintext highlighter-rouge">20th-16th</code> bit from the instruction</li>
    </ul>

    <p><img src="\lectures\images\typora-user-images\image-20201113035607562.png" alt="image-20201113035607562" style="zoom:50%;" /></p>
  </li>
  <li>
    <p>Now, the computation is completed, and we need to <strong>decide</strong> on the <strong>next instruction</strong>:</p>

    <ul>
      <li>in this case, we simply add <code class="language-plaintext highlighter-rouge">4</code> to get the <strong>address of the next instruction</strong> (since <code class="language-plaintext highlighter-rouge">lw</code> is <strong><em>not</em></strong> jump)</li>
    </ul>

    <p><img src="\lectures\images\typora-user-images\image-20201113040236783.png" alt="image-20201113040236783" style="zoom:50%;" /></p>
  </li>
</ol>

<blockquote>
  <p><strong>Note</strong>:</p>

  <ul>
    <li>The above did not discuss the <strong><code class="language-plaintext highlighter-rouge">op</code> code</strong>, which actually <strong>contributes to the control signals</strong> at the point when instruction is read:</li>
  </ul>

  <p><img src="\lectures\images\typora-user-images\image-20201113040506224.png" alt="image-20201113040506224" style="zoom:50%;" /></p>

  <ul>
    <li>The initiation of <code class="language-plaintext highlighter-rouge">PC</code> is set by the OS (not for us to control)</li>
  </ul>
</blockquote>

<h3 id="executing-the-sw-instruction">Executing the <code class="language-plaintext highlighter-rouge">sw</code> Instruction</h3>

<p><img src="\lectures\images\typora-user-images\image-20201117233130952.png" alt="image-20201117233130952" style="zoom: 67%;" /></p>

<p>where for <code class="language-plaintext highlighter-rouge">sw</code>:</p>

<ul>
  <li>we are executing <code class="language-plaintext highlighter-rouge">sw $rt, imm($rs)</code></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201117233016706.png" alt="image-20201117233016706" style="zoom: 67%;" /></p>

<p>where:</p>

<ol>
  <li>Assuming this circuit knows that we are doing <code class="language-plaintext highlighter-rouge">sw</code></li>
  <li>Fetch <strong>instruction data</strong> from <strong>Instruction Memory</strong> by address given from <code class="language-plaintext highlighter-rouge">PC</code></li>
  <li>Extract <code class="language-plaintext highlighter-rouge">rs</code>, into <code class="language-plaintext highlighter-rouge">A1</code> of the <strong>Register File</strong>, <strong>Sign Extend</strong> the <code class="language-plaintext highlighter-rouge">imm</code> into 32 bits
    <ul>
      <li>we first compute <code class="language-plaintext highlighter-rouge">imm($rs)</code></li>
    </ul>
  </li>
  <li><strong>Add</strong> the data from <code class="language-plaintext highlighter-rouge">A1</code> and <code class="language-plaintext highlighter-rouge">imm</code>, obtained a computed address</li>
  <li><strong>Use</strong> the above address for knowing <strong>where</strong> to write to in <strong>Data Memory</strong></li>
  <li><strong>Load</strong> data from <code class="language-plaintext highlighter-rouge">$rt</code> to <code class="language-plaintext highlighter-rouge">A2</code> of <strong>Register File</strong>, and write to <code class="language-plaintext highlighter-rouge">WD</code> of <strong>Data Memory</strong>
    <ul>
      <li>now you need to have <code class="language-plaintext highlighter-rouge">write=1</code> enabled for data memory</li>
    </ul>
  </li>
</ol>

<p>Notice:</p>

<ul>
  <li>for <code class="language-plaintext highlighter-rouge">sw</code>, we are writing to memory. So there is <strong>no</strong> change for contents in your register file/no loop back from data to regfile.</li>
</ul>

<h3 id="executing-r-type-instructions">Executing R-Type Instructions</h3>

<p>Imagine the below for an <code class="language-plaintext highlighter-rouge">add</code> instruction:</p>

<p><img src="\lectures\images\typora-user-images\image-20201117233737737.png" alt="image-20201117233737737" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>An example of R-Type would be: <code class="language-plaintext highlighter-rouge">add $rd, $rs, $rt</code></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201117233904678.png" alt="image-20201117233904678" style="zoom: 67%;" /></p>

<p>where:</p>

<ol>
  <li>F</li>
</ol>

<ul>
  <li>the multiplexer comes in because sometimes the addition needs an immediate, but sometimes it comes from a register. So we chose to MUX it.
    <ul>
      <li>however, remember that for <strong>R-types</strong>, you don’t have intermediates, so that MUX will <strong>always</strong> be <code class="language-plaintext highlighter-rouge">0</code>.</li>
    </ul>
  </li>
  <li>also, since R-Type instructions don’t need to talk to the memory at all, we take another MUX such that it <strong>goes back to Register File</strong> for <strong>writing</strong>.
    <ul>
      <li>the <strong>address of register to write</strong> to is contained in the <code class="language-plaintext highlighter-rouge">rd</code> field of R-Type, being the <code class="language-plaintext highlighter-rouge">15:11</code> digits.</li>
    </ul>
  </li>
  <li>lastly, since we don’t have a jump/branch, the clock/next instruction just <strong>increases</strong> by <code class="language-plaintext highlighter-rouge">4</code> as before.</li>
</ul>

<h3 id="executing-beq-instructions">Executing <code class="language-plaintext highlighter-rouge">beq</code> Instructions</h3>

<p><img src="\lectures\images\typora-user-images\image-20201118014343617.png" alt="image-20201118014343617" style="zoom: 80%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">beq $rs, $rt, imm</code>, <code class="language-plaintext highlighter-rouge">imm</code> would be the address</p>
  </li>
  <li>
    <p>Determine whether <code class="language-plaintext highlighter-rouge">rs</code> and <code class="language-plaintext highlighter-rouge">rt</code> are equal, and jump/branch to that address (inside <code class="language-plaintext highlighter-rouge">imm</code>) if true.</p>
  </li>
</ul>

<blockquote>
  <p><strong>Note:</strong></p>

  <ul>
    <li>The <strong>calculation for the next address</strong> is entirely different from <code class="language-plaintext highlighter-rouge">beq</code> and <code class="language-plaintext highlighter-rouge">j</code>
      <ul>
        <li>for <code class="language-plaintext highlighter-rouge">beq</code>, next <code class="language-plaintext highlighter-rouge">PC ← PC + 4 + SignExt18b({imm, 00})</code></li>
        <li>for <code class="language-plaintext highlighter-rouge">j</code>, next <code class="language-plaintext highlighter-rouge">PC ← {(PC + 4)[31:28], address, 00}</code></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><img src="\lectures\images\typora-user-images\image-20201118014300231.png" alt="image-20201118014300231" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>to determine if <code class="language-plaintext highlighter-rouge">rs</code> and <code class="language-plaintext highlighter-rouge">rt</code> are equivalent, we <strong>subtract</strong> them
    <ul>
      <li>this means for later ALU control, it needs to send <code class="language-plaintext highlighter-rouge">110</code> as control signal.</li>
    </ul>
  </li>
  <li>the <code class="language-plaintext highlighter-rouge">beq</code> jump instruction in the above is calculated by <code class="language-plaintext highlighter-rouge">PC ← PC + 4 + SignExt18b({imm, 00})</code>
    <ol>
      <li>first we sign extend <code class="language-plaintext highlighter-rouge">imm</code> the order between this and the next step does not matter)</li>
      <li>then we first shift left by <code class="language-plaintext highlighter-rouge">4</code> bits
        <ul>
          <li>here, <code class="language-plaintext highlighter-rouge">4</code> bits in address means 4 bytes of data
            <ul>
              <li>(remember, 1 bit = 1 memory cell = 1 byte of data)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Add it to the current <code class="language-plaintext highlighter-rouge">PC</code> + <code class="language-plaintext highlighter-rouge">4</code>.</li>
    </ol>
  </li>
  <li>whether or not to branch depends on the result of subtraction. Hence we have a <strong>MUX right before <code class="language-plaintext highlighter-rouge">PC'</code></strong></li>
</ul>

<h3 id="implementing-the-controller">Implementing the Controller</h3>

<p>This is the piece that decides <strong>which components to activate for each instruction</strong>.</p>

<ul>
  <li>remember that all the above instructions executes in 1 cycle</li>
</ul>

<p>Components of the controller include:</p>

<h4 id="single-cycle-controller">Single Cycle Controller</h4>

<p><img src="\lectures\images\typora-user-images\image-20201118015642556.png" alt="image-20201118015642556" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>remember, for certain I-Type and J-Type, ALU decoder don’t need to decide since it will be always adding/subtracting
    <ul>
      <li>e.g. <strong>always add</strong> for <code class="language-plaintext highlighter-rouge">lw</code>/<code class="language-plaintext highlighter-rouge">sw</code> for computing the address with <code class="language-plaintext highlighter-rouge">imm</code></li>
      <li>e.g. <strong>always subtract</strong> for <code class="language-plaintext highlighter-rouge">beq</code> for computing the difference between <code class="language-plaintext highlighter-rouge">$rs</code> and <code class="language-plaintext highlighter-rouge">$rt</code></li>
    </ul>
  </li>
</ul>

<h5 id="main-decoder">Main Decoder</h5>

<p>In short, we need to be able to:</p>

<ul>
  <li><strong>get</strong> the <code class="language-plaintext highlighter-rouge">OP</code> and <code class="language-plaintext highlighter-rouge">FUNC</code> field</li>
  <li><strong>figure out</strong> what to set to control signals such as <code class="language-plaintext highlighter-rouge">WriteEnable</code>, <code class="language-plaintext highlighter-rouge">ALU</code>, etc.</li>
</ul>

<p>Reminder:</p>

<p><img src="\lectures\images\typora-user-images\image-20201118020417263.png" alt="image-20201118020417263" /></p>

<p><strong><em>For R-Types:</em></strong></p>

<p><img src="\lectures\images\typora-user-images\image-20201117235850462.png" alt="image-20201117235850462" style="zoom: 67%;" /></p>

<p><strong><em>For <code class="language-plaintext highlighter-rouge">lw</code></em></strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201118000427655.png" alt="image-20201118000427655" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>The ALU Op in this case basically says to ALU: ignore the <code class="language-plaintext highlighter-rouge">funct</code> field an just <code class="language-plaintext highlighter-rouge">add</code> whatever you get</li>
</ul>

<p><strong><em>For <code class="language-plaintext highlighter-rouge">sw</code></em></strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201120065747554.png" alt="image-20201120065747554" style="zoom:80%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MemToReg</code> is don’t care because we don’t have anything output from memory. as we are just saving a word</li>
</ul>

<p><strong><em>For <code class="language-plaintext highlighter-rouge">beq</code></em></strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201118000843868.png" alt="image-20201118000843868" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">branch</code> control signal would be <code class="language-plaintext highlighter-rouge">1</code>, but whether or not to branch <strong>depends</strong> on the result of subtraction.
    <ul>
      <li>i.e. <strong>not to branch</strong> if <code class="language-plaintext highlighter-rouge">$rs</code> is not equal to <code class="language-plaintext highlighter-rouge">$rt</code></li>
    </ul>
  </li>
</ul>

<h5 id="alu-decoder">ALU Decoder</h5>

<p><img src="\lectures\images\typora-user-images\image-20201118001038195.png" alt="image-20201118001038195" style="zoom: 50%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">00</code> and <code class="language-plaintext highlighter-rouge">01</code> means “ignore the <code class="language-plaintext highlighter-rouge">funct</code> field and do add/subtract”.</li>
  <li>Therefore, <strong>ALU Control</strong> basically <strong>only</strong> <strong>cares</strong> about <code class="language-plaintext highlighter-rouge">func</code> when <strong><code class="language-plaintext highlighter-rouge">ALU OP=10</code></strong></li>
</ul>

<h4 id="extension">Extension:</h4>

<h5 id="support-addiu">Support <code class="language-plaintext highlighter-rouge">addiu</code></h5>

<p><img src="\lectures\images\typora-user-images\image-20201118001152073.png" alt="image-20201118001152073" style="zoom:67%;" /></p>

<h5 id="support-jump">Support <code class="language-plaintext highlighter-rouge">jump</code></h5>

<p><img src="\lectures\images\typora-user-images\image-20201118001237332.png" alt="image-20201118001237332" style="zoom:67%;" /></p>

<h2 id="single-cycle-processor-performance">Single Cycle Processor Performance</h2>

<p>In short, we are measuring <strong>how long do we have to wait</strong> for each program.</p>

<p><img src="\lectures\images\typora-user-images\image-20201118001816195.png" alt="image-20201118001816195" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>$instruction$ refers to the <strong>dynamic instruction count</strong>, which is when it actually <strong>executes</strong>, how many instructions it will have.
    <ul>
      <li>it is different from the number of instruction in the code you write.</li>
    </ul>
  </li>
  <li>Our $CPI$ would be <code class="language-plaintext highlighter-rouge">1</code>, since we take exactly <code class="language-plaintext highlighter-rouge">1</code> clock cycle for each instruction</li>
  <li>Clock period would be the things such as <code class="language-plaintext highlighter-rouge">5.5GHz</code> CPU you see in the market</li>
</ul>

<h3 id="critical-path-and-clock-period">Critical Path and Clock Period</h3>

<p><img src="\lectures\images\typora-user-images\image-20201118001932259.png" alt="image-20201118001932259" style="zoom: 50%;" /></p>

<p>where:</p>

<ul>
  <li>this would be the <strong>MAX</strong> clock period you can have (obviously, you need to wait for propagation delays)</li>
  <li>$t_{mem-I}$ means memory read time for <strong>instructions</strong>, and $t_{mem-D}$ means memory read time for <strong>data</strong>, which in essence are all memory reads.</li>
</ul>

<h3 id="program-execution-time">Program Execution Time</h3>

<p>For the above <strong>single-cycle processor</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201118002108296.png" alt="image-20201118002108296" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>in fact, we could execute it faster if we increase the $\frac{\text{Clock Cycles}}{\text{Instruction}}$ ratio, which means we need to execute more than one instruction per cycle.
    <ul>
      <li>this could be achieved if we use the <strong>pipeline MIPS processor</strong></li>
    </ul>
  </li>
</ul>

<h2 id="pipelined-mips-processor-implementation">Pipelined MIPS Processor Implementation</h2>

<p>This is <strong>another processor</strong> that implements the MIPS ISA, and it uses pipelining to <strong>increase</strong> the $\frac{\text{Clock Cycles}}{\text{Instruction}}$ ratio.</p>

<ul>
  <li>while this would make program execution time shorter, the design is <strong>more complicated</strong></li>
</ul>

<blockquote>
  <p><strong>Intuition:</strong></p>

  <ul>
    <li>
      <p>In short, the single cycle processor has the problem of limiting the clock to the slowest instruction execution (i.e. <code class="language-plaintext highlighter-rouge">lw</code>):</p>

      <p><img src="\lectures\images\typora-user-images\image-20201120070838851.png" alt="image-20201120070838851" style="zoom:50%;" /></p>
    </li>
    <li>
      <p>In fact, this could be solved using the <strong>multi-cycle processor</strong>, such that:</p>

      <ul>
        <li>we break instruction into <strong>smaller components</strong>, and execute them in a cycle</li>
        <li>therefore, we can save time to not execute unneeded instructions</li>
      </ul>

      <p><img src="\lectures\images\typora-user-images\image-20201120071056383.png" alt="image-20201120071056383" style="zoom:50%;" /></p>
    </li>
    <li>
      <p><strong>Pipeline</strong> would work even faster than the above two, by:</p>

      <ul>
        <li>once a <strong>single unit of execution</strong> finished, we <strong>start</strong> executing the <strong>next</strong> instruction</li>
        <li>on the <strong>long run</strong>, we would have <strong>$\approx 1$ instruction done per cycle</strong></li>
        <li>this introduces complexities because we need to manage the dependencies</li>
      </ul>

      <p><img src="\lectures\images\typora-user-images\image-20201120071454998.png" alt="image-20201120071454998" style="zoom:50%;" /></p>

      <p>the analogy of pipeline processor in real life is:</p>

      <p><img src="\lectures\images\typora-user-images\image-20201120072031580.png" alt="image-20201120072031580" style="zoom:33%;" /></p>
    </li>
  </ul>
</blockquote>

<p>In fact, this is exactly what happens in a pipelined processor:</p>

<p><img src="\lectures\images\typora-user-images\image-20201120073416493.png" alt="image-20201120073416493" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p>a <strong>potential hazard</strong> you see would be: what if the first instruction is a <code class="language-plaintext highlighter-rouge">beq</code>? Then we don’t know which address next fetch instruction to take.</p>

    <ul>
      <li>these are also things that we need to manage in our design</li>
    </ul>
  </li>
  <li>
    <p>notice that some components are left-aligned, where some are right-aligned. This is because we cannot read <strong>and</strong> write to regfile at the <strong>same time</strong>:</p>

    <p><img src="\lectures\images\typora-user-images\image-20201120073935060.png" alt="image-20201120073935060" style="zoom:33%;" /></p>
  </li>
</ul>

<h3 id="pipeline-datapath">Pipeline Datapath</h3>

<p><img src="\lectures\images\typora-user-images\image-20201120074157599.png" alt="image-20201120074157599" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>the <strong>highlighted vertical bars</strong> in the pipeline processor are <strong>registers</strong> themselves, such that we can do the <strong>pipelining</strong> in each clock cycle.</li>
  <li><strong>Decode</strong> just means <strong>read data from register file</strong></li>
</ul>

<blockquote>
  <p><strong>Naming for each stage:</strong></p>

  <ul>
    <li>Sometimes we use <strong>acronyms</strong> for each stage:
      <ul>
        <li><code class="language-plaintext highlighter-rouge">Fetch</code>=<code class="language-plaintext highlighter-rouge">F</code></li>
        <li><code class="language-plaintext highlighter-rouge">Decode</code>=<code class="language-plaintext highlighter-rouge">D</code></li>
        <li><code class="language-plaintext highlighter-rouge">Execute</code>=<code class="language-plaintext highlighter-rouge">E</code> or <code class="language-plaintext highlighter-rouge">X</code></li>
        <li><code class="language-plaintext highlighter-rouge">Memory</code>=<code class="language-plaintext highlighter-rouge">M</code></li>
        <li><code class="language-plaintext highlighter-rouge">Writeback</code>=<code class="language-plaintext highlighter-rouge">W</code></li>
      </ul>
    </li>
  </ul>
</blockquote>

<hr />

<p><strong><em>For example</em></strong></p>

<ul>
  <li>
    <p>Consider the <code class="language-plaintext highlighter-rouge">add</code> instruction:</p>

    <p><img src="\lectures\images\typora-user-images\image-20201120074714420.png" alt="image-20201120074714420" style="zoom: 67%;" /></p>

    <p>where:</p>

    <ul>
      <li>this means we would need $5$ <strong>clock cycles</strong> to finish executing <code class="language-plaintext highlighter-rouge">add</code></li>
      <li>for <code class="language-plaintext highlighter-rouge">add</code>, the <code class="language-plaintext highlighter-rouge">Memory</code> stage is optional: since we are not doing anything with memory, we could have skipped it. However, <strong>forcing every instruction</strong> to do the $5$ stages has the <strong>advantage</strong> of:
        <ul>
          <li>making sure at each cycle, <strong>only one instruction completes</strong></li>
          <li>reduces design complexity</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="corrected-datapath">Corrected Datapath</h3>

<p>One error in the above design is the write register operation:</p>

<p><img src="\lectures\images\typora-user-images\image-20201120075652403.png" alt="image-20201120075652403" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">A3</code>, the <strong>register</strong> to write to, comes in <strong>after <code class="language-plaintext highlighter-rouge">Decode</code> stage</strong></li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">WD3</code>, the <strong>data</strong> to write to, comes in <strong>after <code class="language-plaintext highlighter-rouge">Writeback</code> stage</strong></p>
  </li>
  <li>having them <strong>out-of-sync</strong> means you might have data from another instruction written into a register of the next instruction</li>
</ul>

<p>To <strong>fix</strong> this, we simply do:</p>

<p><img src="\lectures\images\typora-user-images\image-20201120080056357.png" alt="image-20201120080056357" style="zoom: 50%;" /></p>

<h3 id="pipeline-control">Pipeline Control</h3>

<p>The idea of control is the same, but the only difference is that we also pipe them into the stage registers:</p>

<p><img src="\lectures\images\typora-user-images\image-20201120080844160.png" alt="image-20201120080844160" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>we <strong>compute</strong> the control signals of an instruction <strong>at once</strong></li>
  <li><strong>pipe</strong> them into the registers</li>
  <li><strong>use</strong> them when needed</li>
</ul>

<blockquote>
  <p><strong>Note:</strong></p>

  <ul>
    <li>The <strong>last character</strong> of the name of control signal corresponds to the <strong>data at different stage</strong>, which will be <strong>different</strong>:
      <ul>
        <li><code class="language-plaintext highlighter-rouge">RegWriteD</code> is the data at the <code class="language-plaintext highlighter-rouge">Decode</code> stage</li>
        <li><code class="language-plaintext highlighter-rouge">RegWriteE</code> is the data at the <code class="language-plaintext highlighter-rouge">Execute</code> stage</li>
        <li><code class="language-plaintext highlighter-rouge">RegwriteM</code> is the data at the <code class="language-plaintext highlighter-rouge">Memory</code> stage</li>
        <li>etc.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="abstraction-for-pipeline-timing">Abstraction for Pipeline Timing</h3>

<p><img src="\lectures\images\typora-user-images\image-20201120081711876.png" alt="image-20201120081711876" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>the <strong>shading</strong> indicates which <strong>resource is in use</strong>
    <ul>
      <li>half shading is shown such that <code class="language-plaintext highlighter-rouge">write</code> to regfile would happen before <code class="language-plaintext highlighter-rouge">read</code></li>
    </ul>
  </li>
  <li>since we have 5 stages, we could <strong>execute 5 “computations “at a time</strong></li>
</ul>

<h2 id="hazards-in-pipelined-processor">Hazards in Pipelined Processor</h2>

<h3 id="data-hazards">Data Hazards</h3>

<p>One problem of the above design is due to the fact that we <strong>Writeback</strong> to register file in the final step. This means if we do:</p>

<p><img src="\lectures\images\typora-user-images\image-20201120082041027.png" alt="image-20201120082041027" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>doing <code class="language-plaintext highlighter-rouge">add</code> means <code class="language-plaintext highlighter-rouge">$s0</code> will only get <strong>updated</strong> in the <strong>fifth cycle</strong></li>
  <li>but <code class="language-plaintext highlighter-rouge">and</code> needs to <strong>read</strong> the computed <code class="language-plaintext highlighter-rouge">$s0</code> on the <strong>third cycle</strong></li>
</ul>

<p>In fact, both <code class="language-plaintext highlighter-rouge">and</code> and <code class="language-plaintext highlighter-rouge">or</code> would not work:</p>

<p><img src="\lectures\images\typora-user-images\image-20201120082141163.png" alt="image-20201120082141163" style="zoom:50%;" /></p>

<h4 id="remedies-for-data-hazards">Remedies for Data Hazards</h4>

<p>One approach is to simply insert <code class="language-plaintext highlighter-rouge">nop</code> commands:</p>

<p><img src="\lectures\images\typora-user-images\image-20201120082400454.png" alt="image-20201120082400454" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>we therefore <strong>force the spacing</strong> between instructions to be correct</li>
  <li>but this causes a <strong>lower</strong> processor performance</li>
</ul>

<p>The preferred approach is called <strong>forwarding/bypassing</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201120082826402.png" alt="image-20201120082826402" style="zoom: 50%;" /></p>

<p>where:</p>

<ul>
  <li>the idea is that we <strong>insert the correct value in manually</strong>, since the computation of the data is always one cycle earlier</li>
  <li>the only problem for implementing would be to know exactly <strong>which register</strong> is having the <code class="language-plaintext highlighter-rouge">r/w</code> conflict
    <ul>
      <li>in fact, we do this by <strong>only</strong> checking the data on the <strong>memory stage and the writeback stage</strong></li>
    </ul>
  </li>
</ul>

<h4 id="implementation-of-forwardingbypassing">Implementation of Forwarding/Bypassing</h4>

<p>Since the data hazard only happens when data is ready in stage 3 but not written in stage 4 or 5, we just need to check</p>

<ul>
  <li>data on stage 4=<code class="language-plaintext highlighter-rouge">Memory</code></li>
  <li>data on stage 5=<code class="language-plaintext highlighter-rouge">Writeback</code></li>
  <li>unless you are doing <code class="language-plaintext highlighter-rouge">lw</code>, whose data would only be there on stage 5.
    <ul>
      <li>this will be address in the section <a href="#`lw` Data Hazards"><code class="language-plaintext highlighter-rouge">lw</code> Data Hazards</a></li>
    </ul>
  </li>
</ul>

<p>Therefore, the data <strong>after the read from register file</strong> could come from:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">00</code> normal case, data from register file</li>
  <li><code class="language-plaintext highlighter-rouge">01</code> forwarding case, data from <code class="language-plaintext highlighter-rouge">Memory</code> stage</li>
  <li><code class="language-plaintext highlighter-rouge">10</code> forwarding cases, data from <code class="language-plaintext highlighter-rouge">Writeback</code> stage</li>
</ol>

<p><img src="\lectures\images\typora-user-images\image-20201120084458456.png" alt="image-20201120084458456" style="zoom:50%;" /></p>

<p>And the control signals in total would <strong>need information</strong> from:</p>

<ul>
  <li>which register in regfile is being <strong>read</strong> (potentially causing hazard)</li>
  <li>which register in regfile is being <strong>written</strong> to
    <ul>
      <li>in <code class="language-plaintext highlighter-rouge">Memory</code> stage</li>
      <li>in <code class="language-plaintext highlighter-rouge">Writeback</code> stage</li>
      <li>remember we also need to know if we are <strong>actually writing</strong> to a register, hence need <code class="language-plaintext highlighter-rouge">RegWrite</code> control signal as well</li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201120084638810.png" alt="image-20201120084638810" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">10</code> means $\text{register read is none zero } \&amp; \text{ register read == register written at Memory stage } \&amp; \text{ register actually written in Memory}$</li>
  <li><code class="language-plaintext highlighter-rouge">01</code> means $\text{register read is none zero } \&amp; \text{ register read == register written at Writeback stage } \&amp; \text{ register actually written in Writeback}$</li>
  <li><code class="language-plaintext highlighter-rouge">00</code> otherwise</li>
</ul>

<h4 id="lw-data-hazards"><code class="language-plaintext highlighter-rouge">lw</code> Data Hazards</h4>

<p>The above work assuming data being ready at both <code class="language-plaintext highlighter-rouge">Memory</code> stage and <code class="language-plaintext highlighter-rouge">Writeback</code> stage, but there is one exception: <code class="language-plaintext highlighter-rouge">lw</code></p>

<ul>
  <li>now, since <code class="language-plaintext highlighter-rouge">lw</code> <strong>only has data ready</strong> at the last cycle, this means we cannot prepare the data for the next instruction</li>
  <li>therefore, we have <strong>no choice</strong> but to <strong>stall</strong>
    <ul>
      <li>or inserting <code class="language-plaintext highlighter-rouge">nop</code>, at this point it is equivalent</li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201120090155810.png" alt="image-20201120090155810" style="zoom:50%;" /></p>

<h4 id="implementation-of-stalling">Implementation of Stalling</h4>

<p>Basically, we place a “<strong>bubble</strong>” in between the <code class="language-plaintext highlighter-rouge">lw</code> and the <code class="language-plaintext highlighter-rouge">and</code> instruction in the above example.</p>

<ul>
  <li>it is essentially the <strong><em>same as we delay the instruction by one <code class="language-plaintext highlighter-rouge">nop</code></em></strong></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201124232624511.png" alt="image-20201124232624511" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>basically, instead of just doing nothing, we <strong>repeat</strong> what has been done at the previous stage.
    <ul>
      <li>just <strong><em>imagine sticking in a <code class="language-plaintext highlighter-rouge">nop</code> between <code class="language-plaintext highlighter-rouge">lw</code> and <code class="language-plaintext highlighter-rouge">and</code>,</em></strong> so that the rest of the instructions flow correctly</li>
    </ul>
  </li>
  <li>the <strong>net result</strong> is that each <strong>instruction after <code class="language-plaintext highlighter-rouge">lw</code> is delayed</strong> for one stage. This is visibly seen for the instruction <code class="language-plaintext highlighter-rouge">sub</code>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">sub</code> starts on cycle <code class="language-plaintext highlighter-rouge">4</code> on the diagram for section <a href="#`lw` Data Hazards"><code class="language-plaintext highlighter-rouge">lw</code> Data Hazards</a></li>
      <li><code class="language-plaintext highlighter-rouge">sub</code> starts on cycle <code class="language-plaintext highlighter-rouge">5</code> after the fix</li>
    </ul>
  </li>
</ul>

<p><strong>Remember,</strong> for <code class="language-plaintext highlighter-rouge">lw</code> hazard, we have need to check:</p>

<ul>
  <li>whether if the <strong>next</strong> instruction <strong>reads data</strong> (<code class="language-plaintext highlighter-rouge">rs</code> or <code class="language-plaintext highlighter-rouge">rt</code>) from the <strong>register <code class="language-plaintext highlighter-rouge">lw</code> is writing to <code class="language-plaintext highlighter-rouge">rt</code></strong></li>
</ul>

<blockquote>
  <p><strong>Recall that:</strong></p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">lw $rt, offset($rs)</code></li>
    <li><code class="language-plaintext highlighter-rouge">add $rd, $rs, $rt</code></li>
  </ul>
</blockquote>

<p><strong>To implement it, we have:</strong></p>

<p><img src="\lectures\images\typora-user-images\image-20201124233245849.png" alt="image-20201124233245849" style="zoom: 80%;" /></p>

<p>where:</p>

<ul>
  <li>essentially we check:
    <ul>
      <li>$\text{Actually Writing from Memory to RegFile &amp;&amp; (Register Read by Next instruction==Register Written To)}$</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>and since we have two possible register to read from: $\text{(Register Read by Next instruction==Register Written To)=(rs at Decode/Read==rt writing to)</td>
              <td> </td>
              <td>(rt at Decode/Read==rt writing to)}$</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>
    <p>if we have a <code class="language-plaintext highlighter-rouge">lw</code>, then we have a <code class="language-plaintext highlighter-rouge">MemToRegE=1</code>.</p>
  </li>
  <li>since we need to <strong>stall</strong> the <strong>next two instructions</strong> (to be equivalent of inserting a <code class="language-plaintext highlighter-rouge">nop</code>), we need to have:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">StallD</code> to stall/redo the same decode stage (by letting the <code class="language-plaintext highlighter-rouge">D</code> <strong>clock</strong> not advance)</li>
      <li><code class="language-plaintext highlighter-rouge">StallF</code> to stall/redo the same fetch stage (by letting the <code class="language-plaintext highlighter-rouge">F</code> <strong>clock</strong> not advance)</li>
      <li><code class="language-plaintext highlighter-rouge">FlushE</code> means make the data in the register all <code class="language-plaintext highlighter-rouge">0</code>.
        <ul>
          <li>This signifies a <code class="language-plaintext highlighter-rouge">nop</code>, since essentially, all <code class="language-plaintext highlighter-rouge">Execute</code> (ALU calculation) <strong>starting from the stall</strong> pushed forward for one stage, meaning there is <strong>no calculation</strong> going on at this cycle</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="week-12">Week 12</h1>

<h2 id="hazards-in-pipelined-processor-continued">Hazards in Pipelined Processor (Continued)</h2>

<h3 id="control-hazards">Control Hazards</h3>

<p>The problem comes from <strong>branching</strong>:</p>

<ul>
  <li>in short, we <strong>cannot determine</strong> whether of not to branch before the <strong>beginning of cycle 4</strong></li>
  <li>as a result, we might need to <strong>flush/”undo” next three instructions</strong></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201125013008262.png" alt="image-20201125013008262" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>remember to know if we are branching (<code class="language-plaintext highlighter-rouge">beq</code>), we do two things:
    <ul>
      <li>do the <strong>subtraction</strong> to see if <code class="language-plaintext highlighter-rouge">rs</code> and <code class="language-plaintext highlighter-rouge">rt</code> are equal</li>
      <li>if we are branching, <strong>control signal</strong> of <code class="language-plaintext highlighter-rouge">branch=1</code></li>
    </ul>
  </li>
</ul>

<h4 id="early-branch-resolution">Early Branch Resolution</h4>

<p>Instead of flushing all three next instructions, we could:</p>

<ul>
  <li><strong>determine</strong> the branching in <strong><code class="language-plaintext highlighter-rouge">Decode</code> stage</strong></li>
  <li>then you would only need to <strong>flush one instruction</strong></li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201124234836906.png" alt="image-20201124234836906" style="zoom:67%;" /></p>

<p>To <strong>determine branching in the decode stage</strong>, we need to <strong>change our processor</strong> a bit:</p>

<p><img src="\lectures\images\typora-user-images\image-20201125013254681.png" alt="image-20201125013254681" /></p>

<p>where:</p>

<ul>
  <li>while this would work, we have <strong>additional data hazards</strong>
    <ul>
      <li>remember, what if <strong>data read from register (stage 2)</strong> was being written by the <strong>previous instruction (stage5)</strong></li>
      <li>for example, consider the worst case of first <code class="language-plaintext highlighter-rouge">lw</code> (updating <strong><em>only on</em></strong> <strong>cycle 5</strong>), then <code class="language-plaintext highlighter-rouge">beq</code> for the same register (reading at <strong>cycle 3</strong>)
        <ul>
          <li>hints at the need of <strong>stalling twice</strong> to get the data ready if we have <code class="language-plaintext highlighter-rouge">lw</code> then <code class="language-plaintext highlighter-rouge">beq</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="handling-data-hazards-in-early-branch-resolution">Handling Data Hazards in Early Branch Resolution</h4>

<p>In short, we forward/bypass again.</p>

<ul>
  <li>Before, we implemented forward/bypass to:
    <ul>
      <li>get correct data to <code class="language-plaintext highlighter-rouge">Execute</code> (<code class="language-plaintext highlighter-rouge">i+1</code>th instruction) from <code class="language-plaintext highlighter-rouge">Memory</code> (<code class="language-plaintext highlighter-rouge">i</code>th instruction)</li>
      <li>get correct data to <code class="language-plaintext highlighter-rouge">Execute</code> (<code class="language-plaintext highlighter-rouge">i+2</code>th instruction) from <code class="language-plaintext highlighter-rouge">Writeback</code> (<code class="language-plaintext highlighter-rouge">i</code>th instruction)</li>
    </ul>
  </li>
  <li>Now, we need to also forward/bypass to:
    <ul>
      <li>get correct data <strong>to <code class="language-plaintext highlighter-rouge">Decode</code></strong> (<code class="language-plaintext highlighter-rouge">i+1</code> instruction after stall=<code class="language-plaintext highlighter-rouge">i+2</code> instruction) <strong>from <code class="language-plaintext highlighter-rouge">Memory</code></strong> (<code class="language-plaintext highlighter-rouge">i</code>th instruction)
        <ul>
          <li>i.e. from <strong>beginning of <code class="language-plaintext highlighter-rouge">memory</code> to late stage of <code class="language-plaintext highlighter-rouge">execute</code></strong></li>
        </ul>
      </li>
      <li>we <strong>don’t</strong> need <code class="language-plaintext highlighter-rouge">W-D</code> forwarding, because, remember, <strong><code class="language-plaintext highlighter-rouge">W</code> (write) happens before <code class="language-plaintext highlighter-rouge">D</code> (read)!</strong></li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201124235034034.png" alt="image-20201124235034034" style="zoom:80%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p>Therefore, to check <code class="language-plaintext highlighter-rouge">Memory</code> and <code class="language-plaintext highlighter-rouge">Decode</code> stage, we check:</p>

    <p><img src="\lectures\images\typora-user-images\image-20201125020743896.png" alt="image-20201125020743896" style="zoom:67%;" /></p>

    <ul>
      <li>if <strong>register read <code class="language-plaintext highlighter-rouge">rs</code> at <code class="language-plaintext highlighter-rouge">D</code> stage</strong> is the same as <strong>register written at <code class="language-plaintext highlighter-rouge">M</code> stage</strong>, then we forward</li>
      <li>if <strong>register read <code class="language-plaintext highlighter-rouge">rd</code> at <code class="language-plaintext highlighter-rouge">D</code> stage</strong> is the same as <strong>register written at <code class="language-plaintext highlighter-rouge">M</code> stage</strong>, then we forward</li>
    </ul>
  </li>
</ul>

<p><strong>However, we also need to deal with the problem that:</strong></p>

<ul>
  <li>
    <p>since <code class="language-plaintext highlighter-rouge">beq</code> needs data in register at <code class="language-plaintext highlighter-rouge">Decode</code> stage, we need to check:</p>

    <p><img src="\lectures\images\typora-user-images\image-20201125025758083.png" alt="image-20201125025758083" style="zoom:67%;" /></p>

    <ul>
      <li>if <strong><code class="language-plaintext highlighter-rouge">beq</code></strong> reads <strong>data from <code class="language-plaintext highlighter-rouge">rs/rt</code> at <code class="language-plaintext highlighter-rouge">D</code> stage</strong>, and that data <strong>would</strong> be the <strong>ALU calculated data from <code class="language-plaintext highlighter-rouge">E</code> stage</strong> (of previous instruction)
        <ul>
          <li>e.g. <code class="language-plaintext highlighter-rouge">add</code> followed by <code class="language-plaintext highlighter-rouge">beq</code></li>
        </ul>
      </li>
      <li>if <strong><code class="language-plaintext highlighter-rouge">beq</code></strong> reads <strong>data from <code class="language-plaintext highlighter-rouge">rs/rt</code> at <code class="language-plaintext highlighter-rouge">D</code> stage</strong>, and that data <strong>would</strong> be the <strong>data read from Memory at <code class="language-plaintext highlighter-rouge">M</code> stage</strong> (of previous instruction)</li>
      <li>e.g. <code class="language-plaintext highlighter-rouge">lw</code> followed by <code class="language-plaintext highlighter-rouge">beq</code></li>
    </ul>
  </li>
</ul>

<p><strong>Therefore, the total stall condition would be</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201125025826679.png" alt="image-20201125025826679" style="zoom: 67%;" /></p>

<ul>
  <li>technically <strong><code class="language-plaintext highlighter-rouge">FlushE</code></strong> has the <strong>extra condition of <code class="language-plaintext highlighter-rouge">PCSrcD=1</code></strong>. Because if we have decided to branch, then we need to <strong>flush the next instruction</strong> as well.</li>
</ul>

<blockquote>
  <p><strong>In general, we see that those problem happen because</strong>:</p>

  <ul>
    <li>we have a <strong>eager consumer</strong> e.g. <code class="language-plaintext highlighter-rouge">beq</code></li>
    <li>we have a <strong>later producer</strong> e.g. <code class="language-plaintext highlighter-rouge">lw</code></li>
  </ul>
</blockquote>

<h4 id="fully-bypassed-processor">Fully Bypassed Processor</h4>

<p><img src="\lectures\images\typora-user-images\image-20201124235547114.png" alt="image-20201124235547114" /></p>

<h3 id="stallbypass-summary-for-data-hazards">Stall/Bypass Summary for Data Hazards</h3>

<p><img src="\lectures\images\typora-user-images\image-20201125000311098.png" alt="image-20201125000311098" style="zoom: 50%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">other</code> include instructions such as <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">sub</code>, etc
    <ul>
      <li>then normal forwarding would suffice (without <code class="language-plaintext highlighter-rouge">stall</code>)</li>
    </ul>
  </li>
  <li>once we have a <code class="language-plaintext highlighter-rouge">beq</code>, the previous instruction needs to be <strong>stalled</strong> (if <code class="language-plaintext highlighter-rouge">beq</code> consumes it)
    <ul>
      <li>because <code class="language-plaintext highlighter-rouge">beq</code> needs data at late <code class="language-plaintext highlighter-rouge">Decode</code> stage, so we need data to be prepared from the <strong>previous instruction</strong> at latest at <strong>start of <code class="language-plaintext highlighter-rouge">Decode</code> stage</strong>
        <ul>
          <li>remember, we can only forward at the <strong>start</strong> of <code class="language-plaintext highlighter-rouge">Decode/Execute/...</code> due to our <strong>implementation</strong>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>additionally, for <code class="language-plaintext highlighter-rouge">beq</code>, we will often <strong>flush</strong> the next instruction (if <code class="language-plaintext highlighter-rouge">beq</code> is <code class="language-plaintext highlighter-rouge">True</code> and we need to branch)
    <ul>
      <li>because we cannot figure out whether or not to branch in time for <strong><code class="language-plaintext highlighter-rouge">Fetch</code> stage of next instruction</strong>. Therefore, if it turns out we need to branch, we need to discard the one instruction we have just computed</li>
      <li>since <code class="language-plaintext highlighter-rouge">Decode</code> stage and <code class="language-plaintext highlighter-rouge">Fetch</code> stage <strong><em>only has 1 stage difference</em></strong></li>
    </ul>
  </li>
  <li>once we have a <code class="language-plaintext highlighter-rouge">lw</code>, the next instruction needs to be <strong>stalled</strong> (if the next instructions consumes it)
    <ul>
      <li>because data from <code class="language-plaintext highlighter-rouge">lw</code> cannot be <strong>ready for <code class="language-plaintext highlighter-rouge">Execute</code> stage</strong> of next instruction</li>
      <li>since <code class="language-plaintext highlighter-rouge">Execute</code> stage and <code class="language-plaintext highlighter-rouge">Memory</code> stage <strong><em>only has 1 stage difference</em></strong></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">bubble</code> means a <strong>single stall</strong></li>
</ul>

<blockquote>
  <p><strong>The twice stall comes from:</strong></p>

  <ul>
    <li>If you have <code class="language-plaintext highlighter-rouge">lw $s0 ...</code>, then <code class="language-plaintext highlighter-rouge">beq $s0 ...</code>, but <strong>stalled only once</strong>:</li>
  </ul>

  <p><img src="\lectures\images\typora-user-images\image-20201125022213958.png" alt="image-20201125022213958" style="zoom:67%;" /></p>

  <ul>
    <li>since the forwarding is <strong>in this case only</strong> at early stage of <code class="language-plaintext highlighter-rouge">Writeback</code> (no forwarding at late <code class="language-plaintext highlighter-rouge">Memory</code>), we need to <strong>stall twice</strong>.</li>
  </ul>
</blockquote>

<h2 id="pipelined-processor-performance">Pipelined Processor Performance</h2>

<p>First, we consider how our CPI has changed.</p>

<p>The ideal CPI would be 1, but since we have <strong>stall</strong>, what would be our CPI now?</p>

<p><strong>On average in real life,</strong> we have the following <strong>dynamic instructions per program</strong>:</p>

<ul>
  <li>$54\%$ <code class="language-plaintext highlighter-rouge">R-Type</code></li>
  <li>$25\%$ <code class="language-plaintext highlighter-rouge">load</code></li>
  <li>$10\%$ <code class="language-plaintext highlighter-rouge">store</code></li>
  <li>$11\%$ <code class="language-plaintext highlighter-rouge">branch</code></li>
</ul>

<p>If we have $40\%$ of the loads used immediately  by the next instruction, and $25\%$ of branches being taken (actually jumped), then the <strong>average</strong> CPI would be:</p>

<p><img src="\lectures\images\typora-user-images\image-20201125001302693.png" alt="image-20201125001302693" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>one <strong>ignored</strong> calculation was the scenario of having <strong><code class="language-plaintext highlighter-rouge">lw</code> and then immediately <code class="language-plaintext highlighter-rouge">beq</code></strong>, which would have <strong>two stalls</strong>: <code class="language-plaintext highlighter-rouge">CPI=3</code></li>
</ul>

<p>and the average CPI would be the <strong>weighted sum of the above</strong>:
\(\text{Overall CPI}=0.54*1.0 +0.25*1.4+0.10*1.0+0.11*1.25=1.13\)</p>

<h3 id="pipelined-processor-critical-path">Pipelined Processor Critical Path</h3>

<p>For pipelined processor, we just need to think about the <strong>longest computation time of each <em>stage</em></strong>.</p>

<p><img src="\lectures\images\typora-user-images\image-20201125002055006.png" alt="image-20201125002055006" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>the factor of $2$ for <code class="language-plaintext highlighter-rouge">Decode</code> and <code class="language-plaintext highlighter-rouge">WriteBack</code> will be <strong>useful</strong> (but sometimes not necessary) for <strong>avoiding more hazards</strong>, because we needed to <strong>read</strong> from register <strong><em>after</em></strong> <strong>writing</strong> to register.
    <ul>
      <li>this implementation usually won’t take up much time, but for a <strong>safe estimation</strong>, we use a factor of $2$</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Extension:</strong></p>

  <ul>
    <li>
      <p>In fact, one implementation to achieve the <strong>read after write</strong> would be:</p>

      <ul>
        <li>
          <p>if <strong>register</strong> I am <strong>reading</strong> is the <strong>same</strong> as <strong>register</strong> I am <strong>writing</strong>, then I <strong>output data from <code class="language-plaintext highlighter-rouge">WD3</code></strong> directly instead of register</p>

          <p><img src="\lectures\images\typora-user-images\image-20201125003702342.png" alt="image-20201125003702342" style="zoom:50%;" /></p>

          <p>where:</p>

          <ul>
            <li>this would be implemented inside the register file, and in fact, it will probably not need $2 \times$ the time of <code class="language-plaintext highlighter-rouge">Decode</code>/<code class="language-plaintext highlighter-rouge">Writeback</code> stage.</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="pipelined-performance-calculation">Pipelined Performance Calculation</h3>

<p><img src="\lectures\images\typora-user-images\image-20201125002649852.png" alt="image-20201125002649852" style="zoom:67%;" /></p>

<h2 id="pipelined-speedup">Pipelined Speedup</h2>

<p>Now, we can <strong>compare</strong> the relative performances of <strong>different processors</strong>.</p>

<ul>
  <li><strong>Speedup:</strong> a measure of relative performance
\(\text{Speedup} = \frac{\text{Runtime Baseline}}{\text{Runtime Optimized}}\)</li>
</ul>

<p><strong><em>For example:</em></strong></p>

<p><img src="\lectures\images\typora-user-images\image-20201125030013900.png" alt="image-20201125030013900" style="zoom:67%;" /></p>

<h1 id="week-13">Week 13</h1>

<h2 id="caches">Caches</h2>

<p>This is another way of optimizing our processor.</p>

<p>In short, the problem comes as the <strong>performance of memory</strong> might be sub-optimal.</p>

<ul>
  <li>
    <p>for example, it often happens that, since <strong>memory is large</strong>, we sometimes need <strong>100 clock cycles</strong> to read a data, rather than 1.</p>

    <ul>
      <li>remember, the design of memory is separate from our CPU: we use them like an Interface</li>
    </ul>

    <p><img src="\lectures\images\typora-user-images\image-20201201231831075.png" alt="image-20201201231831075" style="zoom:50%;" /></p>
  </li>
</ul>

<blockquote>
  <p><strong>As a result:</strong></p>

  <ul>
    <li>
      <p>The <strong>clock speed/performance</strong> of instruction and data <strong>memory</strong> will <strong><em>limit</em> the performance of our CPU</strong>.</p>
    </li>
    <li>
      <p>In fact, the gap between the performance can be shown below:</p>

      <ul>
        <li>where the term “<strong>memory wall</strong>” means that the performance your CPU will be upper bounded by the performance of that memory</li>
      </ul>

      <p><img src="\lectures\images\typora-user-images\image-20201201232222455.png" alt="image-20201201232222455" style="zoom: 67%;" /></p>
    </li>
  </ul>
</blockquote>

<p>Therefore, <strong>caches</strong> are used to improve the performance, for many cases (but not all).</p>

<h3 id="memory-technologies">Memory Technologies</h3>

<p>It turns out that our memory design can only satisfy <strong>two</strong> of the three below:</p>

<p><img src="\lectures\images\typora-user-images\image-20201201232541652.png" alt="image-20201201232541652" style="zoom: 67%;" /></p>

<h4 id="memory-hierachy">Memory Hierachy</h4>

<p>The idea is that:</p>

<ul>
  <li>we can <strong>combine</strong> some small capacity but fast memories, with some large but slow memories, and …</li>
  <li>and to find a data, we check
    <ul>
      <li>first our Cache (<code class="language-plaintext highlighter-rouge">SRAM</code>)</li>
      <li>then our Memory (<code class="language-plaintext highlighter-rouge">DRAM</code>)</li>
      <li>finally, our Disk</li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201201233229162.png" alt="image-20201201233229162" style="zoom: 50%;" /></p>

<p>where:</p>

<ul>
  <li><strong>density</strong> means number of giga bits we can store per <code class="language-plaintext highlighter-rouge">cm2</code></li>
</ul>

<blockquote>
  <p><strong>Note:</strong></p>

  <ul>
    <li>Both <code class="language-plaintext highlighter-rouge">SRAM</code> and <code class="language-plaintext highlighter-rouge">DRAM</code> are fast, but volatile.
      <ul>
        <li>this means once we unplug the power, data there is gone.</li>
      </ul>
    </li>
    <li>For computers in real life:
      <ul>
        <li><code class="language-plaintext highlighter-rouge">RAM</code> usually refers to <code class="language-plaintext highlighter-rouge">DRAM</code></li>
        <li><code class="language-plaintext highlighter-rouge">L1-3 Cache</code> usually refers to <code class="language-plaintext highlighter-rouge">SRAM</code></li>
      </ul>
    </li>
  </ul>
</blockquote>

<hr />

<p><strong><em>For example:</em></strong></p>

<p><img src="\lectures\images\typora-user-images\image-20201201233823781.png" alt="image-20201201233823781" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>the entire thing is only <strong>caches</strong></li>
  <li>the bottom part will be the <code class="language-plaintext highlighter-rouge">L3 Cache</code></li>
</ul>

<hr />

<h3 id="deciding-what-to-cache">Deciding What to Cache</h3>

<p><strong><em>For example:</em></strong></p>

<ul>
  <li>Consider the program to find the substring <code class="language-plaintext highlighter-rouge">hip</code> in the string below</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201201234908406.png" alt="image-20201201234908406" style="zoom:67%;" /></p>

<ul>
  <li>It turns out that commonly:
    <ul>
      <li><strong>temporal locality</strong>: data <code class="language-plaintext highlighter-rouge">X</code> used <strong>recently</strong> are likely to be used again
        <ul>
          <li>cache data that are used recently</li>
        </ul>
      </li>
      <li><strong>spatial locality</strong>: if data <code class="language-plaintext highlighter-rouge">X</code> is used, then <strong>data near</strong> <code class="language-plaintext highlighter-rouge">X</code> in terms of memory address are likely to be used again
        <ul>
          <li>cache data that are near the data you touched</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="caches-exploit-locality">Caches Exploit Locality</h4>

<p>Since cache is small:</p>

<ul>
  <li>Temporal Locality:
    <ul>
      <li>copy newly accessed data</li>
    </ul>
  </li>
  <li>Spatial Locality</li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>the above is just the average case. You could perfectly come up with a program that has nothing to do with temporal and spatial locality.</li>
  </ul>
</blockquote>

<h3 id="caching-technology">Caching Technology</h3>

<p>Caches make up the highest level of memory hierarchy</p>

<ul>
  <li>caches are typically as fast as one clock cycle</li>
  <li>with luck (if data needed is in the cache), then performance is fast</li>
</ul>

<p>Therefore, we would want to:</p>

<ul>
  <li><strong>design our cache such that it can supply most of our data needed</strong></li>
</ul>

<p><strong>Questions</strong> to think about is:</p>

<ul>
  <li>What data should cache hold?
    <ul>
      <li>recently accessed, based on space+temporal locality</li>
    </ul>
  </li>
  <li>How should that data is found?
    <ul>
      <li>using address “hash” (address as key)</li>
    </ul>
  </li>
  <li>What data in cache should be replaced when cache is full?
    <ul>
      <li>least recently used data should be replaced</li>
    </ul>
  </li>
</ul>

<h4 id="cache-performance">Cache Performance</h4>

<ul>
  <li><strong>Hit</strong> - Data is found in the level of memory hierarchy</li>
  <li><strong>Miss</strong> - Data not found, need to look in next level</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201202000333953.png" alt="image-20201202000333953" style="zoom:67%;" /></p>

<ul>
  <li>
    <p><strong>Expected Access Time</strong> $E_{L}$ for a memory level $L$ with latency $t_L$ and <strong>miss</strong> rate $M_L$ is:
\(E_L = t_L + M_L \cdot E_{L+1}\)
where:</p>

    <ul>
      <li>$t_L$ of the current level refers to the time needed to <strong>check whether if data is here</strong></li>
    </ul>
  </li>
</ul>

<p><strong><em>For example:</em></strong></p>

<ul>
  <li>
    <p><strong>Question:</strong></p>

    <p><img src="\lectures\images\typora-user-images\image-20201202000724578.png" alt="image-20201202000724578" style="zoom: 50%;" /></p>

    <p><img src="\lectures\images\typora-user-images\image-20201202000813419.png" alt="image-20201202000813419" style="zoom:50%;" /></p>
  </li>
  <li>
    <p><strong>Solution:</strong></p>

    <p>First, the hit rate is simple:
\(Hit = \frac{750}{1000} = 0.75\)
then we know that the miss rate is $M_L = 0.25$, hence:
\(E_L = 1.00 * 1+0.25*100 = 26\)
where:</p>

    <ul>
      <li>$1.00$ comes from the fact that, no matter where you look at, you will <strong><em>always</em> look at/start from the top memory level</strong></li>
    </ul>
  </li>
</ul>

<h3 id="direct-mapped-cache">Direct-Mapped Cache</h3>

<p>This is the simplest design of a cache:</p>

<ul>
  <li>for each address in main memory, there will be exactly only one location to store that data</li>
  <li>therefore, there will be collisions</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201202001343683.png" alt="image-20201202001343683" style="zoom: 67%;" /></p>

<blockquote>
  <p><strong>Note:</strong></p>

  <ul>
    <li>Since we are mapping 32 bits to 3 bits “hash”, we need to also <strong>store other bit of the address as well</strong>.</li>
  </ul>
</blockquote>

<h4 id="direct-mapped-cache-implementation">Direct-Mapped Cache Implementation</h4>

<p><img src="\lectures\images\typora-user-images\image-20201202002037120.png" alt="image-20201202002037120" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">tag</code> is basically used to store the <strong>remaining of the addresses</strong></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">V</code> is the <strong>valid</strong> bit, telling you if the <strong>data there is valid</strong> before even checking the address <code class="language-plaintext highlighter-rouge">tag</code></p>
  </li>
  <li>
    <p><strong>a row</strong> in the cache above is called a <strong>set</strong></p>

    <ul>
      <li>for example, we have 8 sets above, indexed from 0-7</li>
    </ul>
  </li>
  <li>
    <p><strong>a column</strong> in the cache above is called a <strong>way</strong></p>

    <ul>
      <li>
        <p>basically, how many “caches” there are in series</p>
      </li>
      <li>
        <p>for example, the cache below has <strong>2 ways</strong> and 6 sets:</p>

        <p><img src="\lectures\images\typora-user-images\image-20201204015331266.png" alt="image-20201204015331266" style="zoom: 67%;" /></p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="direct-mapped-cache-behavior">Direct-Mapped Cache Behavior</h4>

<p>For example:</p>

<ul>
  <li>
    <p>Consider the program:</p>

    <p><img src="\lectures\images\typora-user-images\image-20201202020756622.png" alt="image-20201202020756622" style="zoom: 67%;" /></p>

    <p>the <code class="language-plaintext highlighter-rouge">lw</code> <strong>reads from Memory, hence this is where cache comes in</strong></p>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201202021310097.png" alt="image-20201202021310097" style="zoom: 67%;" /></p>

<blockquote>
  <p><strong>Note that</strong>:</p>

  <ul>
    <li>if you are doing <strong>operations</strong> that only involve <strong>registers in regfile</strong>, you <strong>don’t need to cache</strong>, obviously, as that is part of the CPU.</li>
  </ul>
</blockquote>

<ul>
  <li>Since it started empty, we will miss the first three accesses, but the remaining are going to be hit</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201202002719633.png" alt="image-20201202002719633" style="zoom:50%;" /></p>

<ul>
  <li>where:
    <ul>
      <li>the miss rate would be $\frac{3}{15}$ (assuming only <strong>temporal</strong> locality)</li>
    </ul>
  </li>
</ul>

<h4 id="direct-mapped-cache-conflict-misses">Direct-Mapped Cache Conflict Misses</h4>

<p>Now, consider the program:</p>

<p><img src="\lectures\images\typora-user-images\image-20201204021803717.png" alt="image-20201204021803717" style="zoom:50%;" /></p>

<p>however, notice the address <code class="language-plaintext highlighter-rouge">lw</code> used from <strong>memory</strong> are:</p>

<p><img src="\lectures\images\typora-user-images\image-20201204021936003.png" alt="image-20201204021936003" style="zoom:50%;" /></p>

<p><strong>As a result</strong>, you will be repeatedly accessing the same set in the cache:</p>

<p>After first iteration:</p>

<p><img src="\lectures\images\typora-user-images\image-20201204022034525.png" alt="image-20201204022034525" style="zoom: 50%;" /></p>

<p>After second iteration:</p>

<p><img src="\lectures\images\typora-user-images\image-20201204022135302.png" alt="image-20201204022135302" style="zoom:50%;" /></p>

<p>Therefore, the <strong>trend is that</strong>, for our <strong>memory accesses</strong>:</p>

<p><img src="\lectures\images\typora-user-images\image-20201204022246693.png" alt="image-20201204022246693" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p>the problem can be thought as each set is “a queue”, here, it will be 8 queues each of <strong>size 1</strong> only</p>
  </li>
  <li>
    <p>this could be improved if we use a 2-way set associative cache/fully associative cache</p>
    <ul>
      <li>so that you have 4 queues each of size 2, or 1 queue of size 8, <strong>preventing this problem</strong></li>
      <li>but on average, the performance would be the same, as you increases the probability of colliding</li>
    </ul>
  </li>
</ul>

<h3 id="general-schema-for-cache">General Schema for Cache</h3>

<p><img src="\lectures\images\typora-user-images\image-20201204022204195.png" alt="image-20201204022204195" style="zoom:50%;" /></p>

<h3 id="2-way-set-associative-cache">2-Way Set Associative Cache</h3>

<p>In short, all the below caches will have a 4 <code class="language-plaintext highlighter-rouge">byte</code> space for data (as a shared trait), and a <strong>total of 32 bytes</strong></p>

<ul>
  <li>direct-mapped cache
    <ul>
      <li>in fact, as we know and the name suggests, it has only <strong>one way</strong> (8 sets), hence direct-mapped</li>
    </ul>
  </li>
  <li>2-way set associative cache
    <ul>
      <li>this will have <strong>two ways</strong> (4 sets)</li>
    </ul>
  </li>
  <li>fully associative cache
    <ul>
      <li>as you will see in later section, this has only <strong>one set</strong> (8 ways)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Note:</strong></p>

  <ul>
    <li>In fact, all the above will ignore spatial locality.</li>
  </ul>
</blockquote>

<p>Therefore, 2-way set associative cache looks like:</p>

<p><img src="\lectures\images\typora-user-images\image-20201204020242572.png" alt="image-20201204020242572" style="zoom: 80%;" /></p>

<p>where:</p>

<ul>
  <li>now, since we only have 4 sets, we can index it with <code class="language-plaintext highlighter-rouge">2</code> bits</li>
  <li>therefore, the <code class="language-plaintext highlighter-rouge">tag</code> will contain <code class="language-plaintext highlighter-rouge">(32-2)-2=28</code> bits</li>
</ul>

<h4 id="2-way-set-associative-cache-implementation">2-Way Set Associative Cache Implementation</h4>

<p>The <strong>difference</strong> will just be:</p>

<ul>
  <li>need to <strong>compare twice</strong> since we have two possible blocks for each set</li>
  <li>need to <strong>have a <code class="language-plaintext highlighter-rouge">MUX</code></strong> that tells us, <strong>when hit</strong>, which one to put out
    <ul>
      <li>here, it is simply <code class="language-plaintext highlighter-rouge">Hit1</code></li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201204023357952.png" alt="image-20201204023357952" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p>since we have doubled the #ways, but the total size of cache is constant, we have <strong>only 4 sets</strong></p>
  </li>
  <li>
    <p>since we have <strong>2 ways</strong>, we need to <strong>compare</strong> the <code class="language-plaintext highlighter-rouge">tag</code> <strong>twice</strong> (and <strong><code class="language-plaintext highlighter-rouge">v</code> twice</strong>)</p>
  </li>
</ul>

<h4 id="2-way-set-associative-cache-behavior">2-Way Set Associative Cache Behavior</h4>

<p>Again, consider the <strong>program that we had problem</strong> with:</p>

<p><img src="\lectures\images\typora-user-images\image-20201204023946681.png" alt="image-20201204023946681" style="zoom: 67%;" /></p>

<p>And both data will be stored</p>

<p><img src="\lectures\images\typora-user-images\image-20201204024032703.png" alt="image-20201204024032703" style="zoom: 50%;" /></p>

<p><strong>As a result:</strong></p>

<p><img src="\lectures\images\typora-user-images\image-20201204024059204.png" alt="image-20201204024059204" style="zoom:50%;" /></p>

<p>however:</p>

<ul>
  <li>the collision rate/<strong>comparison rate has gone up</strong>.</li>
</ul>

<h3 id="fully-associative-cache">Fully Associative Cache</h3>

<p>Now, we have a “queue” of size 8:</p>

<p><img src="\lectures\images\typora-user-images\image-20201204025002816.png" alt="image-20201204025002816" /></p>

<p>where:</p>

<ul>
  <li>now, since we just have <strong>1 set</strong>, we don’t need a set index anymore</li>
  <li>therefore, we will have <strong><code class="language-plaintext highlighter-rouge">30</code> bits for <code class="language-plaintext highlighter-rouge">tag</code></strong></li>
</ul>

<p><strong>Additionally:</strong></p>

<ul>
  <li>this would make <code class="language-plaintext highlighter-rouge">0%</code> conflict miss</li>
  <li>only <strong>compulsory and capacity misses</strong>,
    <ul>
      <li>compulsory misses -  in the beginning, we haven’t even read the data once. Then this will of course be missed.</li>
      <li>capacity misses - if we are working with memory data that is <strong>larger than the total size of our cache</strong></li>
      <li><strong><em>for example</em></strong>, we have <strong>$8$ blocks</strong> of <code class="language-plaintext highlighter-rouge">4</code> Bytes. If we are working with <strong>10 <code class="language-plaintext highlighter-rouge">lw</code></strong> all from different location, then eventually we will miss because it exceeded our total capacity.</li>
    </ul>
  </li>
  <li>however, the <strong>#comparisons has gone up</strong> due to the associativity/collision rate</li>
</ul>

<h3 id="direct-mapped-16-cache">Direct-Mapped-16 Cache</h3>

<p>This is the different with all the above, in which it stores <strong>16 bytes</strong> per block (<strong>4 words</strong> can be stored)</p>

<ul>
  <li>and still a <strong>total of 32 bytes</strong>, for the sake of comparison</li>
  <li><strong>this adds spatial locality</strong> into consideration</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201204020519369.png" alt="image-20201204020519369" style="zoom: 67%;" /></p>

<h4 id="direct-mapped-16-cache-implementation">Direct-Mapped-16 Cache Implementation</h4>

<p>Now, we are dealing with:</p>

<ul>
  <li>A direct mapped cache, so just <strong>one way</strong></li>
  <li>but we are storing <strong>16 bytes</strong> per block</li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201204030349796.png" alt="image-20201204030349796" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li><strong>set index starts at the <code class="language-plaintext highlighter-rouge">5</code>th bit of the address</strong>, instead of the <code class="language-plaintext highlighter-rouge">3</code> bit</li>
  <li><code class="language-plaintext highlighter-rouge">block offset</code> is used to <strong>select which sub-select</strong> in the cache, which data you want</li>
  <li><code class="language-plaintext highlighter-rouge">tag</code> will be <code class="language-plaintext highlighter-rouge">(32-2)-1 for set index - 2 for subselecting = 27</code> bits</li>
</ul>

<p><strong>Additionally:</strong></p>

<blockquote>
  <p><strong>Added Spatial Locality</strong>:</p>

  <ul>
    <li>When we get a <strong>miss</strong>:
      <ul>
        <li>we <strong>store 4 pieces of data</strong> that has the <strong>same tag+set number</strong>, with <strong>block offset either 00,01,10,11</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="direct-mapped-16-cache-example">Direct-Mapped-16 Cache Example</h4>

<p>Consider the program:</p>

<p><img src="\lectures\images\typora-user-images\image-20201204031026046.png" alt="image-20201204031026046" style="zoom:50%;" /></p>

<p><strong>and with spatial locality:</strong></p>

<p><img src="\lectures\images\typora-user-images\image-20201204031635820.png" alt="image-20201204031635820" style="zoom: 67%;" /></p>

<p>where:</p>

<ul>
  <li>the <strong>four data brought</strong> in had addresses:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">same tag</code>+<code class="language-plaintext highlighter-rouge">same set=0</code>+00+<code class="language-plaintext highlighter-rouge">00</code></li>
      <li><code class="language-plaintext highlighter-rouge">same tag</code>+<code class="language-plaintext highlighter-rouge">same set=0</code>+01+<code class="language-plaintext highlighter-rouge">00</code></li>
      <li><code class="language-plaintext highlighter-rouge">same tag</code>+<code class="language-plaintext highlighter-rouge">same set=0</code>+10+<code class="language-plaintext highlighter-rouge">00</code></li>
      <li><code class="language-plaintext highlighter-rouge">same tag</code>+<code class="language-plaintext highlighter-rouge">same set=0</code>+11+<code class="language-plaintext highlighter-rouge">00</code></li>
    </ul>
  </li>
</ul>

<p><strong>As a result:</strong></p>

<p><img src="\lectures\images\typora-user-images\image-20201204031842947.png" alt="image-20201204031842947" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>in the end, it also <strong>reduced the compulsory misses</strong> in the beginning</li>
</ul>

<h2 id="intel-on-chip-cache-trajectory">Intel On-Chip Cache Trajectory</h2>

<p>Over time, caches are:</p>

<ul>
  <li>growing in memory size</li>
  <li>deeper cache hierarchy</li>
  <li>physically closer to CPU
    <ul>
      <li>which is good for faster CPU accesses</li>
    </ul>
  </li>
</ul>

<p><img src="\lectures\images\typora-user-images\image-20201204032241538.png" alt="image-20201204032241538" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>in general, it has been found that by <strong>separating data and instruction storage</strong> into two caches speeds up the performance</li>
  <li><code class="language-plaintext highlighter-rouge">trace cache</code> <strong>caches</strong> a sequence of instructions before execution needs (by guess work)</li>
</ul>

  </div><a class="u-url" href="/lectures/2021@columbia/CSEE3827_Fundemental_of_Computer.html/" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/lectures/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Lecture Notes</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Lecture Notes</li><li><a class="u-email" href="mailto:jasonyux17@gmail.com">jasonyux17@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jasonyux"><svg class="svg-icon"><use xlink:href="/lectures/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jasonyux</span></a></li><li><a href="https://www.linkedin.com/in/xiao-yu2437"><svg class="svg-icon"><use xlink:href="/lectures/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">xiao-yu2437</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>An inexhaustive collection of markdown/latex(PDF) notes that I took since college. </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
