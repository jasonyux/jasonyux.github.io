<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>COMS4118 Operating Systems | Lecture Notes</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="COMS4118 Operating Systems" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An inexhaustive collection of markdown/latex(PDF) notes that I took since college." />
<meta property="og:description" content="An inexhaustive collection of markdown/latex(PDF) notes that I took since college." />
<link rel="canonical" href="/lectures/2021@columbia/COMS4118_Operating_Systems.html/" />
<meta property="og:url" content="/lectures/2021@columbia/COMS4118_Operating_Systems.html/" />
<meta property="og:site_name" content="Lecture Notes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-04T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="COMS4118 Operating Systems" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-01-04T00:00:00-05:00","datePublished":"2022-01-04T00:00:00-05:00","description":"An inexhaustive collection of markdown/latex(PDF) notes that I took since college.","headline":"COMS4118 Operating Systems","mainEntityOfPage":{"@type":"WebPage","@id":"/lectures/2021@columbia/COMS4118_Operating_Systems.html/"},"url":"/lectures/2021@columbia/COMS4118_Operating_Systems.html/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/lectures/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/lectures/feed.xml" title="Lecture Notes" /></head>
<body><header class="site-header">

	<div class="wrapper"><a class="site-title" rel="author" href="/lectures/">Lecture Notes</a>

		<nav class="site-nav">
			<input type="checkbox" id="nav-trigger" class="nav-trigger" />
			<label for="nav-trigger">
			<span class="menu-icon">
				<svg viewBox="0 0 18 15" width="18px" height="15px">
				<path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
				</svg>
			</span>
			</label>

			<div class="trigger">
				<a class="page-link" href="/">Home</a>
				<a class="page-link" href="/projects">Projects</a>
				<a class="page-link" href="/learning">Blog</a>
				<a class="page-link" href="/research">Research</a>
				<span class="page-link" href="#">[Education]</span>
			</div>
		</nav>
	</div>
  </header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <head>
	<script>
		MathJax = {
		  tex: {
			inlineMath: [['$', '$'], ['\\(', '\\)']],
			displayMath: [['$$', '$$'], ['\\[', '\\]']]
		  }
		};
	</script>
	<script id="MathJax-script" async
		src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
	</script>
  </head>
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">COMS4118 Operating Systems</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-01-04T00:00:00-05:00" itemprop="datePublished">
        Jan 4, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <style type="text/css">@page { margin-left: 0em; } img {width: 60%;}</style>

<h1 id="week-1---introduction">Week 1 - Introduction</h1>

<h2 id="os-1-logistics">OS 1 Logistics</h2>

<ul>
  <li>Course <strong>Website</strong>
    <ul>
      <li>includes TA OH sessions</li>
      <li>https://www.cs.columbia.edu/~nieh/teaching/w4118/</li>
    </ul>
  </li>
  <li><strong>Issues</strong> with the course
    <ul>
      <li>Use the w4118 staff mailing list, <code class="language-plaintext highlighter-rouge">w4118@lists.cs.columbia.edu</code>
        <ul>
          <li>e.g. regrade request</li>
        </ul>
      </li>
      <li>Or email to Professor Jason personally</li>
    </ul>
  </li>
  <li><strong>Homework</strong> Assignments 50%
    <ul>
      <li>Lowest will be dropped</li>
      <li><em>Submitted via <code class="language-plaintext highlighter-rouge">git</code></em>, and by default latest submission counts (or, you can <strong><em>specify</em></strong> which submission)
        <ul>
          <li>instructions available on https://w4118.github.io/</li>
        </ul>
      </li>
      <li>Codes can be written anywhere, but <strong><em>testing must be done in the VM machine</em></strong> of the course</li>
      <li>Using materials/code outside of your work needs a <strong>citation</strong> (in top-level <code class="language-plaintext highlighter-rouge">references.txt</code>)
        <ul>
          <li>this includes discussions from fri.,ends</li>
          <li>except for materials in the textbooks</li>
          <li>see http://www.cs.columbia.edu/~nieh/teaching/w4118/homeworks/references.txt</li>
        </ul>
      </li>
      <li>Details see http://www.cs.columbia.edu/~nieh/teaching/w4118/homeworks/</li>
    </ul>
  </li>
  <li>Synchronous <strong>Exams</strong> 50%
    <ul>
      <li>Midterm 20%</li>
      <li>Final 30%</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Cores of the Course:</strong></p>

  <ul>
    <li>How the underlying <strong>C APIs</strong> work</li>
    <li><strong>Concurrency</strong>
      <ul>
        <li>threading</li>
        <li>synchronization</li>
      </ul>
    </li>
    <li>Programming in the <strong>Kernel</strong>
      <ul>
        <li>build, compile, run your own OS</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="what-is-an-os">What is an OS</h2>

<blockquote>
  <p><strong>Heuristics:</strong> Are applications part of an OS? Is browser part of an OS?</p>

  <ul>
    <li>
      <p>Microsoft and Netscape. Microscope basically bundled the browser Netscape with their OS!</p>

      <ul>
        <li>the government accused Microsoft for taking a potential monopoly in software as well</li>
      </ul>
    </li>
    <li>
      <p>OS Kernel + OS environment</p>

      <ul>
        <li>
          <p>Kernel = Core part of an OS</p>

          <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-11_22-44-19.png" style="zoom: 25%;" /></p>

          <p>where:</p>

          <ul>
            <li>A kernel provides APIs to its upper levels</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Things we <strong>need an OS to do</strong>:</p>

<ul>
  <li><strong>manage the computer’s hardware</strong></li>
  <li><strong>provides</strong> a basis for application programs and acts as an <strong>intermediary</strong> between the computer user (and applications) and the computer hardware
    <ul>
      <li>to do this, OS supply some API/<strong>System Calls</strong> so that users/applications can use them</li>
    </ul>
  </li>
  <li><strong>run</strong> a program (<strong>process</strong>)</li>
</ul>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-13_21-36-13.png" alt="" /></p>

<blockquote>
  <p><strong>Reminder:</strong></p>

  <ul>
    <li>
      <p>To run that process, the OS needs to manage the Unix Address Space</p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-11_22-48-32.png" style="zoom: 33%;" /></p>

      <p>where:</p>

      <ul>
        <li>remember that your code stays in <code class="language-plaintext highlighter-rouge">text</code>, static/global data in <code class="language-plaintext highlighter-rouge">data</code> and <code class="language-plaintext highlighter-rouge">bss</code>, and etc.
          <ul>
            <li>the difference between <code class="language-plaintext highlighter-rouge">data</code> and <code class="language-plaintext highlighter-rouge">bss</code> is that one of them stores initialized data, one of them initialized data</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="what-os-do">What OS Do</h3>

<p>First, a computer system contains:</p>

<ul>
  <li>A <strong>hardware</strong>
    <ul>
      <li>CPU, memory, I/O devices</li>
    </ul>
  </li>
  <li>An <strong>OS</strong>
    <ul>
      <li>provides an environment within which other programs can do useful work</li>
      <li>depends on the need, <strong>OS can “act” completely differently</strong> (different implementation)
        <ul>
          <li><em>for example,</em> when you have a shared system, the OS will tend to maximize resource utilization— to assure that all available CPU time, memory, and I/O are used efficiently and that no individual user takes more than her fair share. (As compared to a personal laptop, which does not care about resource sharing)</li>
        </ul>
      </li>
      <li>from the computer’s point of view, the operating system is the program most intimately involved with the hardware.
        <ul>
          <li>In this context, we can view an operating system as a <strong>resource allocator</strong>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>An <strong>application program</strong>
    <ul>
      <li>word processors, spreadsheets</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>A small history of OS</strong></p>

  <ul>
    <li>The fundamental goal of computer systems is to <strong>execute user programs and to make solving user problems easier</strong>. Computer hardware is constructed toward this goal.</li>
    <li>Since bare hardware alone is not particularly easy to use, application programs are developed. These programs require certain common operations, such as those controlling the I/O devices. <strong>The common functions of controlling and allocating resources are then brought together into one piece of software: the operating system.</strong></li>
  </ul>
</blockquote>

<p>However, we have <strong><em>no universally accepted definition of what is part of the operating system</em></strong>.</p>

<p>Yet a popular definition is: operating system is the <strong>one program</strong> running at all times on the computer—usually called the <strong>kernel</strong>.</p>

<ul>
  <li>Along with the kernel, there are two other types of programs:
    <ul>
      <li><strong>system programs</strong>, which are associated with the operating system but are not necessarily part of the kernel, e.g.
        <ul>
          <li>System Software maintain the system resources and give the path for application software to run. An important thing is that without system software, system can not run.</li>
        </ul>
      </li>
      <li><strong>application programs</strong>, which include all programs not associated with the operation of the system, e.g. a web browser</li>
    </ul>
  </li>
</ul>

<p><img src="images\Snipaste_2021-01-18_12-38-06.png" style="zoom: 80%;" /></p>

<p>where:</p>

<ul>
  <li>usually when you execute commands in CLI such as <code class="language-plaintext highlighter-rouge">ls</code>, they basically executes a <strong>system program</strong> (a file), which then in turn will execute some underlying system calls to perform the task</li>
</ul>

<blockquote>
  <p><strong>Kernel vs OS</strong></p>

  <ul>
    <li>Sometimes, people refer to the <strong>OS</strong> as the entire environment of the computing system, including the <strong>kernel, system programs, <em>and GUIs (possibly some native applications as well)</em></strong>.</li>
    <li>Below shows the general structure of a <strong>UNIX system</strong>, in particular, what a <strong>kernel</strong> does and the structure of the entire <strong><em>layered</em></strong> environment</li>
  </ul>

  <p><img src="images\Snipaste_2021-01-18_12-55-52.png" alt="" /></p>
</blockquote>

<h3 id="system-calls">System Calls</h3>

<blockquote>
  <p><strong>Definition:</strong></p>

  <ul>
    <li>A <strong>system call</strong> (commonly abbreviated to <code class="language-plaintext highlighter-rouge">syscall</code>) is the programmatic way in which a computer program requests a service from the <strong><em>kernel of the operating system</em></strong></li>
    <li>Therefore, it is the sole interface between a user and a kernel
      <ul>
        <li>it is also made to <strong><em>return integers</em></strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Here, you need to know that:</p>

<ul>
  <li>
    <p>the difference between user space and kernel space is:</p>

    <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-11_22-54-52.png" style="zoom: 33%;" /></p>
  </li>
</ul>

<blockquote>
  <p><strong>Definition: Errors in System Calls</strong></p>

  <ul>
    <li>Since using the APIs depend on the programmer, OS <strong>puts error code in <code class="language-plaintext highlighter-rouge">errno</code> variable</strong>
      <ul>
        <li>errors are typically indicated by returns of <code class="language-plaintext highlighter-rouge">-1</code></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><strong><em>For Example:</em> A System Call</strong></p>

<p><code class="language-plaintext highlighter-rouge">write()</code> is actually a system call of UNIX:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
    <span class="c1">// error!</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"error %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span> <span class="c1">// for errno, see below</span>
    <span class="c1">// perror</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li>Many system calls and system-level functions use the <code class="language-plaintext highlighter-rouge">errno</code> facility. To deal with these calls, <strong>you will need to include <code class="language-plaintext highlighter-rouge">errno.h</code>, which will provide something that looks like a global integer variable called <code class="language-plaintext highlighter-rouge">errno</code></strong>.
    <ul>
      <li>There are a standard set of predefined constants corresponding to common error conditions (see <code class="language-plaintext highlighter-rouge">errno.h</code> for details).</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong><em>Reminder:</em></strong></p>

  <ul>
    <li><strong><em>C does not have any standard exception signaling/handling mechanism</em></strong>, <em>so errors are handled by normal function return values (or by side affecting some data).</em></li>
  </ul>
</blockquote>

<p>However, <strong>for most of the other cases</strong>, this is what happens:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-13_21-55-33.png" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>the <strong><em>library</em></strong> does a little abstraction for making system calls easier
    <ul>
      <li><em>for example</em>, the <code class="language-plaintext highlighter-rouge">libc</code> library</li>
      <li><em>for example,</em> <code class="language-plaintext highlighter-rouge">fread()</code> and <code class="language-plaintext highlighter-rouge">fwrite()</code> are library functions. (They also do not return integers.)</li>
    </ul>
  </li>
</ul>

<h3 id="creating-a-process">Creating a Process</h3>

<blockquote>
  <p><strong>Heuristics:</strong></p>

  <ul>
    <li>How does an OS create and run a process?</li>
    <li>First, we need to remember that a <strong>process has</strong>:
      <ul>
        <li>an <strong>Unix Address Space</strong> (stack, heap, etc.) to keep track of what the program is doing</li>
        <li>a <strong>stack pointer</strong> to tell you where the stack is</li>
        <li>a <strong>program counter</strong> to tell you which line of code/instruction to run</li>
        <li><strong>registers</strong> for storing data</li>
        <li>etc.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>In fact, we know one <code class="language-plaintext highlighter-rouge">C</code> function (abstracted away by the OS) to create a process: <code class="language-plaintext highlighter-rouge">fork()</code></p>

<blockquote>
  <p><strong><em>Reminder:</em></strong></p>

  <ul>
    <li>After calling <code class="language-plaintext highlighter-rouge">fork()</code> during one of your process, it will <strong><em>create another process:</em></strong></li>
  </ul>

  <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-13_22-13-28.png" style="zoom: 33%;" /></p>
</blockquote>

<h2 id="booting-an-os">Booting an OS</h2>

<p>In summary, the following happens:</p>

<ol>
  <li>When a CPU receives a reset event—for instance, when it is powered up or rebooted—<strong>the instruction register is loaded</strong> with a <strong>predefined memory location</strong>, and execution starts there
    <ul>
      <li><strong><em>At that location is the initial bootstrap program</em></strong>. This program is in the form of <strong>read-only memory (ROM)</strong>. (This means it is fixed code)</li>
      <li>The PC will be loaded with something called a <strong>BIOS</strong> (Basic Input/Output System.) <strong>On modern PCs, the CPU loads UEFI (Unified Extensible Firmware Interface) firmware instead</strong>.</li>
    </ul>
  </li>
  <li>Then, that <strong>bootstrap program (e.g. BIOS)</strong> hand off to a <strong>boot device</strong>
    <ul>
      <li>typically, it is <strong>on your hard disk/SSD</strong>. Traditionally, a BIOS looked at the <strong>MBR (master boot record)</strong>, a special boot sector at the <strong>beginning of a disk</strong>. The MBR contains code that loads the rest of the operating system, known as a “<strong>bootloader</strong>.”
        <ul>
          <li>basically, it will <strong>read a single block at a <em>fixed</em> location (say block zero) from <em>disk</em> (so the bootloader)</strong> into memory and execute the code from that <strong>boot block</strong></li>
          <li>For <strong>large operating systems</strong> (including most general-purpose operating systems like Windows, Mac OS X, and UNIX) or for systems that change frequently, the <strong>operating system is on disk</strong>.</li>
        </ul>
      </li>
      <li><strong>boot device is configurable</strong> from within the UEFI or BIOS setup screen.
        <ul>
          <li>so you can switch that to <strong>read from a USB stick</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Then, depending on the choice, that <strong>boot block/bootloader (e.g. GRUB)</strong> can:
    <ul>
      <li>contain the entire sophisticated code that load the entire OS into memory and begin execution</li>
      <li>contain a <strong><em>simple code</em></strong> that only knows <strong><em>where to find the more sophisticated bootstrap program</em></strong> on disk and also the <strong><em>length of that program</em></strong>.
        <ul>
          <li>On Windows, the Windows Boot Manager (bootloader) <strong>finds and starts <a href="https://docs.microsoft.com/en-us/windows/client-management/advanced-troubleshooting-boot-problems">the Windows OS Loader</a>.</strong> The OS loader loads essential hardware drivers that are required to run the kernel—the core part of the Windows operating system—and then <strong>launches the kernel</strong>.</li>
          <li>On Linux, the <strong>GRUB boot loader loads the Linux kernel</strong>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Now that the <strong>full bootstrap program has been loaded</strong>, and you can now work with it.
    <ul>
      <li>On Linux, at this point, the kernel also <strong>starts the <code class="language-plaintext highlighter-rouge">init</code> system</strong>—that’s <code class="language-plaintext highlighter-rouge">systemd</code> on most modern Linux distributions</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>The <strong>next step of <code class="language-plaintext highlighter-rouge">init</code></strong> is to start up various daemons that <strong>support networking and other services</strong>.</p>

  <ul>
    <li>X server daemon is one of the most important daemon. It manages display, keyboard, and mouse. When X server daemon is started you see a Graphical Interface and a login screen is displayed.</li>
  </ul>
</blockquote>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-20_23-39-08.png" alt="" /></p>

<h2 id="questions">Questions</h2>

<ul>
  <li>
    <p><strong>Question</strong></p>

    <p>“The boot block can contain a <strong><em>simple code</em></strong> that only knows <strong><em>where to find the more sophisticated bootstrap program</em></strong> and the length…”. Why do the more work of locating the other bootstrap program? Why can’t it just load the sophisticated boot strap program directly?</p>

    <p>Is it there to allow users to potentially install and then choose from different OS?</p>
  </li>
</ul>

<h1 id="week-2">Week 2</h1>

<h2 id="using-your-computer-system">Using your Computer System</h2>

<p><strong>After booted</strong>, how do we use it?</p>

<ul>
  <li>Explanation of what happens at boot up time is written in section <a href="#Booting-an-OS">Booting an OS</a></li>
</ul>

<blockquote>
  <p><strong>Some History:</strong></p>

  <ul>
    <li>
      <p>Before OS comes up:</p>

      <ul>
        <li>
          <p>people uses <strong>assembly code</strong> to manipulate registers/RAM</p>
        </li>
        <li>
          <p>commonly used ones include x86 with AT&amp;T syntax:</p>

          <pre><code class="language-assembly">mov $0xDEAD, %ax # to move the value 0xDEAD into register ax
</code></pre>
        </li>
        <li>
          <p><strong>this means that to do I/O</strong>, you will need to use a <strong>Memory Mapped I/O</strong>, which basically maps <em>addresses of an I/O device to your RAM</em>, so that you have a way to <strong>directly read/write data into the I/O</strong></p>

          <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-20_22-11-32.png" style="zoom: 50%;" /></p>
        </li>
        <li>
          <p>However, when the OS booted up, it is <strong>in 16-bit mode</strong>, so that you can only address up to <code class="language-plaintext highlighter-rouge">0xFFFF</code></p>
        </li>
        <li>
          <p><strong>Therefore, to access addresses outside of that</strong>, we need to use <strong>segmentation</strong>:</p>

          <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-20_22-20-21.png" style="zoom: 33%;" /></p>

          <p>So <strong>addresses</strong> are calculated with:</p>

          <pre><code class="language-assembly">address = base * 0x10 + offset
</code></pre>

          <p>then to access address <code class="language-plaintext highlighter-rouge">0xf0ff0</code>:</p>

          <pre><code class="language-assembly">mov $0xf000, %ax
mov %ax, %ds # you cannot directly copy literals into ds register
        
movb $1, (0xff0) # accesses 0xf0ff0
</code></pre>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><strong>Now, when you have an <code class="language-plaintext highlighter-rouge">OS</code></strong></p>

<ul>
  <li>All we needed to do is to use <code class="language-plaintext highlighter-rouge">OS System Calls</code>
    <ul>
      <li>without all the difficulty with assembly code and stuff</li>
    </ul>
  </li>
  <li>Can <strong>use the C library</strong></li>
  <li>Can have multiple programs and run <strong>multiple processes</strong></li>
</ul>

<blockquote>
  <p><strong>But in essence, it just becomes that the OS have the control all the hardware.</strong></p>

  <ul>
    <li>instead of yourself being able to manipulate via the assembly code</li>
    <li>so the OS has to deal with:
      <ul>
        <li><strong>program interrupt timers</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="interrupts">Interrupts</h3>

<p>How does interrupt works?</p>

<p><strong>In between your instructions</strong>, the <em>CPU checks</em> from the interrupt line, <strong><em>whether there has been an interrupt</em></strong>, and will handle that before proceeding.</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-20_22-52-55.png" style="zoom: 33%;" /></p>

<p>where:</p>

<ul>
  <li>attached to the CPU, you have an <strong>INTR</strong>(upt) line</li>
  <li>from that PIC, you can attach things such as:
    <ul>
      <li>timer</li>
      <li>disk</li>
      <li>networks</li>
      <li>all of which that can generate interrupts</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Interrupt vs Trap</strong></p>

  <ul>
    <li>A <strong>trap</strong> is a <em>software</em>-generated <strong>interrupt</strong>.
      <ul>
        <li>e.g. to call system calls</li>
      </ul>
    </li>
    <li><strong>Interrupts</strong> are <em>hardware</em> <strong>interrupts</strong>.</li>
  </ul>
</blockquote>

<p><strong>Typically</strong>, there is also an <strong>interrupt descriptor table (IDT)</strong> to that contains pointers to <strong>handlers to each type of interrupt</strong></p>

<ul>
  <li>so it has a bunch of functions, that can be used to handle different types of interrupts
    <ul>
      <li><em>for example,</em> when a time interrupt happened, the <strong>CPU checks the table, and looks at and goes to the address</strong> of the <em>time interrupt handle</em> (where some code will be there to handle time interrupts)</li>
    </ul>
  </li>
  <li><strong>those handlers</strong> will be <strong>OS code</strong> (managed by the OS)</li>
  <li>this IDT table is stored in the <code class="language-plaintext highlighter-rouge">idt</code> <strong>register</strong>
    <ul>
      <li>this will be setup by the OS at boot/load time</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>When your CPU has to deal with an interrupt, you need your CPU to <strong>push every register holding current data into the stack</strong></li>
    <li>Then, when the CPU is done with the interrupts, it pops off from the stack, so that it can deal with <strong>last processed code</strong></li>
  </ul>
</blockquote>

<h3 id="exception">Exception</h3>

<p>Exceptions happen <strong>within the instruction</strong>, as compared to interrupts <strong>between instructions</strong></p>

<ul>
  <li><em>for example</em>, when you attempt to divide by 0, the <strong>CPU itself</strong> will throw an interrupt</li>
</ul>

<p><strong>CPUs tend to throw an <em>exception</em> interrupt (in between exceptions)</strong>, on things like division by zero, or dereferencing a NULL pointer.</p>

<ul>
  <li>These interrupts are trapped, like when hardware interrupts, <strong>halting execution of current program and return control to the <em>OS</em></strong>, which then handles the event.</li>
</ul>

<h3 id="cpu-modes">CPU Modes</h3>

<p>This could be very useful to deal with <strong>constrain accesses/control security</strong> .</p>

<ul>
  <li>user mode</li>
  <li>privileged mode (kernel)</li>
</ul>

<blockquote>
  <ul>
    <li>
      <p>When you are running user programs, your OS <strong>switches the CPU into user mode</strong></p>
    </li>
    <li>
      <p>When you are running necessary system calls, your OS <strong>switches the CPU into kernel mode</strong></p>
    </li>
  </ul>
</blockquote>

<p>Some <strong>privileged instructions</strong> involve:</p>

<ul>
  <li>writing the <code class="language-plaintext highlighter-rouge">idt</code> register</li>
  <li>disable interrupts
    <ul>
      <li>if disabled, it means interrupts still comes, but the <em>CPU will not check them between instructions anymore</em></li>
    </ul>
  </li>
  <li>switch into kernel/privileged mode</li>
  <li>etc, so that the OS can maintain control</li>
</ul>

<h3 id="init-process">Init Process</h3>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">init</code> process (referred in UNIX often) sets up everything, and is the first process</li>
  <li>All the following processes are the children of this <code class="language-plaintext highlighter-rouge">init</code> process</li>
</ol>

<h1 id="week-3---4">Week 3 - 4</h1>

<h2 id="processes">Processes</h2>

<p>Each process is represented in the operating system by a <strong>process control block (PCB)</strong>—also called a task control block:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-26_21-47-53.png" style="zoom:50%;" /></p>

<h3 id="life-cycle-of-a-process">Life Cycle of a Process</h3>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-16_12-05-42.png" alt="" /></p>

<ol>
  <li>
    <p>it is <strong>created</strong></p>

    <ul>
      <li>e.g. <code class="language-plaintext highlighter-rouge">fork()</code></li>
    </ul>
  </li>
  <li>
    <p>it is queued in a <strong>ready queue</strong></p>

    <ul>
      <li><em>process scheduling</em></li>
      <li>in the <em>state diagram</em>:
        <ul>
          <li><em>runnable</em></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>the scheduler calls the process and now it is <strong>running</strong></p>

    <ul>
      <li>in the <em>state diagram</em>
        <ul>
          <li><em>running</em></li>
          <li><em>blocked</em> means your program is waiting on something (e.g. User input, I/O), and not proceeding in execution</li>
          <li><em>wakes up</em> means your process has got what it is waiting, and goes back in the queue</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>program <strong>terminates</strong></p>

    <ul>
      <li>the program <em>will <strong>not</strong> exit</em> unless it has entered the <em>running</em> state
        <ul>
          <li>this explains why, sometimes sending <code class="language-plaintext highlighter-rouge">Ctrl-C</code> will not work, because the process has not yet went out from the <em>blocked</em> state</li>
        </ul>
      </li>
      <li>in the <em>state diagram</em>
        <ul>
          <li><em>terminate</em>
            <ul>
              <li>for a process, first it becomes a <em>zombie</em> (parent has not called <code class="language-plaintext highlighter-rouge">wait()</code> yet), then it is <em>dead</em></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p><strong>In Linux, this is how the state is recorded</strong></p>

  <ul>
    <li>
      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define TASK_RUNNING			0x0000 </span><span class="cm">/* the obvious one */</span><span class="cp">
#define TASK_INTERRUPTIBLE		0x0001 </span><span class="cm">/* e.g. the Ctrl-C comes, OS interrupts/switches it to runnable */</span><span class="cp">
#define TASK_UNINTERRUPTIBLE		0x0002  </span><span class="cm">/* e.g. the Ctrl-C comes, it is still blocked */</span><span class="cp">
#define __TASK_STOPPED			0x0004
#define __TASK_TRACED			0x0008
</span><span class="cm">/* Used in tsk-&gt;exit_state: */</span>
<span class="cp">#define EXIT_DEAD			0x0010 </span><span class="cm">/* Process exited/dead AND it has been wait() on by its parent */</span><span class="cp">
#define EXIT_ZOMBIE			0x0020 </span><span class="cm">/* Process exited/dead, but the task struct is still in the OS */</span><span class="cp">
#define EXIT_TRACE			(EXIT_ZOMBIE | EXIT_DEAD)
</span><span class="cm">/* Used in tsk-&gt;state again: */</span>
<span class="cp">#define TASK_PARKED			0x0040
#define TASK_DEAD			0x0080 </span><span class="cm">/* First state when Processes is killed FROM running. */</span><span class="cp">
</span>							     <span class="cm">/* Afterwards, it goes to EXIT_ZOMBIE */</span>
<span class="cp">#define TASK_WAKEKILL			0x0100
#define TASK_WAKING			0x0200
#define TASK_NOLOAD			0x0400
#define TASK_NEW			0x0800
#define TASK_STATE_MAX			0x1000
</span></code></pre></div>      </div>
    </li>
  </ul>
</blockquote>

<h3 id="process-scheduling">Process Scheduling</h3>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-26_21-44-40.png" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>Each <em>rectangular box</em> represents a queue.
    <ul>
      <li>Two types of queues are present: the ready queue and a set of device queues.</li>
    </ul>
  </li>
  <li>The <em>circles</em> represent the resources that serve the queues, and the arrows indicate the flow of processes in the system.</li>
</ul>

<p><strong>A new process is initially put in the ready queue</strong>. It waits there until it is selected for execution, or <em>dispatched</em>. Once the process is allocated the CPU and is executing, one of several events could occur:</p>

<ul>
  <li>The process could issue an I/O request and then be placed in an I/O queue.</li>
  <li>The process could create a new child process and wait for the child’s termination.</li>
  <li>The process could be removed forcibly from the CPU, as a result of an interrupt, and be put back in the ready queue.</li>
</ul>

<h4 id="context-switch">Context Switch</h4>

<p>This basically refers to the phenomenon that the OS <code class="language-plaintext highlighter-rouge">scheduler</code> decides to switch the running current process to running another one (e.g. due to time being used up).</p>

<p><em>For Example</em>:</p>

<ol>
  <li>A user process <code class="language-plaintext highlighter-rouge">P</code> has used up the time it has for execution</li>
  <li><em>Time Interrupt</em> sent to kernel</li>
  <li>Kernel <code class="language-plaintext highlighter-rouge">schedule</code> another process <code class="language-plaintext highlighter-rouge">Q</code> to run. In fact, this is what happens:
    <ul>
      <li>process <code class="language-plaintext highlighter-rouge">P</code> changes its state to, for example, <code class="language-plaintext highlighter-rouge">Running -&gt; Runnable</code></li>
      <li>process <code class="language-plaintext highlighter-rouge">P</code> then <em>calls</em> <code class="language-plaintext highlighter-rouge">schedule</code> to schedule another process to run</li>
    </ul>
  </li>
  <li>So at this point, a context switch happened
    <ul>
      <li>you need to store the state of process <code class="language-plaintext highlighter-rouge">P</code></li>
    </ul>
  </li>
</ol>

<h3 id="process-creation">Process Creation</h3>

<p>The <strong><code class="language-plaintext highlighter-rouge">init</code> process</strong> (which always has a <code class="language-plaintext highlighter-rouge">pid</code> of 1) serves as the <strong>root parent process</strong> for all user processes.</p>

<p>Once the system has booted, the <code class="language-plaintext highlighter-rouge">init</code> process can also create various user processes, such as a web or print server, an <code class="language-plaintext highlighter-rouge">ssh</code> server, and the like</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-26_22-20-07.png" style="zoom: 67%;" /></p>

<p>When a process creates a <strong>new process</strong>, two possibilities for <strong>execution</strong> exist:</p>
<ol>
  <li>The parent continues to execute <em>concurrently</em> with its children.</li>
  <li>The parent <em>waits</em> until some or all of its children have terminated.</li>
</ol>

<p>There are also <strong>two address-space possibilities</strong> for the new process:</p>

<ol>
  <li>The child process is a <em>duplicate</em> of the parent process (it has the same program and data as the parent).</li>
  <li>The child process has a <em>new program</em> loaded into it.</li>
</ol>

<h3 id="process-termination">Process Termination</h3>

<p>A process <strong>terminates</strong> when it finishes executing its final statement and <strong>asks the operating system to delete</strong> it by using the <code class="language-plaintext highlighter-rouge">exit()</code> system call.</p>

<ul>
  <li>At that point, the process may <em>return a status value (typically an integer) to its parent process</em> (via the <code class="language-plaintext highlighter-rouge">wait()</code> system call). All the <em>resources of the process</em>—including physical and virtual memory,  open files, and I/O buffers—are <strong>deallocated by the operating system</strong>.</li>
</ul>

<blockquote>
  <p><strong>Zombie Process</strong></p>

  <ul>
    <li>
      <p>When a process terminates, its resources are deallocated by the operating system. <em>However, its entry in the process table must remain there until the parent calls <code class="language-plaintext highlighter-rouge">wait()</code></em>, because the process table contains the process’s exit status.</p>

      <p>So, a process that has terminated, but <strong>whose parent has not yet called <code class="language-plaintext highlighter-rouge">wait()</code></strong>, is known as a <strong>zombie process</strong>.</p>

      <ul>
        <li>All processes transition to this state when they terminate, but generally they exist as zombies only briefly. Once the parent calls <code class="language-plaintext highlighter-rouge">wait()</code>, the <em>process identifier of the zombie process and its entry in the process table are released.</em></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Orphaned Process</strong></p>

  <ul>
    <li>
      <p>Now consider what would happen if a <strong>parent did not invoke <code class="language-plaintext highlighter-rouge">wait()</code> and instead terminated</strong>, thereby leaving its child processes as <strong>orphans</strong>.</p>

      <p>Linux and UNIX address this scenario by assigning the <code class="language-plaintext highlighter-rouge">init</code> process <em>as the new parent</em></p>

      <ul>
        <li>The <code class="language-plaintext highlighter-rouge">init</code> process periodically invokes <code class="language-plaintext highlighter-rouge">wait()</code>, thereby allowing the exit status of any orphaned process to be collected and <em>releasing the orphan’s process identifier and process-table entry</em>.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="process-communication">Process Communication</h3>

<p>Processes have its own address space. What if we need to share something between two processes?</p>

<p><em>Inter-process communication (IPC)</em>, can be done in two ways:</p>

<ul>
  <li><strong>message passing</strong>
    <ul>
      <li>e.g. <em>signals</em></li>
    </ul>
  </li>
  <li><strong>shared memory</strong></li>
</ul>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-02_10-21-17.png" style="zoom: 50%;" /></p>

<h4 id="message-passing">Message Passing</h4>

<blockquote>
  <p><strong>Simple Message Passing</strong></p>

  <ul>
    <li>
      <p>This is</p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-02_10-27-54.png" style="zoom:33%;" /></p>

      <p>where:</p>

      <ul>
        <li><code class="language-plaintext highlighter-rouge">signal number</code>, a number <strong>indicating some status</strong>, such as <code class="language-plaintext highlighter-rouge">A</code> has done its work, and it needs <code class="language-plaintext highlighter-rouge">B</code> to proceed
          <ul>
            <li>has nothing to do with <em>Interrupts</em></li>
          </ul>
        </li>
        <li><code class="language-plaintext highlighter-rouge">singal handler</code>, so that the other process knows <strong>what to do with the signal</strong>
          <ul>
            <li>obviously, <code class="language-plaintext highlighter-rouge">B</code> <em>cannot</em> handle the signal until <code class="language-plaintext highlighter-rouge">B</code> runs</li>
            <li>e.g. <code class="language-plaintext highlighter-rouge">SIGINT</code>, aims to kill a process, but you <em>could</em> change its implementation in the <code class="language-plaintext highlighter-rouge">signal handler</code>. This is generated by <code class="language-plaintext highlighter-rouge">Ctrl-C</code>
              <ul>
                <li><code class="language-plaintext highlighter-rouge">SIGKILL</code> (forcibly kills the process, <em>does not allow</em> implementation in <code class="language-plaintext highlighter-rouge">signal handler</code>)</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Under the hood, this is how it is implemented. Consider the <code class="language-plaintext highlighter-rouge">SIGKILL</code> signal is <strong>received by a process</strong>:</p>

<ol>
  <li>
    <p>inside <code class="language-plaintext highlighter-rouge">kernel/signal.c</code></p>

    <ul>
      <li>
        <p>it has <code class="language-plaintext highlighter-rouge">static int kill_something_info</code></p>
      </li>
      <li>
        <p>in the end, the OS does:</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">send_signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_siginfo</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">pid_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */</span>
	<span class="n">bool</span> <span class="n">force</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
     
	<span class="cm">/* bunch of stuff omitted */</span>
	<span class="k">return</span> <span class="n">__send_signal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">force</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>In the end, there is a <code class="language-plaintext highlighter-rouge">sigaddset(&amp;pending-&gt;signal, sig);</code>, which <strong>adds a signal to the receiving process</strong></p>

    <ul>
      <li>the <code class="language-plaintext highlighter-rouge">pending</code> is basically a <em>field of the task struct</em>, which is a <strong>bit map</strong> <em>indicating the current signals</em>
        <ul>
          <li>in the end, <code class="language-plaintext highlighter-rouge">pending</code> is a <code class="language-plaintext highlighter-rouge">sigset_t</code> which looks like <code class="language-plaintext highlighter-rouge">unsigned long sig[_NSIG_WORDS]</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>After setting the signal, the function in <code class="language-plaintext highlighter-rouge">static int kill_something_info</code> calls <code class="language-plaintext highlighter-rouge">complete_signal()</code></p>

    <ul>
      <li>this essentially calls <code class="language-plaintext highlighter-rouge">signal_wake_up()</code>, which will <strong>wake up the receiving process</strong></li>
    </ul>
  </li>
  <li>
    <p>Lastly, the <strong>receiving process eventually runs</strong>, which means that the OS wants to return back to User mode and run the code of that program.</p>

    <ul>
      <li>
        <p><em>now, during that process</em>, the OS <em>makes the process</em> to be <code class="language-plaintext highlighter-rouge">RUNNING</code>, and the OS does something like (might not be entirely correct):</p>

        <ol>
          <li>
            <p><code class="language-plaintext highlighter-rouge">prepare_exit_to_usermode()</code>, which calls</p>
          </li>
          <li>
            <p><code class="language-plaintext highlighter-rouge">exit_to_usermode_loop</code>, which contains the following:</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">exit_to_usermode_loop</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cached_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Some code omitted here */</span>
        
		<span class="cm">/* deal with pending signal delivery!! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cached_flags</span> <span class="o">&amp;</span> <span class="n">_TIF_SIGPENDING</span><span class="p">)</span>
			<span class="n">do_signal</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
        
		<span class="cm">/* other code omitted here */</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
          <li>inside <code class="language-plaintext highlighter-rouge">do_signal</code>, first we call <code class="language-plaintext highlighter-rouge">bool get_signal(struct ksignal *ksig)</code></li>
          <li>if you have <code class="language-plaintext highlighter-rouge">SIGKILL</code>, then it will go into <code class="language-plaintext highlighter-rouge">do_group_exit()</code></li>
          <li>then it does <code class="language-plaintext highlighter-rouge">void __noreturn do_exit(long code)</code>. This is also what the <strong><code class="language-plaintext highlighter-rouge">exit()</code> system call does in the end</strong>
            <ul>
              <li>in addition to clean ups and exiting, it also <em>sets the process</em> <code class="language-plaintext highlighter-rouge">tsk-&gt;exit_state = EXIT_ZOMBIE;</code></li>
              <li>then there is the ` do_task_dead(void)<code class="language-plaintext highlighter-rouge">, which calls </code>__schedule(false);` to <strong>tell the OS to schedule another task</strong> to do some work, since this task is dead</li>
            </ul>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p><strong>Note:</strong></p>

  <ul>
    <li>In step 4 of the above, we see that if the process is <em>still blocked</em> and cannot get back to <code class="language-plaintext highlighter-rouge">RUNNABLE-&gt;RUNNING</code>, then the process <em>cannot process its signal</em>, hence pressing <code class="language-plaintext highlighter-rouge">Ctrl-C</code> will <strong>not exit it</strong>.</li>
  </ul>
</blockquote>

<p>Lastly, <strong>how does the OS implement the <code class="language-plaintext highlighter-rouge">wait()</code> functionality for zombies?</strong></p>

<ul>
  <li>under the cover, it uses the <code class="language-plaintext highlighter-rouge">wait4()</code> function in <code class="language-plaintext highlighter-rouge">kernel/exit.c</code>
    <ol>
      <li>this calls <code class="language-plaintext highlighter-rouge">kernel_wait_4</code>, which eventually <strong>calls</strong> <code class="language-plaintext highlighter-rouge">do_wait()</code></li>
      <li>which <strong>calls</strong> <code class="language-plaintext highlighter-rouge">do_wait_thread()</code></li>
      <li>which <strong>calls</strong> <code class="language-plaintext highlighter-rouge">wait_consider_task()</code></li>
      <li>if the task has <em>exit state being a <code class="language-plaintext highlighter-rouge">Zombie</code></em>, then it <strong>calls</strong> <code class="language-plaintext highlighter-rouge">wait_task_zombie()</code>
        <ul>
          <li>this changes the state to <code class="language-plaintext highlighter-rouge">EXIT_DEAD</code></li>
          <li>then it <strong>calls</strong><code class="language-plaintext highlighter-rouge">release_task()</code>. At this state, <strong>everything is cleaned up</strong> for the task and it is gone</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h4 id="shared-memory">Shared Memory</h4>

<p>In short, there APIs for a program to share memory, but it is difficult to use</p>

<ul>
  <li>as a result, a solution is to use <strong>threads</strong>, which has the default behavior of <strong>shared heap/data</strong></li>
  <li>therefore, it is <em>much more easier to use <strong>threads</strong></em> for shared memory</li>
</ul>

<h2 id="threads-and-cores">Threads and Cores</h2>

<p><strong>Cores</strong></p>

<ul>
  <li>each <strong>core</strong> appears as a separate <em>processor</em> to the OS
    <ul>
      <li>so with 4-cores, you can execute 4-threads in <em>parallel</em></li>
      <li>with 1-core, you can execute 4-threads <em>concurrently</em> (by interleaving)</li>
    </ul>
  </li>
</ul>

<p><strong>Threads</strong></p>

<ul>
  <li>
    <p>a <strong>thread</strong> is a part of a <em>process</em>, and is like a <em>virtual CPU</em> for the programmer</p>
  </li>
  <li>
    <p>a thread provides <strong>better code/data/file sharing between other threads</strong>, which is much more efficient than the <em>message passing/memory sharing</em> technique between processes</p>

    <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-30_14-14-21.png" style="zoom:150%;" /></p>
  </li>
</ul>

<blockquote>
  <p><strong>A Thread is:</strong></p>

  <ul>
    <li>basically an <em>independent thread of execution, so that you can <strong>execute</strong> stuff</em></li>
  </ul>

  <p><strong>A Thread contains:</strong></p>

  <ul>
    <li>
      <p>CPU Registers such as <code class="language-plaintext highlighter-rouge">PC</code>, <code class="language-plaintext highlighter-rouge">SP</code>, <code class="language-plaintext highlighter-rouge">GPR</code>, etc (<em>separated</em>)</p>
    </li>
    <li>
      <p>Stack (<em>separated</em>)</p>
    </li>
    <li>
      <p>Other Memories (e.g. heap) is <em>shared</em></p>

      <ul>
        <li>so you basically have the <em>same address space</em></li>
      </ul>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-04_12-05-39.png" style="zoom: 50%;" /></p>

      <p>where:</p>

      <ul>
        <li>in the end there is just <strong>one address space for those threads</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="multithreading-models">Multithreading Models</h3>

<p>In real life, the threading happens as follows/is <em>implemented</em> as follows:</p>

<ul>
  <li><strong>user thread</strong> - the user controllable/programmable thread.
    <ul>
      <li>The <em>kernel does NOT know about them</em>. This means they are by default belonging to a <em>single process</em>.</li>
      <li>this means for multithreading to actually occur, you need to <em>create/manage copies of the processes</em></li>
    </ul>
  </li>
  <li><strong>kernel thread</strong> - managed by the OS, hence manages user threads
    <ul>
      <li>your OS knows about them, so if one thread gets a <code class="language-plaintext highlighter-rouge">SEGFAULT</code> for example, then <em>only that thread will die</em>, but not other kernel threads</li>
      <li>if your OS <em>has</em> kernel threads, then this could lead a <em>user thread</em> maps to a <em>kernel thread</em> for actual execution.</li>
    </ul>
  </li>
</ul>

<p>For <em>mapping user thread to kernel thread</em>, there are the following possibilities:</p>

<ul>
  <li>
    <p><strong>one to one model</strong></p>

    <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-30_14-29-29.png" /></p>

    <p>currently used by many OS.</p>

    <ul>
      <li><em>Disadvantage:</em> creating a user thread means also needing to create a kernel thread, which is some overhead</li>
    </ul>
  </li>
  <li>
    <p><strong>many to one model</strong></p>

    <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-30_14-30-55.png" alt="" /></p>

    <ul>
      <li><em>Disadvantage</em>: no parallelism, only concurrency. Also, if one thread invoked a blocking system call, <em>all the rest of the threads are blocked as well</em>.</li>
    </ul>
  </li>
  <li>
    <p><strong>many to many model</strong></p>

    <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-30_14-32-27.png" alt="" /></p>
  </li>
</ul>

<h3 id="linux-implementation-of-threads">Linux Implementation of Threads</h3>

<p>In Linux, a thread is represented as the <strong>same as a <code class="language-plaintext highlighter-rouge">process</code></strong>:</p>

<ul>
  <li>
    <p>it is <code class="language-plaintext highlighter-rouge">struct task_struct</code></p>
  </li>
  <li>
    <p>the only difference would be the <code class="language-plaintext highlighter-rouge">memory space</code> of a <code class="language-plaintext highlighter-rouge">task_struct</code>, which would be <em>shared for threads</em></p>
  </li>
  <li>
    <p>a common function to use would be <code class="language-plaintext highlighter-rouge">clone()</code></p>

    <ul>
      <li>
        <p>using <code class="language-plaintext highlighter-rouge">CLONE_VM</code> flag, then threads will <em>share their memory/address space</em></p>
      </li>
      <li>
        <p>using <code class="language-plaintext highlighter-rouge">CLONE_THREAD</code> flag, then threads are grouped together, hence associated to a <em>single process</em></p>
      </li>
      <li>
        <p>for example:</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define CSIGNAL		0x000000ff	</span><span class="cm">/* signal mask to be sent at exit */</span><span class="cp">
#define CLONE_VM	0x00000100	</span><span class="cm">/* set if VM shared between processes */</span><span class="cp">
#define CLONE_FS	0x00000200	</span><span class="cm">/* set if fs info shared between processes */</span><span class="cp">
#define CLONE_FILES	0x00000400	</span><span class="cm">/* set if open files shared between processes */</span><span class="cp">
#define CLONE_SIGHAND	0x00000800	</span><span class="cm">/* set if signal handlers and blocked signals shared */</span><span class="cp">
</span><span class="cm">/* etc. */</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
    <span class="cm">/* stuff omitted */</span>
	<span class="k">struct</span> <span class="n">mm_struct</span>		<span class="o">*</span><span class="n">mm</span><span class="p">;</span> <span class="cm">/* address apce */</span>
	<span class="k">struct</span> <span class="n">mm_struct</span>		<span class="o">*</span><span class="n">active_mm</span><span class="p">;</span>
    <span class="cm">/* stuff omitted */</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="forking-implementation">Forking Implementation</h5>

<blockquote>
  <p><strong>Forking</strong></p>

  <ul>
    <li>The behavior for a <em>thread of a process</em> to <code class="language-plaintext highlighter-rouge">fork()</code> is defined as follows:
      <ul>
        <li>it will copy the <em>thread</em> itself, and allocating a separate memory address</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>What happens exactly is:</p>

<ol>
  <li>
    <p>A <em>thread</em> calls <code class="language-plaintext highlighter-rouge">__do_fork()</code>, which calls <code class="language-plaintext highlighter-rouge">copy_process()</code></p>

    <ul>
      <li>remember that a thread and a process to Linux are the same, i.e. <code class="language-plaintext highlighter-rouge">struct task_struct</code></li>
    </ul>
  </li>
  <li>
    <p>inside the <code class="language-plaintext highlighter-rouge">copy_process()</code>, it</p>

    <ul>
      <li>creates/allocates a new <code class="language-plaintext highlighter-rouge">task_struct</code></li>
      <li>initializes some fields</li>
      <li>copies information from the previous process, such as <code class="language-plaintext highlighter-rouge">copy_mm()</code></li>
    </ul>
  </li>
  <li>
    <p>for example, inside <code class="language-plaintext highlighter-rouge">copy_mm()</code>, if we have set <code class="language-plaintext highlighter-rouge">CLONE_VM</code>:</p>

    <ul>
      <li>
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_mm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">){</span>
    <span class="cm">/* bunch of codes omitted */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_VM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mmget</span><span class="p">(</span><span class="n">oldmm</span><span class="p">);</span>
		<span class="n">mm</span> <span class="o">=</span> <span class="n">oldmm</span><span class="p">;</span> <span class="cm">/* shared address space */</span>
		<span class="k">goto</span> <span class="n">good_mm</span><span class="p">;</span>
	<span class="p">}</span>
     
    <span class="cm">/* otherwise, a separate address space */</span>
    <span class="n">mm</span> <span class="o">=</span> <span class="n">dup_mm</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>additionally. with <code class="language-plaintext highlighter-rouge">CLONE_THREAD</code>:</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_THREAD</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="cm">/* adds the group leader */</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">tgid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_PARENT</span><span class="p">)</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">exit_signal</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_signal</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">exit_signal</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">group_leader</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">tgid</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p><strong>Group Leader</strong></p>

  <ul>
    <li><em>By default</em>, each thread/process is its <em>own group leader</em>
      <ul>
        <li>in the end, added to a new <code class="language-plaintext highlighter-rouge">thread_group</code> of the group leader being itself</li>
        <li>e.g. if you <code class="language-plaintext highlighter-rouge">fork()</code>, you are creating a new process/thread, so the new guy will be its own group leader</li>
      </ul>
    </li>
    <li>If you <code class="language-plaintext highlighter-rouge">clone()</code> and configured <code class="language-plaintext highlighter-rouge">CLONE_THREAD</code>, then the new guy will have the <em>calling thread’s group leader</em> as the group leader
      <ul>
        <li>in the end, added to the existing <code class="language-plaintext highlighter-rouge">thread_group</code></li>
        <li>this also populates <code class="language-plaintext highlighter-rouge">sibling</code> and <code class="language-plaintext highlighter-rouge">real_parent</code> and etc.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="threading-apis">Threading APIs</h3>

<p>Some threading APIs are implemented on the <strong>kernel level</strong> (results directly in system calls), whereas some are implemented on the <strong>user level</strong>.</p>

<p><em>For example</em>, consider the task of calculating:
\(\sum_{i=1}^n i\)</p>

<ol>
  <li><strong>POSIX Pthread</strong></li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="n">sum</span><span class="p">;</span> <span class="cm">/* this data is shared by the thread(s) */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">runner</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">);</span> <span class="cm">/* threads call this function */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">pthread</span> <span class="n">t</span> <span class="n">tid</span><span class="p">;</span> <span class="cm">/* the thread identifier */</span>
	<span class="n">pthread</span> <span class="n">attr</span> <span class="n">t</span> <span class="n">attr</span><span class="p">;</span> <span class="cm">/* set of thread attributes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"usage: a.out &lt;integer value&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"%d must be &gt;= 0</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* get the default attributes */</span>
	<span class="n">pthread</span> <span class="n">attr</span> <span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
	<span class="cm">/* create the thread */</span>
	<span class="n">pthread</span> <span class="n">create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span><span class="n">runner</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="cm">/* wait for the thread to exit */</span>
	<span class="n">pthread</span> <span class="n">join</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"sum = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* The thread will begin control in this function */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">runner</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
	<span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">pthread</span> <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<blockquote>
  <p><strong>Note</strong>:</p>

  <ul>
    <li>
      <p>to join multiple threads, use a <code class="language-plaintext highlighter-rouge">for</code> loop:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define NUM THREADS 10
</span><span class="cm">/* an array of threads to be joined upon */</span>
<span class="n">pthread</span> <span class="n">t</span> <span class="n">workers</span><span class="p">[</span><span class="n">NUM</span> <span class="n">THREADS</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM</span> <span class="n">THREADS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="n">pthread</span> <span class="nf">join</span><span class="p">(</span><span class="n">workers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div>      </div>
    </li>
  </ul>
</blockquote>

<ol>
  <li><strong>Windows Threads</strong></li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="n">DWORD</span> <span class="n">Sum</span><span class="p">;</span> <span class="cm">/* data is shared by the thread(s) */</span>
<span class="cm">/* the thread runs in this separate function */</span>
<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">Summation</span><span class="p">(</span><span class="n">LPVOID</span> <span class="n">Param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">Upper</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">Param</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">Upper</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">Sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">ThreadId</span><span class="p">;</span>
	<span class="n">HANDLE</span> <span class="n">ThreadHandle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">Param</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"An integer parameter is required</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">Param</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Param</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">"An integer &gt;= 0 is required</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* create the thread */</span>
	<span class="n">ThreadHandle</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="cm">/* default security attributes */</span>
			<span class="mi">0</span><span class="p">,</span> <span class="cm">/* default stack size */</span>
			<span class="n">Summation</span><span class="p">,</span> <span class="cm">/* thread function */</span>
			<span class="o">&amp;</span><span class="n">Param</span><span class="p">,</span> <span class="cm">/* parameter to thread function */</span>
			<span class="mi">0</span><span class="p">,</span> <span class="cm">/* default creation flags */</span>
			<span class="o">&amp;</span><span class="n">ThreadId</span><span class="p">);</span> <span class="cm">/* returns the thread identifier */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ThreadHandle</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* now wait for the thread to finish */</span>
		<span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">ThreadHandle</span><span class="p">,</span><span class="n">INFINITE</span><span class="p">);</span>
		<span class="cm">/* close the thread handle */</span>
		<span class="n">CloseHandle</span><span class="p">(</span><span class="n">ThreadHandle</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"sum = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">Sum</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>
    <p><strong>Java Threading</strong></p>

    <p>Since Java does not have a <em>global variable</em>, it uses <em>objects in Heap</em> to share data (<em>you need to pass the object into the thread</em>)</p>
  </li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Sum</span>
<span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">sum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Summation</span> <span class="kd">implements</span> <span class="nc">Runnable</span>
<span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">upper</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">Sum</span> <span class="n">sumValue</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nf">Summation</span><span class="o">(</span><span class="kt">int</span> <span class="n">upper</span><span class="o">,</span> <span class="nc">Sum</span> <span class="n">sumValue</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">sumValue</span> <span class="o">=</span> <span class="n">sumValue</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
			<span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
		<span class="n">sumValue</span><span class="o">.</span><span class="na">setSum</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Driver</span>
<span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">" must be &gt;= 0."</span><span class="o">);</span>
			<span class="k">else</span> <span class="o">{</span>
				<span class="nc">Sum</span> <span class="n">sumObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Sum</span><span class="o">();</span>
				<span class="kt">int</span> <span class="n">upper</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
				<span class="nc">Thread</span> <span class="n">thrd</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Summation</span><span class="o">(</span><span class="n">upper</span><span class="o">,</span> <span class="n">sumObject</span><span class="o">));</span>
				<span class="n">thrd</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
				<span class="k">try</span> <span class="o">{</span>
					<span class="n">thrd</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
					<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span>
						<span class="o">(</span><span class="s">"The sum of "</span><span class="o">+</span><span class="n">upper</span><span class="o">+</span><span class="s">" is "</span><span class="o">+</span><span class="n">sumObject</span><span class="o">.</span><span class="na">getSum</span><span class="o">());</span>
				<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">ie</span><span class="o">)</span> <span class="o">{</span> <span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">else</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Usage: Summation &lt;integer value&gt;"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>
      <p>There are two techniques for creating threads in a <strong>Java</strong> program.</p>

      <ul>
        <li>
          <p>One approach is to create a new class that is derived from the <code class="language-plaintext highlighter-rouge">Thread</code> class and to override its <code class="language-plaintext highlighter-rouge">run()</code> method.</p>
        </li>
        <li>
          <p>An alternative —and more commonly used— technique is to define a class that <em>implements</em> the <code class="language-plaintext highlighter-rouge">Runnable</code> interface. The
<code class="language-plaintext highlighter-rouge">Runnable</code> interface is defined as follows:</p>

          <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Runnable</span>
<span class="o">{</span>
	<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>          </div>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="thread-pools">Thread Pools</h3>

<p>The problem with the above essentially free threading is:</p>

<ul>
  <li>
    <p><em>Creation</em> of each thread takes some time</p>
  </li>
  <li>
    <p>Unlimited threads could <em>exhaust</em> system resources, such as CPU time or memory.</p>
  </li>
</ul>

<p>One solution to this problem is to use a <strong>thread pool.</strong></p>

<ul>
  <li>The general idea behind a thread pool is to create a number of threads at process startup and place them into a pool, where they sit and wait for work.
    <ul>
      <li>When a server receives a request, it <em>awakens a thread from this pool</em>—if one is available—and passes it the request for service.</li>
      <li>Once the thread completes its service, it <em>returns to the pool and awaits more work</em>.</li>
      <li>If the pool contains no available thread, the <em>server waits until one becomes free</em>.</li>
    </ul>
  </li>
</ul>

<h2 id="os-control">OS Control</h2>

<p>In the following situations, the <strong>OS takes control</strong> (i.e. OS code runs, including interrupt handler codes)</p>

<ol>
  <li>On <strong>boot</strong> time</li>
  <li>When <strong>Interrupt</strong> occurs
    <ul>
      <li>also <strong>Exceptions</strong></li>
    </ul>
  </li>
  <li>Dealing with <strong>Main Memory</strong>
    <ul>
      <li>e.g. setting your program address space to use <code class="language-plaintext highlighter-rouge">addr</code> within $base \le addr \le limit$</li>
    </ul>
  </li>
  <li><strong>System Calls</strong> (API for outside users, a <em>way to enter the kernel</em>)
    <ul>
      <li>e.g. by using a software interrupt, so that OS can take control in between your program
        <ul>
          <li>jumps to interrupt handler to handle it (OS code)</li>
        </ul>
      </li>
      <li>e.g. implements using a <em>special</em> <code class="language-plaintext highlighter-rouge">syscall</code> instruction</li>
    </ul>
  </li>
  <li>CPU <strong>modes</strong> (e.g. kernel mode)
    <ul>
      <li>dealing with <em>security</em></li>
    </ul>
  </li>
</ol>

<h2 id="kernel">Kernel</h2>

<blockquote>
  <p><strong>Relationship between OS and Kernel</strong></p>

  <table>
    <thead>
      <tr>
        <th style="text-align: left">Operating System</th>
        <th style="text-align: left">Kernel</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="text-align: left">Operating System is a system software.</td>
        <td style="text-align: left">Kernel is system software which is <em>part of</em> operating system.</td>
      </tr>
      <tr>
        <td style="text-align: left">Operating System provides interface b/w <em>user and hardware</em>.</td>
        <td style="text-align: left">kernel provides interface b/w <em>application and hardware</em>.</td>
      </tr>
      <tr>
        <td style="text-align: left">It also provides protection and security.</td>
        <td style="text-align: left">It’s main purpose is <em>memory management, disk management, process management and task management</em>.</td>
      </tr>
      <tr>
        <td style="text-align: left">All system needs operating system to run.</td>
        <td style="text-align: left">All operating system needs kernel to run.</td>
      </tr>
      <tr>
        <td style="text-align: left">Type of operating system includes single and multiuser OS, multiprocessor OS, real-time OS, Distributed OS.</td>
        <td style="text-align: left">Type of kernel includes Monolithic and Micro kernel.</td>
      </tr>
      <tr>
        <td style="text-align: left">It is the first program to load when computer boots up.</td>
        <td style="text-align: left">It is the first program to load when <em>operating system loads</em>.</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<blockquote>
  <p><em>Reminder:</em></p>

  <ul>
    <li>
      <p>The Linux Kernel is the first thing that your OS loads:</p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-20_23-39-08.png" alt="" /></p>
    </li>
    <li>
      <p><em>System calls</em> provide userland processes a way to <em>request services from the kernel</em>. Those services are managed by operating system like storage, memory, network, process management etc.</p>

      <ul>
        <li>For example if a user process wants to read a file, it will have to make <code class="language-plaintext highlighter-rouge">open</code> and <code class="language-plaintext highlighter-rouge">rea</code> system calls. Generally system calls are not called by processes directly. <em>C library provides an interface to all system calls</em>.</li>
      </ul>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-13_21-55-33.png" style="zoom:50%;" /></p>
    </li>
  </ul>
</blockquote>

<p><strong>Kernel</strong> has a hardware dependent part and a hardware-independent part. Codes on this site: https://elixir.bootlin.com/linux/v5.10.10/source contains:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">arch/x86/boot</code> - first codes to be executed
    <ul>
      <li>initializes keyboard, heap, etc, then starts the <code class="language-plaintext highlighter-rouge">init</code> program</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">arch/x86/entry</code> contains system call codes
    <ul>
      <li>remember, user calling system call = stopping current process and <em>switching/entering to OS control</em></li>
    </ul>
  </li>
</ul>

<h3 id="kernel-system-calls">Kernel System Calls</h3>

<blockquote>
  <p><strong>What Happens when a process execute system call?</strong></p>

  <ul>
    <li>
      <p>Basically, the following graph:</p>

      <p><img src="https://qph.fs.quoracdn.net/main-qimg-0cb5c3a6e1fd7642ac988badc7598c0c" alt="https://qph.fs.quoracdn.net/main-qimg-0cb5c3a6e1fd7642ac988badc7598c0c" style="zoom:80%;" /></p>

      <p>in words, the following happened:</p>

      <ol>
        <li>Application program makes a system call by invoking <em>wrapper function</em> in C library</li>
        <li>This wrapper functions makes sure that all the <em>system call arguments are available to trap-handling routine</em>
          <ul>
            <li>the wrapper function also takes care of copying these arguments to specific <em>registers</em></li>
            <li>The wrapper function again <em>copies the system call number</em> (of itself) into specific CPU registers</li>
          </ul>
        </li>
        <li>Now the wrapper function executes <em>trap</em> instruction (int 0x80). This instruction causes the processor to switch from <em>‘User Mode’</em> to <em>‘Kernel Mode’</em></li>
        <li>The <em>code pointed out by location 0x80</em> is executed (Most modern machines use <code class="language-plaintext highlighter-rouge">sysenter</code> rather than 0x80 trap instruction)</li>
        <li>In response to trap to location 0x80, kernel invokes <code class="language-plaintext highlighter-rouge">system_call()</code> routine which is located in assembler file <code class="language-plaintext highlighter-rouge">arch/i386/entry.S</code></li>
        <li>the rest is covered below.</li>
      </ol>
    </li>
  </ul>
</blockquote>

<p>How does the <strong>kernel implement/deal with system calls</strong>? (reference: http://articles.manugarg.com/systemcallinlinux2_6.html)</p>

<ul>
  <li>You need to first get into Kernel</li>
  <li>Then locate that system call</li>
  <li>Run that system call</li>
</ul>

<blockquote>
  <p><strong>In the past:</strong></p>

  <ul>
    <li>Linux used to implement system calls on all x86 platforms using <em>software interrupts</em>.</li>
    <li>To execute a system call, user process will <em>copy desired system call number</em> to <code class="language-plaintext highlighter-rouge">%eax</code> and will execute ‘int 0x80’. This will generate interrupt <code class="language-plaintext highlighter-rouge">0x80</code> and an interrupt service routine will be called.
      <ul>
        <li>For interrupt 0x80, this routine is an “all system calls handling” routine. This routine will execute in ring 0 (privileged mode). This routine, as defined in the file <code class="language-plaintext highlighter-rouge">/usr/src/linux/arch/i386/kernel/entry.S</code>, will <em>save the current state and call appropriate system call handler</em> based on the value in <code class="language-plaintext highlighter-rouge">%eax</code>.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><strong>For Modern x86</strong>, there is a <em>specific SYSCALL instruction</em></p>

<ol>
  <li>
    <p>Inside <code class="language-plaintext highlighter-rouge">arch/x86/entry/entry.S</code></p>

    <ul>
      <li>
        <p><strong>SYSYCALL begins/enters</strong> via the line <code class="language-plaintext highlighter-rouge">ENTRY(entry_SYSCALL_64)</code>,</p>

        <p>where:</p>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">entry_SYSCALL_64</code> contains/is initialized with an <em>address</em> to the actual function of <code class="language-plaintext highlighter-rouge">entry_SYSCALL_64</code></li>
          <li>it can take <strong>up to 6 arguments/6 registers</strong></li>
        </ul>

        <p>and after entering, it <em>needs</em></p>

        <ul>
          <li>a <em>register</em> containing <em>address of the implemented SYSCALL code</em></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Inside the <code class="language-plaintext highlighter-rouge">ENTRY(entry_SYSCALL_64)</code></p>

    <ul>
      <li>
        <p>after a bunch of stack savings, it <strong>does</strong> <code class="language-plaintext highlighter-rouge">do_syscall_64</code></p>

        <p>where:</p>

        <ul>
          <li>this is when the <em>actual code is executed</em></li>
          <li><code class="language-plaintext highlighter-rouge">do_syscall_64</code> again points to an address of the <em>C function</em> <code class="language-plaintext highlighter-rouge">do_syscall_64(nr, *regs)</code>, with
            <ul>
              <li><code class="language-plaintext highlighter-rouge">nr</code> would <em>represent the <code class="language-plaintext highlighter-rouge">id</code> for each system call</em></li>
              <li><code class="language-plaintext highlighter-rouge">*regs</code> would contain the <em>arguments for the system call</em></li>
              <li>similar to interrupt handler table, <em>there is a “table” for SYSCALL</em> <code class="language-plaintext highlighter-rouge">asm/syscalls_64.h</code> which is generated by <code class="language-plaintext highlighter-rouge">arch/x86/entry/syscalls/sysycall_64.tbl</code> <strong>dynamically depending on the hardware spec</strong>
                <ul>
                  <li>for example, one line inside the <code class="language-plaintext highlighter-rouge">tbl</code> has <code class="language-plaintext highlighter-rouge">0	common	read	__x64_sys_read</code></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <p>some code there does:</p>

        <ul>
          <li>check <code class="language-plaintext highlighter-rouge">nr</code> being a <em>legal system call number in the table</em> <code class="language-plaintext highlighter-rouge">sys_call_table</code></li>
          <li><strong>runs</strong> that system call with <code class="language-plaintext highlighter-rouge">sys_call_table[nr](regs)</code>, where <code class="language-plaintext highlighter-rouge">sys_call_table[nr]</code> would basically be a <em>function</em></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Inside <code class="language-plaintext highlighter-rouge">include/linux/syscalls.h</code></p>

    <ul>
      <li>you can find the actual <em>definition of SYSCALL</em> in C, which can be used to find the actual implementation
        <ul>
          <li>for example, <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINE0</code> <strong>wrapper</strong> for functions that takes <code class="language-plaintext highlighter-rouge">0</code> arguments, <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINE1</code>, …, up to <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINE6</code></li>
          <li>for example, <code class="language-plaintext highlighter-rouge">sys_read()</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Inside <code class="language-plaintext highlighter-rouge">kernel/sys.c</code></p>

    <ul>
      <li>you can find the actual <em>implementations of SYSCALL</em> in C
        <ul>
          <li>for example, <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINE0(getpid)</code>, which will get translated to <code class="language-plaintext highlighter-rouge">__x64_sys_getpid</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">sys_read()</code> would be converted <em>dynamically</em> to <code class="language-plaintext highlighter-rouge">__x64_sys_read</code> by using <code class="language-plaintext highlighter-rouge">#defines</code> which basically <em>adds a wrapper <code class="language-plaintext highlighter-rouge">__x86</code>to the functions</em>
      <ul>
        <li>this is configured by the <code class="language-plaintext highlighter-rouge">Kconfig</code> file, and the wrapper is defined at <code class="language-plaintext highlighter-rouge">arch/x86/include/asm/syscall_wrapper.h</code></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>In the View of a Programmer</strong></p>

  <ul>
    <li>
      <p>this is what happens in the virtual memory space:</p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-01-28_09-55-25.png" style="zoom:50%;" /></p>

      <p>where:</p>

      <ul>
        <li>every process has a <em>separate/independent user space</em>, but a <em>shared kernel space</em> for system calls (the kernel image is loaded there as well).</li>
        <li><strong>this also means the stack for system call is very limited</strong>. So you should <em>not write recursion functions for system calls</em>.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="system-call-example">System Call Example</h4>

<p>Consider the function <code class="language-plaintext highlighter-rouge">gettimeofday</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">gettimeofday</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tv</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">timezone</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">tv</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timespec64</span> <span class="n">ts</span><span class="p">;</span>

		<span class="n">ktime_get_real_ts64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">put_user</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_usec</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tz</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sys_tz</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sys_tz</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li><strong>user arguments</strong> comes in like <code class="language-plaintext highlighter-rouge">struct timeval __user *, tv</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">__user</code> denotes that the pointer comes from user space</li>
      <li><code class="language-plaintext highlighter-rouge">tv</code> is the variable name</li>
    </ul>
  </li>
  <li>
    <p>since the <strong>variables</strong> comes from <em>user space</em>, we need to be careful of its <em>validity</em>:</p>

    <ul>
      <li>
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">timespec64</span> <span class="n">ts</span><span class="p">;</span>
    
<span class="n">ktime_get_real_ts64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">||</span>
    <span class="n">put_user</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_usec</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
</code></pre></div>        </div>

        <p>where we basically create our own structure and <em>copied fields to user’s variable</em> with <code class="language-plaintext highlighter-rouge">put_user()</code></p>
      </li>
    </ul>
  </li>
  <li>the <strong>error</strong> that system call returns is <em>not directly <code class="language-plaintext highlighter-rouge">-1</code></em>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">return -EFAULT;</code></li>
      <li>and then a wrapper will <em>populate the error information and then <code class="language-plaintext highlighter-rouge">return -1</code></em></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>In general, there is <em>no explicit check done</em> by the OS on the number of arguments you passed in for a system call. This means that <em>all you should check in your function</em> are the validity of the arguments you <strong>need</strong>.</li>
  </ul>
</blockquote>

<p>More details on <code class="language-plaintext highlighter-rouge">copy_to_user</code> and the other ones:</p>

<blockquote>
  <p><strong>Copy Data to/from Kernel</strong></p>

  <table>
    <thead>
      <tr>
        <th><strong>Function</strong></th>
        <th><strong>Description</strong></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code class="language-plaintext highlighter-rouge">copy_from_user(to, from, n)</code> _copy_from_user</td>
        <td>Copies a string of n bytes from from (userspace) to to (kernel space).</td>
      </tr>
      <tr>
        <td><code class="language-plaintext highlighter-rouge">get_user(type *to, type* ptr)</code> _get_user</td>
        <td>Reads a simple variable (char, long, … ) from ptr to to; depending on pointer type, the kernel decides automatically to transfer 1, 2, 4, or 8 bytes.</td>
      </tr>
      <tr>
        <td><code class="language-plaintext highlighter-rouge">put_user(type *from, type *to)</code> _put_user</td>
        <td>Copies a simple value from from (kernel space) to to (userspace); the relevant value is determined automatically from the pointer type passed.</td>
      </tr>
      <tr>
        <td><code class="language-plaintext highlighter-rouge">copy_to_user(to, from, n)</code> _copy_to_user</td>
        <td>Copies n bytes from from (kernel space) to to (userspace).</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h1 id="week-5">Week 5</h1>

<h2 id="process-synchronization">Process Synchronization</h2>

<blockquote>
  <p><em>Reminder</em>:</p>

  <ul>
    <li>Cooperating processes can either directly share a logical address space (that is, both code and data) or be allowed to share data only through files or messages.
      <ul>
        <li>The former case is achieved through the use of <strong>threads</strong> (see <a href="#Threads-and-Cores">Threads and Cores</a></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>This chapter addresses how <strong>concurrent or parallel execution</strong> can contribute to <strong>issues</strong> involving the <strong>integrity of data shared</strong> by several processes.</p>

<h3 id="race-condition-and-lock">Race Condition and Lock</h3>

<p>Consider the case (<strong>thread race</strong>):</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-04_13-36-40.png" style="zoom: 67%;" /></p>

<p>the result has the following possibility:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1</code>, if <code class="language-plaintext highlighter-rouge">T1/T2</code> loads <code class="language-plaintext highlighter-rouge">x=0</code> into register, and <code class="language-plaintext highlighter-rouge">T1</code> writes <em>later</em> than <code class="language-plaintext highlighter-rouge">T2</code> back to the memory</li>
  <li><code class="language-plaintext highlighter-rouge">0</code>, if <code class="language-plaintext highlighter-rouge">T1</code> loads <code class="language-plaintext highlighter-rouge">x=0</code> into register, and writes back to the memory, and <em>then</em> <code class="language-plaintext highlighter-rouge">T2</code> loads and writes back</li>
  <li><code class="language-plaintext highlighter-rouge">-1</code>, if <code class="language-plaintext highlighter-rouge">T1/T2</code> loads <code class="language-plaintext highlighter-rouge">x=0</code> into register, and <code class="language-plaintext highlighter-rouge">T2</code> writes <em>later</em> than <code class="language-plaintext highlighter-rouge">T1</code> back to the memory</li>
</ul>

<blockquote>
  <p><strong>This is the problem of none-Atomic operations</strong></p>

  <ul>
    <li>so that the actual operation in CPU has <em>multiple steps</em></li>
    <li>as a result, you have <em>ambiguity of result</em> when multiple these operations are acting on the same data</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Critical Section</strong>:</p>

  <ul>
    <li>the critical section is a segment of code that manipulates a data object, which <em>two or more concurrent threads are trying to modify</em></li>
  </ul>

</blockquote>

<p>To <em>guard against the race condition</em> above, we need to ensure that only one process at a time can be manipulating the variable. To make such a guarantee, we require that the <strong>processes be synchronized in some way</strong>.</p>

<ul>
  <li>The solution is to get a <strong>lock</strong> for the <strong>critical section</strong>:</li>
</ul>

<blockquote>
  <p><strong>Lock</strong></p>

  <ul>
    <li>
      <p>so that <em>all operations within a lock</em> will be <em>atomic/mutually exclusive</em></p>
    </li>
    <li>
      <p>a lock would have the following property:</p>

      <ol>
        <li><strong>mutual exclusion</strong> - only <em>one thread</em> can access the critical section at a time</li>
        <li><strong>forward progress</strong> - if <em>no one has the lock for the critical section</em>, I should be able to get it</li>
        <li><strong>bounded waiting</strong> - there can’t be an <em>indefinite wait</em> for getting a lock for the critical section</li>
      </ol>
    </li>
    <li>
      <p><em>for example</em>, to make <code class="language-plaintext highlighter-rouge">x++</code> atomic with locks:</p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-04_13-27-33.png" style="zoom: 33%;" /></p>
    </li>
  </ul>
</blockquote>

<p>In general, this is what we need to do:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-08_20-29-22.png" style="zoom: 67%;" /></p>

<p>This is actually very important if you have <em>multiprocessor CPUs</em>:</p>

<ul>
  <li>since <em>multiple processes can be in the kernel</em> in this case (e.g. calling system calls), they could be <em>manipulating some same kernel data</em>.</li>
  <li>therefore, you need to find a way to lock stuff.</li>
</ul>

<h3 id="petersons-solution">Peterson’s Solution</h3>

<p>This is a <em>heuristic</em> solution that:</p>

<ul>
  <li>demonstrates the idea of a <em>lock</em></li>
  <li>only works for <em>two processes</em></li>
  <li>not guaranteed to work on <em>modern</em> computer architectures.</li>
</ul>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-08_23-22-27.png" alt="" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">i</code> represents <code class="language-plaintext highlighter-rouge">Process i</code> = <code class="language-plaintext highlighter-rouge">Process 0</code></li>
  <li><code class="language-plaintext highlighter-rouge">j</code> represents <code class="language-plaintext highlighter-rouge">Process j</code> = <code class="language-plaintext highlighter-rouge">Process 1</code></li>
</ul>

<p>and that:</p>

<ul>
  <li>Mutual exclusion is preserved.
    <ul>
      <li>$P_0$ and and $P_1$ <em>could not have</em> successfully executed their statements <em>at about the same time</em>
    2. The progress requirement is satisfied.</li>
    </ul>
  </li>
  <li>The bounded-waiting requirement is met.
    <ol>
      <li>There is a bounded waiting, since if one process $P_0=P_i$ is stuck in the loop, the process can get out either by $P_1=P_j$ setting the <code class="language-plaintext highlighter-rouge">flag[j] = false</code> <em>after execution</em> or setting <code class="language-plaintext highlighter-rouge">turn = i</code>. Both of which guaranteed that $P_0=P_i$ will have <em>at <strong>most</strong> one wait for one loop in $P_j$</em></li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>The <strong>actual solution</strong> for 2 processes is:</p>

  <ul>
    <li><img src="\lectures\images\typora-user-images\image-20210209105226383.png" alt="image-20210209105226383" /></li>
  </ul>
</blockquote>

<h3 id="hardware-implementation">Hardware Implementation</h3>

<p>Therefore, one hardware solution to solve this would be:</p>

<ul>
  <li><strong>disable interrupts</strong>, so that once a process is in the critical section, <em>no other process can do work</em>.
    <ul>
      <li>disabling interrupt is <em>atomic itself</em></li>
    </ul>
  </li>
</ul>

<p>However, this is <strong>problematic</strong> because:</p>

<ol>
  <li>need <em>privileged instruction</em> (i.e. normal user outside kernel can’t use it directly)</li>
  <li>can only have <em>one lock</em> in the system, since interrupts are disabled for the entire CPU.</li>
  <li>if you have <em>multiple processors</em>, this does not work at all
    <ul>
      <li>need all processors to disable interrupt</li>
      <li>if process $P_0$ is running on $CPU_0$ and process $P_1$ is $CPU_1$. Disabling interrupt on both <em>does not change/interrupt what is <strong>already running</strong></em>. Therefore, both $P_0,P_1$ will be running.</li>
    </ul>
  </li>
</ol>

<p>The <strong>solution</strong> for MP (multi-processor) is <em>using</em>:</p>

<ul>
  <li>
    <p><strong>test-and-set</strong> (<em>ensured by hardware to be atomic</em>)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">boolean</span> <span class="nf">test_and_set</span><span class="p">(</span><span class="n">boolean</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">boolean</span> <span class="n">rv</span> <span class="o">=</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
    <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>compare-and-swap</strong> (<em>ensured by hardware to be atomic</em>)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* this is made atomic by hardware */</span>
<span class="kt">int</span> <span class="nf">compare_and_swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">value</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span>
    	<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>and <strong>implementing</strong>:</p>

<ul>
  <li>spin locks</li>
  <li>blocking blocks</li>
</ul>

<blockquote>
  <p><strong>Note</strong>:</p>

  <ul>
    <li>under the hood, the code themselves involves more than one instruction. However, this is supported <em>natively by hardware</em>, so that this will be atomic (e.g. locking the communication channel to the main memory when you are loading).</li>
    <li><em>both</em> lock implementation are:
      <ul>
        <li>busy waiting
          <ul>
            <li>since we have the <code class="language-plaintext highlighter-rouge">while</code> loop for testing the lock</li>
          </ul>
        </li>
        <li>spin locks
          <ul>
            <li>since we have the <code class="language-plaintext highlighter-rouge">while</code> loop for waiting</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Therefore, <strong>both are problematic because spinning locks will be eating up the CPU cycles</strong> if there are lots of contentions over a lock</li>
  </ul>
</blockquote>

<h4 id="other-atomic-instructions">Other Atomic Instructions</h4>

<p>For <code class="language-plaintext highlighter-rouge">x86</code> architecture, there are actually a bunch of <strong>useful atomic instructions</strong> you can use.</p>

<p><em>For Example</em>:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">atomic_read(const atomic_t *v)</code></p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">atomic_add(int i, atomic_t *v)</code></li>
  <li>…</li>
  <li>more inside <code class="language-plaintext highlighter-rouge">include/asm-generic/atomic-instrumented.h</code></li>
</ul>

<p>Therefore for <em>simple code,</em> you can just use those atomic instructions instead of explicitly grabbing the lock.</p>

<h3 id="spin-locks">Spin Locks</h3>

<blockquote>
  <p><strong>Conventions for Using Spin Locks</strong></p>

  <ol>
    <li>
      <p>the same task that grabs the spin lock <em>should</em> also releases the spin lock</p>
    </li>
    <li>
      <p>the task that grabs the spin lock <strong>cannot</strong> <em>sleep/block</em> before releasing it</p>

      <ul>
        <li>otherwise, you might cause deadlock situations</li>
      </ul>
    </li>
    <li>
      <p>the usual usage of spin locks in code/by programs looks like:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">initialize</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="n">spin_lock</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="cm">/* some work, not sleeping/blocked */</span>
<span class="n">spin_unlock</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</code></pre></div>      </div>
    </li>
  </ol>
</blockquote>

<blockquote>
  <p><strong>Advantages of Spin Lock</strong></p>

  <ul>
    <li>No context switch is required when a process must wait on a lock (<em>as compare to a blocking lock</em>), and context switch may take considerable time.</li>
  </ul>

  <p><strong>Disadvantages of Spin Lock</strong></p>

  <ul>
    <li>Wastes much of the CPU power if a lot are running for a long time.</li>
  </ul>
</blockquote>

<h4 id="test-and-set-spin-lock">Test and Set Spin Lock</h4>

<p>Consider the case when you have a global lock of <code class="language-plaintext highlighter-rouge">boolean lock=false</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* this is made atomic by hardware */</span>
<span class="n">boolean</span> <span class="nf">test_and_set</span><span class="p">(</span><span class="n">boolean</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">boolean</span> <span class="n">rv</span> <span class="o">=</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
    <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>then the <strong>spin lock implementation/usage</strong> would be:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">))</span>
    	<span class="p">;</span> <span class="cm">/* do nothing */</span>
    
    <span class="cm">/* critical section */</span>
    
    <span class="n">lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="cm">/* remainder section */</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">test_and_set(&amp;lock)</code> basically locks it by <em>atomically</em>:
    <ul>
      <li>letting itself through if <code class="language-plaintext highlighter-rouge">lock=0</code> <strong>and</strong> assigning it to <code class="language-plaintext highlighter-rouge">lock=1</code> to lock it.</li>
    </ul>
  </li>
</ul>

<p>However, <strong>bounded-waiting</strong> is not satisfied:</p>

<ul>
  <li>consider a process that is super lucky and gets to <em>set <code class="language-plaintext highlighter-rouge">lock=1</code> every time before other processes.</em> Then all other processes will have to <strong>wait indefinitely.</strong></li>
</ul>

<h4 id="compare-and-swap-spin-lock">Compare and Swap Spin Lock</h4>

<p>Consider the case when you have a global lock of <code class="language-plaintext highlighter-rouge">int lock=0</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* this is made atomic by hardware */</span>
<span class="kt">int</span> <span class="nf">compare_and_swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">value</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span>
    	<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>then the <strong>spin lock implementation/usage</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    	<span class="p">;</span> <span class="cm">/* do nothing */</span>

    <span class="cm">/* critical section */</span>

    <span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* remainder section */</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li>the idea is that the <strong>one process will set <code class="language-plaintext highlighter-rouge">lock=1</code></strong> before it enters the critical block, so that other processes cannot enter.</li>
</ul>

<p>However, <strong>bounded-waiting</strong> is not satisfied:</p>

<ul>
  <li>consider a process that is super lucky and gets to <em>set <code class="language-plaintext highlighter-rouge">lock=1</code> every time before other processes.</em> Then all other processes will have to <strong>wait indefinitely.</strong></li>
</ul>

<h4 id="try-lock">Try Lock</h4>

<p>This is basically a lock that, instead of spinning, either:</p>

<ul>
  <li>obtains the lock</li>
  <li><strong>tries once and stop</strong></li>
</ul>

<p>Therefore, it is <em>not-spinning</em>, but technically it is not waiting either.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">int</span> <span class="nf">spin_trylock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">raw_spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="kernel-code-examples">Kernel Code Examples</h4>

<p>First, a couple of code to know:</p>

<ol>
  <li>
    <p>the declaration for <code class="language-plaintext highlighter-rouge">spin_lock()</code>  inside <code class="language-plaintext highlighter-rouge">include/linux/spinlock.h</code>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">spin_lock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* other declarations */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">spin_unlock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">rlock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>which if you dig deep into what it did:</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">spin_lock()</code> eventually calls ` __raw_spin_lock(raw_spinlock_t *lock)` and <strong>does 3 things</strong></p>

        <ol>
          <li><code class="language-plaintext highlighter-rouge">preempt_disable();</code>, so that <em>no other process can preempt/context switch this process</em> when it holds the spin lock.
            <ul>
              <li>same principle as not sleeping during holding a spin lock</li>
              <li>this has a similar effect (but not as strong) as <em>disabling interrupts</em></li>
            </ul>
          </li>
          <li>
            <p>`	spin_acquire(&amp;lock-&gt;dep_map, 0, 0, <em>RET_IP</em>);` grabs the lock</p>
          </li>
          <li>
            <p><code class="language-plaintext highlighter-rouge">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</code> <em>configures this function</em> into play:</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">queued_spin_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">qspinlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
    <span class="cm">/* which in the end is the ATOMIC compare_and_swap in ASSEMBLY CODE */</span>
    <span class="cm">/* this would happen in __raw_cmpxchg(ptr, old, new, size, lock) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">atomic_try_cmpxchg_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">_Q_LOCKED_VAL</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
        
	<span class="n">queued_spin_lock_slowpath</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ol>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">spin_unlock()</code> does the opposite three things:</p>
        <ol>
          <li><code class="language-plaintext highlighter-rouge">spin_release(&amp;lock-&gt;dep_map, 1, _RET_IP_);</code></li>
          <li><code class="language-plaintext highlighter-rouge">do_raw_spin_unlock(lock);</code></li>
          <li><code class="language-plaintext highlighter-rouge">preempt_enable();</code></li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <p>the declaration for <strong>defining your own spin lock</strong> is inside <code class="language-plaintext highlighter-rouge">include/linux/spinlock_types.h</code>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define DEFINE_SPINLOCK(x)	spinlock_t x = __SPIN_LOCK_UNLOCKED(x)
</span></code></pre></div>    </div>

    <p>which if you dig deep into what it did:</p>

    <ul>
      <li>essentially sets a <code class="language-plaintext highlighter-rouge">raw_lock</code>’s <code class="language-plaintext highlighter-rouge">counter</code> value to <code class="language-plaintext highlighter-rouge">0</code></li>
    </ul>
  </li>
  <li>
    <p>the declaration for <code class="language-plaintext highlighter-rouge">spin_lock_irq()</code> inside <code class="language-plaintext highlighter-rouge">include/linux/spinlock.h</code>:</p>

    <ul>
      <li>consider the problem that: if a process <strong>hold a spin lock <code class="language-plaintext highlighter-rouge">L</code> is interrupted</strong>, and the <strong>interrupted handler needs that lock <code class="language-plaintext highlighter-rouge">L</code> as well</strong>
        <ul>
          <li>this causes a deadlock situation, because an <em>interrupted process cannot proceed</em></li>
        </ul>
      </li>
      <li>therefore, <code class="language-plaintext highlighter-rouge">spin_lock_irq()</code> in addition <strong>disables interrupt</strong></li>
    </ul>
  </li>
  <li>
    <p>the declaration for <code class="language-plaintext highlighter-rouge">spin_lock_irq_save()</code> inside <code class="language-plaintext highlighter-rouge">include/linux/spinlock.h</code>:</p>

    <ul>
      <li>this solves the problem that if, before calling <code class="language-plaintext highlighter-rouge">spin_lock_irq</code>, the interrupt has <em>already been disabled for other processes</em>. Therefore, here you need to:
        <ol>
          <li>save the <em>previous</em> “disabled interrupt’s configuration”</li>
        </ol>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>One trick thing that you have to find out yourself is <em>which lock in Kernel to use</em>
      <ul>
        <li>for example, <code class="language-plaintext highlighter-rouge">task_list</code> has its own lock.</li>
      </ul>
    </li>
    <li>To choose between <code class="language-plaintext highlighter-rouge">spin_lock()</code> and <code class="language-plaintext highlighter-rouge">spin_lock_irq()</code>, simply think about:
      <ul>
        <li>will this lock be used by <em>Interrupt Handlers</em>? If not, use <code class="language-plaintext highlighter-rouge">spin_lock()</code> suffices.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><em>For Example</em>:</p>

<ul>
  <li>
    <p>Spin lock used in <code class="language-plaintext highlighter-rouge">/arch/parisc/mm/init.c</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">alloc_sid</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
  
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sid_lock</span><span class="p">);</span>
	<span class="cm">/* some code omitted */</span>
  
	<span class="n">index</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">space_id</span><span class="p">,</span> <span class="n">NR_SPACE_IDS</span><span class="p">,</span> <span class="n">space_id_index</span><span class="p">);</span>
	<span class="n">space_id</span><span class="p">[</span><span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="n">SHIFT_PER_LONG</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">index</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
	<span class="n">space_id_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
  
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sid_lock</span><span class="p">);</span>
  
	<span class="k">return</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">SPACEID_SHIFT</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Spin lock <em>defined and used</em></p>

    <p>defined inside <code class="language-plaintext highlighter-rouge">arch/alpha/kernel/time.c</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">rtc_lock</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>then, some other code <em>using</em> the lock:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ssize_t</span> <span class="nf">atari_nvram_read</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i</span><span class="p">;</span>
  
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__nvram_check_checksum</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NVRAM_BYTES</span><span class="p">;</span> <span class="o">--</span><span class="n">count</span><span class="p">,</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">__nvram_read_byte</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtc_lock</span><span class="p">);</span>
  
	<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="blocking-locks">Blocking Locks</h3>

<p>Instead of spin lock, we</p>

<ul>
  <li>send <em>other processes to sleep/blocked</em> when one process is doing critical work.</li>
  <li><em>wake the waiting process up</em> when the process has finished the work</li>
</ul>

<p>This implementation in Linux is called <strong>mutex, or semaphore</strong>.</p>

<ul>
  <li><em>mutex</em> may be (often is) implemented <em>using semaphore</em>.</li>
</ul>

<h4 id="blocking-semaphore">Blocking Semaphore</h4>

<p>The blocking semaphore has:</p>

<ul>
  <li>lock = <code class="language-plaintext highlighter-rouge">P(semaphore)</code> = <code class="language-plaintext highlighter-rouge">wait()</code></li>
  <li>unlock = <code class="language-plaintext highlighter-rouge">V(semaphore)</code> = <code class="language-plaintext highlighter-rouge">signal()</code></li>
</ul>

<blockquote>
  <p><strong>Idea Behind a Semaphore</strong></p>

  <ul>
    <li>
      <p>Rather than engaging in busy waiting, the process can <em>block</em> itself.</p>
    </li>
    <li>
      <p>Overall flow of a semaphore:</p>

      <ol>
        <li>places a process into a <em>waiting queue</em> <strong>associated with the semaphore</strong></li>
        <li>the state of process s switched to the waiting state.</li>
        <li>Then control is transferred to the CPU scheduler, which selects another process to execute.</li>
        <li>A process that is blocked, waiting on a semaphore S, should be restarted  by a <code class="language-plaintext highlighter-rouge">wakeup()</code> operation when some other process executes a <code class="language-plaintext highlighter-rouge">signal()</code> operation.</li>
        <li>The process is <em>restarted</em>, which changes the process from the waiting state to the ready state. The process is then placed in the ready queue.</li>
      </ol>
    </li>
    <li>
      <p>so the simple structure of a <code class="language-plaintext highlighter-rouge">semaphore</code> looks like:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
<span class="p">}</span> <span class="n">semaphore</span><span class="p">;</span>
</code></pre></div>      </div>
    </li>
  </ul>
</blockquote>

<p>Consider <code class="language-plaintext highlighter-rouge">int s=1</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">wait</span><span class="p">(</span><span class="n">s</span><span class="p">){</span>
    <span class="n">lock</span><span class="p">();</span>
    <span class="n">s</span><span class="o">--</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">add</span> <span class="n">current</span> <span class="n">process</span> <span class="n">to</span> <span class="n">queue</span><span class="p">;</span>
        <span class="n">unlock</span><span class="p">();</span>
        <span class="n">block</span> <span class="n">itself</span><span class="p">;</span>
        <span class="c1">// next time it wakes up, check again atomically</span>
        <span class="n">lock</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li>the <code class="language-plaintext highlighter-rouge">lock()</code> and <code class="language-plaintext highlighter-rouge">unlock()</code> are just to make the <em>code of the semaphore to be atomic</em>, so they could just be <code class="language-plaintext highlighter-rouge">test_and_set()</code></li>
</ul>

<p>and then:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">signal</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">();</span>
    <span class="n">S</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">remove</span> <span class="n">a</span> <span class="n">process</span> <span class="n">P</span> <span class="n">from</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
        <span class="n">wakeup</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>the above implementation allows a negative value semaphore. If a semaphore value is negative, <em>its magnitude is the number of processes waiting on that semaphore</em></li>
    <li>One way to add and remove processes from the list so as to ensure <strong>bounded waiting</strong> is to use a FIFO queue</li>
  </ul>
</blockquote>

<p>In kernel, the <strong>actual implementation</strong> are in <code class="language-plaintext highlighter-rouge">kernel/locking/semaphore.c</code></p>

<p>In general:</p>

<ul>
  <li>to <strong>grab a semaphore</strong>, use <code class="language-plaintext highlighter-rouge">void down(struct semaphore *sem)</code></li>
  <li>to <strong>release a semaphore</strong>, use <code class="language-plaintext highlighter-rouge">void up(struct semaphore *sem)</code></li>
</ul>

<p>In specific:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void down(struct semaphore *sem)</code> looks like:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">down</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
  
    <span class="cm">/* using spin lock to make sure the following code is atomic */</span>
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">__down</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>where:</p>

    <ul>
      <li>
        <p>if the original<code class="language-plaintext highlighter-rouge">count=1</code>, then this means only <em>one process can obtain the semaphore</em>. This is also called a <strong>binary semaphore</strong></p>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">count</code> defines <strong>the number of processes allowed to obtain the semaphore simultaneously</strong></li>
        </ul>
      </li>
      <li>
        <p>otherwise, the<code class="language-plaintext highlighter-rouge">__down(sem)</code> basically <em>blocks/sleeps</em> the process and does:</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__sched</span> <span class="nf">__down_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">long</span> <span class="n">state</span><span class="p">,</span>
								<span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">semaphore_waiter</span> <span class="n">waiter</span><span class="p">;</span>
    
    <span class="cm">/* adds the task to a LIST OF TASK WAITING */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">);</span>
	<span class="n">waiter</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">waiter</span><span class="p">.</span><span class="n">up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">interrupted</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">timed_out</span><span class="p">;</span>
        <span class="cm">/* sets the state of the task, E&gt;G&gt; TASK_UNINTERRUPTABLE */</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
        <span class="cm">/* befores goes to sleep, releases the spin lock from down() */</span>
		<span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
        <span class="cm">/* sends the process to sleep, also adds a timeout to the sleep. 
         * Then, schedules something else to run
         */</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
            
        <span class="cm">/* here, the process woke up */</span>
		<span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
        <span class="cm">/* if you woke up not by the __up() function, then waiter.up = false */</span>
        <span class="cm">/* then, you will need to loop again and go back to sleep */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waiter</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
    
<span class="cm">/* some code omitted */</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>on the other hand, <code class="language-plaintext highlighter-rouge">void up(struct semaphore *sem)</code> does:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">up</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
  
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="cm">/* if wait_list is empty, increase the semaphore */</span>
    <span class="cm">/* otherwise, wakes up the first process in the wait_list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">)))</span>
		<span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">__up</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>where:</p>

    <ul>
      <li>
        <p>the <code class="language-plaintext highlighter-rouge">__up(sem)</code> does:</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">__up</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">semaphore_waiter</span> <span class="o">*</span><span class="n">waiter</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">semaphore_waiter</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
    <span class="cm">/* sets the up flag for the __down_common() function */</span>
	<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="cm">/* wakes up the process */</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Disadvantage</strong></p>

  <ul>
    <li>
      <p>Because semaphores are stateful (it is not purely <code class="language-plaintext highlighter-rouge">1</code> or <code class="language-plaintext highlighter-rouge">0</code>), if you messed up by doing:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">up</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="cm">/* messed up the state */</span>
<span class="cm">/* some code */</span>
<span class="n">down</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  
<span class="cm">/* some other code */</span>
<span class="n">up</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</code></pre></div>      </div>

      <p>then the <em>entire state of semaphore is messed up</em> (i.e. it is broken from that point onward)</p>
    </li>
    <li>
      <p>However, if you use a <code class="language-plaintext highlighter-rouge">spinlock</code> which only has <code class="language-plaintext highlighter-rouge">0</code> or <code class="language-plaintext highlighter-rouge">1</code>, then messing it up once will still get it to work afterwards.</p>
    </li>
  </ul>
</blockquote>

<h4 id="mutex-locks">Mutex Locks</h4>

<blockquote>
  <p><strong>Mutex = Mutual Exclusion</strong></p>

  <ul>
    <li>Basically <em>either</em> the spin lock idea, or the blocking idea (<em>often</em> it refers to the blocking locks).</li>
  </ul>
</blockquote>

<p>So that the simple idea is just:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">acquire</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">available</span><span class="p">)</span>
        <span class="p">;</span> <span class="cm">/* busy wait */</span>
    <span class="n">available</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>then</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">release</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">available</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><em>For Example</em></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="n">acquire</span> <span class="n">lock</span>
        <span class="n">critical</span> <span class="n">section</span>
    <span class="n">release</span> <span class="n">lock</span>
        <span class="n">remainder</span> <span class="n">section</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="priority-inversion">Priority Inversion</h4>

<p><em>As an example</em>, assume we have three processes— $L$, $M$, and $H$—whose priorities follow the order $L &lt; M &lt; H$. Assume that process $H$ requires resource $R$, which is currently being accessed by process $L$.</p>

<ul>
  <li>Ordinarily, process $H$ would wait for $L$ to finish using resource $R$.</li>
  <li>However, now suppose that process $M$ becomes runnable, thereby <em>preempting process $L$</em>.</li>
  <li>Indirectly, a process with a lower priority—process $M$—has affected how long process
$H$ must wait for $L$ to relinquish resource $R$.</li>
</ul>

<blockquote>
  <p><strong>Priority Inversion</strong></p>

  <ul>
    <li>The above problem is solved by implementing a priority-inheritance protocol.</li>
    <li>According to this protocol, all processes that are <em>accessing resources needed by a higher-priority</em> process <em>inherit the higher priority</em> until they are finished with the resources in question. When they are <em>finished</em>, their priorities <em>revert to their original values</em>.</li>
  </ul>
</blockquote>

<h3 id="classical-synchronization-problems">Classical Synchronization Problems</h3>

<p>All below mutex locks refer to <strong>blocking semaphores</strong>.</p>

<h4 id="bounded-buffer">Bounded Buffer</h4>

<p>Basically, consider the case where you have a <em>pool</em> of <code class="language-plaintext highlighter-rouge">n</code> buffers, and you want only one process (producer/consumer) to access the pool at the time.</p>

<p>Using a simple <strong>semaphore</strong>:</p>

<ul>
  <li>
    <p>lock setups:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">semaphore</span> <span class="n">empty</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="n">semaphore</span> <span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Producer code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="cm">/* produce an item in next produced */</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
        <span class="n">wait</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
        <span class="n">wait</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="cm">/* add next produced to the buffer */</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    	<span class="n">signal</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    	<span class="n">signal</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></div></div>

<p>Consumer code:</p>

<pre><code class="language-pseudocode">do {
        wait(full);
        wait(mutex);
    . . .
    /* remove an item from buffer to next consumed */
    . . .
        signal(mutex);
        signal(empty);
    . . .
    /* consume the item in next consumed */
    . . .
} while (true);
</code></pre>

<p>Notice that:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">mutex</code> lock ensures <em>only one process into the pool</em></li>
  <li><code class="language-plaintext highlighter-rouge">empty</code> semaphore ensures processes only <em>producing</em> to <code class="language-plaintext highlighter-rouge">empty</code> number of buffers</li>
  <li><code class="language-plaintext highlighter-rouge">full</code> semaphore ensures processes only <em>consuming</em> to <code class="language-plaintext highlighter-rouge">full</code> number of buffers</li>
  <li><strong>all three locks combined</strong> gives the correct behavior</li>
</ul>

<h4 id="reader-writer-problem">Reader-Writer Problem</h4>

<blockquote>
  <p><strong>Reader-Writer Problem</strong></p>

  <ul>
    <li>First of all, when we have readers and writers for the same resource, we want to:
      <ul>
        <li>readers to be <em>concurrent</em></li>
        <li>writers to be <em>mutually exclusive</em></li>
      </ul>
    </li>
  </ul>

  <ol>
    <li>The <strong>first readers–writers problem</strong>, requires that no reader be kept waiting unless a writer has already obtained permission to use the shared object.
      <ul>
        <li>notice that <em>writers may starve</em> here (waiting forever if readers come in a lot)</li>
      </ul>
    </li>
    <li>The <strong>second readers–writers problem</strong> requires that, once a writer is ready, that writer perform its
write as soon as possible
      <ul>
        <li>notice that <em>readers may starve here</em> (waiting forever if writers come in a lot)</li>
      </ul>
    </li>
  </ol>

  <p>Therefore, in reality, there is often a mixed solution.</p>
</blockquote>

<p>The <strong>first problem</strong> is solved by:</p>

<ul>
  <li>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">semaphore</span> <span class="n">rw_mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Used by writer (technically used by both) */</span>
<span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Used by Readers */</span>
<span class="kt">int</span> <span class="n">read</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Writer Process</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">rw_mutex</span><span class="p">);</span> <span class="cm">/* just simply lock */</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="cm">/* writing is performed */</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">rw_mutex</span><span class="p">);</span> <span class="cm">/* just simply unlock */</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></div></div>

<p>Reader Process</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">read_count</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">wait</span><span class="p">(</span><span class="n">rw_mutex</span><span class="p">);</span> <span class="cm">/* first reader disables write */</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="cm">/* reading is performed */</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">read_count</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">signal</span><span class="p">(</span><span class="n">rw_mutex</span><span class="p">);</span> <span class="cm">/* last reader enables write */</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></div></div>

<p>notice that:</p>

<ul>
  <li>if a writer appears first, it obtains <code class="language-plaintext highlighter-rouge">rw_mutex</code>, disallows all readers</li>
  <li>if a reader appears first:
    <ul>
      <li>the first reader locks the <code class="language-plaintext highlighter-rouge">rw_mutex</code>, disallowing write</li>
      <li>the last reader unlucks the <code class="language-plaintext highlighter-rouge">rw_mutex</code>, allowing write</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>My Idea for the Second Reader-Writer Problem:</p>

  <ul>
    <li>
      <p>variables:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">semaphore</span> <span class="n">rw_mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Used by writer (technically used by both) */</span>
<span class="n">semaphore</span> <span class="n">read_lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Used to stop readers comming */</span>
<span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Used by Readers */</span>
<span class="n">semaphore</span> <span class="n">r_mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Used by Writers */</span>
<span class="kt">int</span> <span class="n">read</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>      </div>
    </li>
    <li>
      <p>Writer</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">r_mutex</span><span class="p">);</span>
    <span class="n">write_count</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">wait</span><span class="p">(</span><span class="n">read_lock</span><span class="p">);</span> <span class="cm">/* first writer disables more reader comming */</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">rw_mutex</span><span class="p">);</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">r_mutex</span><span class="p">);</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="cm">/* writing is performed */</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">r_mutex</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">write_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">signal</span><span class="p">(</span><span class="n">read_lock</span><span class="p">);</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">rw_mutex</span><span class="p">);</span> 
    <span class="n">signal</span><span class="p">(</span><span class="n">r_mutex</span><span class="p">);</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></div>      </div>
    </li>
    <li>
      <p>Reader:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">read_lock</span><span class="p">);</span> <span class="cm">/* used by writers to disable readers */</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">read_count</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">wait</span><span class="p">(</span><span class="n">rw_mutex</span><span class="p">);</span> <span class="cm">/* first reader disables write */</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">read_lock</span><span class="p">);</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="cm">/* reading is performed */</span>
    <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="n">wait</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">read_count</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">signal</span><span class="p">(</span><span class="n">rw_mutex</span><span class="p">);</span> <span class="cm">/* last reader enables write */</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></div>      </div>
    </li>
  </ul>

</blockquote>

<h3 id="rcu---read-copy-update">RCU - Read Copy Update</h3>

<p>This is an mechanism in kernel that allows concurrent readers <strong>without grabbing locks</strong> (saves performance issues)</p>

<ul>
  <li>this only works if we can do <strong>atomic updates</strong> (for example, if you are using a linked-list)</li>
</ul>

<blockquote>
  <p><strong>RCU</strong></p>

  <ul>
    <li>readers will <strong>not</strong> have a lock
      <ul>
        <li>in code, there will be a <em>fake lock</em>, which is only used to indicate where the critical section is</li>
      </ul>
    </li>
    <li>writers will <strong>have</strong> a spin lock (or any lock)</li>
  </ul>
</blockquote>

<p><em>For Example</em>: Linked-List RCU</p>

<p>Header file:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">ElementS</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">ElementS</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Element</span><span class="p">;</span>

<span class="n">class</span> <span class="n">RCUList</span> <span class="p">{</span>
  <span class="nl">private:</span>
    <span class="n">RCULock</span> <span class="n">rcuLock</span><span class="p">;</span>
    <span class="n">Element</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
  <span class="nl">public:</span>
    <span class="n">bool</span> <span class="n">search</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">);</span> <span class="cm">/* read */</span>
    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">Element</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">bool</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>implementation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span>
<span class="n">RCUList</span><span class="o">::</span><span class="n">search</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">valuep</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">Element</span> <span class="o">*</span><span class="n">current</span><span class="p">;</span>

    <span class="n">rcuLock</span><span class="p">.</span><span class="n">readLock</span><span class="p">();</span> <span class="cm">/* this is FAKE lock */</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> 
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">valuep</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">rcuLock</span><span class="p">.</span><span class="n">readUnlock</span><span class="p">();</span> <span class="cm">/* this is FAKE lock */</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> 
<span class="n">RCUList</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> 
                   <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Element</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>

    <span class="c1">// One write at a time.</span>
    <span class="n">rcuLock</span><span class="p">.</span><span class="n">writeLock</span><span class="p">();</span> <span class="cm">/* this is an actual lock, we are modifying the list */</span>

    <span class="c1">// Initialize item.</span>
    <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">Element</span><span class="o">*</span><span class="p">)</span>
         <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Element</span><span class="p">));</span>
    <span class="n">item</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span> 
    <span class="n">item</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>  

    <span class="c1">// Atomically update list.</span>
    <span class="n">rcuLock</span><span class="p">.</span><span class="n">publish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span> 

    <span class="c1">// Allow other writes </span>
    <span class="c1">// to proceed.</span>
    <span class="n">rcuLock</span><span class="p">.</span><span class="n">writeUnlock</span><span class="p">();</span> <span class="cm">/* this is an actual lock */</span>

    <span class="c1">// Wait until no reader </span>
    <span class="c1">// has old version.</span>
    <span class="n">rcuLock</span><span class="p">.</span><span class="n">synchronize</span><span class="p">();</span> 
<span class="p">}</span>
<span class="n">bool</span>
<span class="n">RCUList</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">Element</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">current</span><span class="p">;</span>

    <span class="c1">// One write at a time.</span>
    <span class="n">rcuLock</span><span class="p">.</span><span class="n">WriteLock</span><span class="p">();</span>  <span class="cm">/* this is an actual lock, we are modifying the list */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">,</span> 
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">found</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>

            <span class="c1">// Publish update to readers</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">rcuLock</span><span class="p">.</span><span class="n">publish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> 
                          <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">rcuLock</span><span class="p">.</span><span class="n">publish</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">),</span> 
                          <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Allow other writes to proceed.</span>
    <span class="n">rcuLock</span><span class="p">.</span><span class="n">writeUnlock</span><span class="p">();</span>

    <span class="c1">// Wait until no reader has old version.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* before synchronization, there MAY be an OLD reader looking at the old-TO-BE-REMOVED data, which is current */</span>
        <span class="n">rcuLock</span><span class="p">.</span><span class="n">synchronize</span><span class="p">();</span>
        <span class="cm">/* afterwards, you are SURE no reader will be looking at the old entry. Now you can free */</span>
        <span class="n">free</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li>all the actual waiting happens at <code class="language-plaintext highlighter-rouge">synchronize()</code></li>
</ul>

<p>the <strong>locks implementation:</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">class</span> <span class="n">RCULock</span><span class="p">{</span>
  <span class="nl">private:</span>
  <span class="c1">// Global state</span>
    <span class="n">Spinlock</span> <span class="n">globalSpin</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">globalCounter</span><span class="p">;</span>
  <span class="c1">// One per processor</span>
    <span class="n">DEFINE_PER_PROCESSOR</span><span class="p">(</span>
       <span class="k">static</span> <span class="kt">long</span><span class="p">,</span> <span class="n">quiescentCount</span><span class="p">);</span> 

  <span class="c1">// Per-lock state</span>
    <span class="n">Spinlock</span> <span class="n">writerSpin</span><span class="p">;</span>

  <span class="c1">// Public API omitted</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RCULock</span><span class="o">::</span><span class="n">ReadLock</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">disableInterrupts</span><span class="p">();</span> <span class="cm">/* I can't be preempted, but other running processes can run */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RCULock</span><span class="o">::</span><span class="n">ReadUnlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">enableInterrupts</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RCULock</span><span class="o">::</span><span class="n">writeLock</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">writerSpin</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span>  <span class="cm">/* an actual spin lock */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RCULock</span><span class="o">::</span><span class="n">writeUnlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">writerSpin</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="cm">/* an actual spin lock */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">RCULock</span><span class="o">::</span><span class="n">publish</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">pp1</span><span class="p">,</span> 
                         <span class="kt">void</span> <span class="o">*</span><span class="n">p2</span><span class="p">){</span>
    <span class="n">memory_barrier</span><span class="p">();</span> <span class="cm">/* make sure memory layout does not change */</span>
    <span class="o">*</span><span class="n">pp1</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>
    <span class="n">memory_barrier</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Called by scheduler </span>
<span class="kt">void</span> <span class="n">RCULock</span><span class="o">::</span><span class="n">QuiescentState</span><span class="p">(){</span> 
    <span class="n">memory_barrier</span><span class="p">();</span>
    <span class="n">PER_PROC_VAR</span><span class="p">(</span><span class="n">quiescentCount</span><span class="p">)</span> <span class="o">=</span>
                    <span class="n">globalCounter</span><span class="p">;</span> <span class="cm">/* sets the quiescentCount=globalCounter */</span>
    <span class="n">memory_barrier</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">RCULock</span><span class="o">::</span><span class="n">synchronize</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

    <span class="n">globalSpin</span><span class="p">.</span><span class="n">acquire</span><span class="p">();</span> 
    <span class="n">c</span> <span class="o">=</span> <span class="o">++</span><span class="n">globalCounter</span><span class="p">;</span>
    <span class="n">globalSpin</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> 

    <span class="cm">/* WAIT for EVERY single CPU to schedule something else */</span>
    <span class="n">FOREACH_PROCESSOR</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* true if the scheduler scheduled a NEW process AND called QuiescentState() */</span>
        <span class="k">while</span><span class="p">((</span><span class="n">PER_PROC_VAR</span><span class="p">(</span>
          <span class="n">quiescentCount</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// release CPU for 10ms</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> 
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>so we see that <code class="language-plaintext highlighter-rouge">synchronize</code> basically does the <strong>waiting</strong> such that all data across CPUs would be “correct”.</p>

<h4 id="kernel-code-examples-1">Kernel Code Examples</h4>

<blockquote>
  <p><strong>Note that</strong></p>

  <ul>
    <li>
      <p>if you want to use a RCU lock for a resource, then obviously you need all of the related operations:</p>

      <ul>
        <li>read</li>
        <li>write/update</li>
      </ul>

      <p>to <em>also use RCU</em> <code class="language-plaintext highlighter-rouge">publish</code>/<code class="language-plaintext highlighter-rouge">synchronization</code> mechanism</p>
    </li>
  </ul>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span>
<span class="nf">do_sched_setscheduler</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">__user</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_param</span> <span class="n">lparam</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* some code omitted */</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span> <span class="cm">/* rcu read_lock, not a real lock */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">find_process_by_pid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">get_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sched_setscheduler</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lparam</span><span class="p">);</span>
		<span class="n">put_task_struct</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="wait-queues">Wait Queues</h3>

<p>Basically, with this you can:</p>

<ul>
  <li>
    <p>defines a wait queue</p>
  </li>
  <li>add sleeping <code class="language-plaintext highlighter-rouge">task</code> to a wait queue</li>
  <li>wake up sleeping <code class="language-plaintext highlighter-rouge">task</code>s from a wait queue (putting back to <code class="language-plaintext highlighter-rouge">RUN QUEUE</code>)</li>
  <li>…</li>
  <li>more refer to <code class="language-plaintext highlighter-rouge">include/linux/wait.h</code>.</li>
</ul>

<blockquote>
  <p><em>Reminder</em></p>

  <ul>
    <li>When the task marks itself as sleeping, you wan to:
      <ol>
        <li>puts itself on a wait queue</li>
        <li>removes itself from the red-black tree of runnable (<code class="language-plaintext highlighter-rouge">RUN QUEUE</code>)</li>
        <li>calls <code class="language-plaintext highlighter-rouge">schedule()</code> to select a new process to execute.</li>
      </ol>
    </li>
    <li>Waking back up is the inverse:
      <ol>
        <li>The task is set as runnable</li>
        <li>Removed from the wait queue</li>
        <li>Added back to the red-black tree of <code class="language-plaintext highlighter-rouge">RUN QUEUE</code></li>
      </ol>
    </li>
  </ul>

  <p><strong>Note that waking up does not call <code class="language-plaintext highlighter-rouge">schedule()</code></strong></p>
</blockquote>

<p><strong>In specific</strong>:</p>

<ul>
  <li>
    <p>creating a <strong>wait queue</strong>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>  <span class="cm">/* statically creating a waitqueue*/</span>
<span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">wait_queue_name</span><span class="p">);</span> <span class="cm">/* statically creating a waitqueue*/</span>
<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="n">wq_head</span><span class="p">);</span> <span class="cm">/* dynamically creating one */</span>
</code></pre></div>    </div>

    <p>where:</p>

    <ul>
      <li>
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* DECLARE_WAITQUEUE(name, tsk) does this */</span>
<span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="n">name</span> <span class="o">=</span> <span class="n">__WAITQUEUE_INITIALIZER</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tsk</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>creating a wait_entry <em>statically</em> so that you can</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)
</span></code></pre></div>    </div>

    <p>where:</p>

    <ul>
      <li>
        <p>this thing <strong>automatically assigns <code class="language-plaintext highlighter-rouge">current</code> in the private field</strong></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="n">name</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">private</span>	<span class="o">=</span> <span class="n">current</span><span class="p">,</span>
    <span class="p">.</span><span class="n">func</span>		<span class="o">=</span> <span class="n">function</span><span class="p">,</span>	
    <span class="p">.</span><span class="n">entry</span>		<span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">((</span><span class="n">name</span><span class="p">).</span><span class="n">entry</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>adding things to a wait queue</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">void</span> <span class="nf">add_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">);</span>
<span class="cm">/* or lower level */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__add_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>notice that all it does is a <em>list_add</em>. This means you might be able to <strong>customize itself</strong>.</p>
  </li>
  <li>
    <p>adding things to a wait queue to tail</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__add_wait_queue_entry_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>actually <strong>sending a process to sleep</strong></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pstrace_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
<span class="n">schedule</span><span class="p">();</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>waking up all things from a wait queue by putting it <strong>back to <code class="language-plaintext highlighter-rouge">RUN_QUEUE</code></strong></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define wake_up(x)			__wake_up(x, TASK_NORMAL, 1, NULL)
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>remove task from <code class="language-plaintext highlighter-rouge">wait_queue</code> after you are <strong>sure that this thing should be running</strong>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * finish_wait - clean up after waiting in a queue
 * @wq_head: waitqueue waited on
 * @wq_entry: wait descriptor
 *
 * Sets current thread back to running state and removes
 * the wait descriptor from the given waitqueue if still
 * queued.
 */</span>
<span class="kt">void</span> <span class="n">finish_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>
      <p>other useful <code class="language-plaintext highlighter-rouge">wake_up</code> or <code class="language-plaintext highlighter-rouge">sleep</code> related functions can be found in <code class="language-plaintext highlighter-rouge">kernel/sched/core.c</code></p>

      <ul>
        <li>
          <p>wake up a task:</p>

          <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">wake_up_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">try_to_wake_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TASK_NORMAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>          </div>
        </li>
      </ul>
    </li>
  </ul>

</blockquote>

<p><em>For Example</em>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">cx25840_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">to_state</span><span class="p">(</span><span class="n">i2c_get_clientdata</span><span class="p">(</span><span class="n">client</span><span class="p">));</span>

<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">fw_wait</span><span class="p">);</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">"cx25840_fw"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* only changes state */</span>
    <span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">fw_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
    <span class="cm">/* kernel run something else, then the task is actually blocked */</span>
    <span class="n">schedule</span><span class="p">();</span>
    
    <span class="cm">/* after the task GETS RUNNING AGAIN, this is resumed/called */</span>
    <span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">fw_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>then to have something that <em>wakes</em> the task up, use</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">cx25840_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cx25840_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cx25840_state</span><span class="p">,</span> <span class="n">fw_work</span><span class="p">);</span>

	<span class="n">cx25840_loadfw</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">c</span><span class="p">);</span>
    <span class="cm">/* wakes up the task */</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">fw_wait</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">waking_up</code> the task does not automatically puts it to running. It <strong>only puts it back to the <code class="language-plaintext highlighter-rouge">RUN QUEUE</code></strong>. Then, <em>only when some processes called <code class="language-plaintext highlighter-rouge">schedule()</code></em>, the process <strong>might</strong> run (exactly which process to run depends on the scheduling algorithm).</li>
  </ul>
</blockquote>

<hr />

<p><em>For Example</em>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">inotify_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fsnotify_group</span> <span class="o">*</span><span class="n">group</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT_FUNC</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">woken_wake_function</span><span class="p">);</span>
    
    <span class="cm">/* initialization is done somewhere else */</span>

	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">notification_waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">notification_lock</span><span class="p">);</span>
		<span class="n">kevent</span> <span class="o">=</span> <span class="n">get_one_event</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">notification_lock</span><span class="p">);</span>

		<span class="cm">/* some code omitted */</span>
        
        <span class="cm">/* actually schedules a new process */</span>
		<span class="n">wait_woken</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">,</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="cm">/* when woken up, removes from the queue */</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">notification_waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>again, this task will be woken up by other functions calling <code class="language-plaintext highlighter-rouge">wake_up()</code>.</p>

<h3 id="kernel-schedule-function">Kernel Schedule Function</h3>

<p>This is what happens when the kernel calls <code class="language-plaintext highlighter-rouge">schedule</code> (i.e. sleeps a task by switching to let another task run).</p>

<blockquote>
  <p><em>Reminder</em></p>

  <ul>
    <li>When the task marks itself as sleeping, you wan to:
      <ol>
        <li>puts itself on a wait queue</li>
        <li>removes itself from the red-black tree of runnable (<code class="language-plaintext highlighter-rouge">RUN QUEUE</code>)</li>
        <li>calls <code class="language-plaintext highlighter-rouge">schedule()</code> to select a new process to execute.</li>
      </ol>
    </li>
    <li>Waking back up is the inverse:
      <ol>
        <li>The task is set as runnable</li>
        <li>Removed from the wait queue</li>
        <li>Added back to the red-black tree of <code class="language-plaintext highlighter-rouge">RUN QUEUE</code></li>
      </ol>
    </li>
  </ul>

  <p><strong>Note that waking up does not call <code class="language-plaintext highlighter-rouge">schedule()</code></strong></p>
</blockquote>

<p>Now, the code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="n">notrace</span> <span class="nf">__schedule</span><span class="p">(</span><span class="n">bool</span> <span class="n">preempt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">switch_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span> <span class="cm">/* previous running job = current task of run queue */</span>

    <span class="cm">/* some code omitted here */</span>

    <span class="cm">/* picks the next task from the RUN QUEUE */</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
	<span class="n">clear_tsk_need_resched</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">clear_preempt_need_resched</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* if there is only one job, then prev = next since running job
         * by default is still on the queue
         */</span>

         <span class="cm">/* this is when the prev=current job stops running, and the next one starts*/</span>
		<span class="cm">/* Also unlocks the rq: */</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">context_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_update_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RQCF_ACT_SKIP</span><span class="o">|</span><span class="n">RQCF_REQ_SKIP</span><span class="p">);</span>
		<span class="n">rq_unlock_irq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">balance_callback</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note:</p>

<ul>
  <li>for Linux kernel, making a task <code class="language-plaintext highlighter-rouge">RUNNING</code> <strong>does not</strong> remove it from the <code class="language-plaintext highlighter-rouge">RUN QUEUE</code>. Therefore, when you pick the next task to run, check that there are more than one task in the queue.
    <ul>
      <li>this is done with <code class="language-plaintext highlighter-rouge">likely(prev != next)</code></li>
    </ul>
  </li>
  <li>when a task is <code class="language-plaintext highlighter-rouge">context_switched</code>, it is <strong>not placed back on the <code class="language-plaintext highlighter-rouge">RUN QUEUE</code></strong> automatically.
    <ol>
      <li>It is placed back on the <code class="language-plaintext highlighter-rouge">RUN QUEUE</code> only when you call <code class="language-plaintext highlighter-rouge">wake_up()</code>.</li>
      <li>It is then run only when the OS calls <code class="language-plaintext highlighter-rouge">schedule()</code>, and it is its turn (essentially it is the <em>OS’s choice choosing and putting the next process to run</em>)</li>
    </ol>
  </li>
</ul>

<h3 id="monitor">Monitor</h3>

<blockquote>
  <p><em>Reminder</em>:</p>

  <ul>
    <li>
      <p>Because semaphores are stateful (it is not purely <code class="language-plaintext highlighter-rouge">1</code> or <code class="language-plaintext highlighter-rouge">0</code>), if you messed up by doing:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">up</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="cm">/* messed up the state */</span>
<span class="cm">/* some code */</span>
<span class="n">down</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    
<span class="cm">/* some other code */</span>
<span class="n">up</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</code></pre></div>      </div>

      <p>then the <em>entire state of semaphore is messed up</em> (i.e. it is broken from that point onward).</p>
    </li>
  </ul>
</blockquote>

<p>To deal with such errors, researchers have developed <strong>high-level language constructs</strong> - the <code class="language-plaintext highlighter-rouge">monitor</code> type.</p>

<ul>
  <li>essentially, the monitor construct <em>ensures that only one process at a time is active</em> within the monitor.</li>
</ul>

<blockquote>
  <p><strong>Monitor</strong></p>

  <ul>
    <li>
      <p><code class="language-plaintext highlighter-rouge">monitor</code> is an <em>Abstract Data Type</em>. The aim is that anything done <em>in the monitor</em> is <em>guaranteed</em> to be mutually exclusive.</p>

      <ul>
        <li>therefore, technically it does <em>not</em> exist in kernel, it is just an idea/abstract</li>
      </ul>
    </li>
    <li>
      <p>Abstract Structure of Monitor</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">monitor</span> <span class="n">monitor</span> <span class="n">name</span>
<span class="p">{</span>
    <span class="cm">/* shared variable declarations */</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">condition</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">...</span>

    <span class="cm">/* operators */</span>
    <span class="n">function</span> <span class="n">P1</span> <span class="p">(</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">{</span>
    	<span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="p">}</span>
    <span class="n">function</span> <span class="n">P2</span> <span class="p">(</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">{</span>
    	<span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="p">}</span>
    <span class="p">.</span>
    <span class="p">.</span>
    <span class="p">.</span>
    <span class="n">function</span> <span class="n">Pn</span> <span class="p">(</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">{</span>
    	<span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="p">}</span>
    <span class="n">initialization</span> <span class="n">code</span> <span class="p">(</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">{</span>
    	<span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <p>where:</p>

      <ul>
        <li>The <em>only</em> operations that can be invoked on a <strong>condition variable</strong> are <code class="language-plaintext highlighter-rouge">wait()</code>and <code class="language-plaintext highlighter-rouge">signal()</code>, and that the condition variable will have <em>its own wait queue</em></li>
      </ul>
    </li>
    <li>
      <p>Schematic Idea:</p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-16_13-06-00.png" alt="" /></p>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Signal and Wait in Monitor</strong></p>

  <ul>
    <li>Suppose there is some condition <code class="language-plaintext highlighter-rouge">x</code>:
      <ul>
        <li><code class="language-plaintext highlighter-rouge">x.wait();</code> means that the <strong>process invoking this operation is suspended</strong> until another process invokes</li>
        <li><code class="language-plaintext highlighter-rouge">x.signal();</code> <strong>resumes exactly one suspended process.</strong> If no process is suspended, then the signal() operation has no effect.</li>
      </ul>
    </li>
    <li>Now, suppose that <code class="language-plaintext highlighter-rouge">x.signal()</code> operation is invoked by a process $P$, there exists a suspended process $Q$ associated with condition <code class="language-plaintext highlighter-rouge">x</code>.  Now, <strong>both are allowable to run</strong>. Then you will have two strategies:
      <ol>
        <li><strong>Signal and wait.</strong> $P$ either waits until $Q$ leaves the monitor or waits for another condition.
          <ul>
            <li>this is sometimes adopted since the logical condition for which $Q$ was waiting <em>may no longer hold</em> after $P$ continues and finishes its work.</li>
          </ul>
        </li>
        <li><strong>Signal and continue.</strong> $Q$ either waits until $P$ leaves the monitor or waits for another condition.</li>
      </ol>
    </li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<p>Consider the following monitor:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Monitor</span> <span class="n">bank</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">balance</span><span class="p">;</span>

    <span class="n">condition</span> <span class="n">A</span><span class="p">;</span> <span class="cm">/* associated with A.wait() and A.signal() and its wait queue */</span>

    <span class="n">public</span> <span class="n">credit</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
        <span class="cm">/* some mutual exclusion code */</span>
        <span class="n">balance</span> <span class="o">-=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">public</span> <span class="n">debit</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
        <span class="cm">/* some mutual exclusion code */</span>
        <span class="n">balance</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>so that when doing</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">credit</code> or <code class="language-plaintext highlighter-rouge">debit</code>, those mutual exclusion on processes are guaranteed</li>
</ul>

<p>then, a simple example <strong>using the condition variable</strong>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* acquire and do work */</span>
<span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>

<span class="cm">/* condition_A is checked AGAIN when woken up! */</span>
<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">condition_A</span><span class="p">)</span>
    <span class="n">A</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>

<span class="n">unlock</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</code></pre></div></div>

<p>where, since processes <strong>cannot hold locks when asleep</strong>, we need to do the following inside <code class="language-plaintext highlighter-rouge">A.wait()</code>:</p>

<ul>
  <li>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span><span class="p">.</span><span class="n">wait</span><span class="p">(){</span>
    <span class="n">set_process_state_to_blocked</span><span class="p">();</span>
    <span class="n">add_process_to_wait_queue</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
    <span class="c1">// release the lock before going to sleep</span>
    <span class="n">unlock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">schedule</span><span class="p">();</span>
      
    <span class="c1">// when back, obtain the lock back</span>
    <span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>then, for the other part:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* release and have done the work */</span>
<span class="n">lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>

<span class="n">A</span><span class="p">.</span><span class="n">signal</span><span class="p">();</span>

<span class="n">unlock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>the above part of using the <strong>condition variable</strong> is <em>completely general</em> and does not restrict to using it within a <code class="language-plaintext highlighter-rouge">monitor</code>. This means that you can use the condition variable idea above independently in your work.</li>
  </ul>
</blockquote>

<h3 id="deadlocks">Deadlocks</h3>

<blockquote>
  <p><strong>Deadlock</strong></p>

  <ul>
    <li>When every process in the set is waiting for an event that can be caused only by <em>another waiting process in the set</em>, we say that a set of processes is in a <strong>deadlocked</strong> state</li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<ul>
  <li>process $P_1$ grabbed <code class="language-plaintext highlighter-rouge">lock1</code> and <em>attempts to grab</em> <code class="language-plaintext highlighter-rouge">lock2</code></li>
  <li>process $P_2$ grabbed <code class="language-plaintext highlighter-rouge">lock2</code> and <em>attempts to grab</em> <code class="language-plaintext highlighter-rouge">lock1</code></li>
</ul>

<blockquote>
  <p><strong>Conditions for Deadlock</strong></p>

  <p>A deadlock situation can arise if the following four conditions <strong>hold simultaneously</strong> in a system:</p>

  <ol>
    <li>there is some form of <em>mutual exclusion</em> (e.g. locks for a resource)</li>
    <li>there is some form of <em>hold and wait</em> (e.g. holding <code class="language-plaintext highlighter-rouge">lock1</code> and waiting for <code class="language-plaintext highlighter-rouge">lock2</code>)
      <ul>
        <li>basically, you are grabbing multiple locks.</li>
      </ul>
    </li>
    <li>a <em>circular wait</em> (e.g. process $P_1$ waits for $P_2$, and $P_2$ waits for $P_1$)
      <ul>
        <li>in a sense, this implies rule 1 and 2 as well</li>
      </ul>
    </li>
    <li><em>no preemption</em> (e.g. timeouts for locks)</li>
  </ol>

  <p>If these conditions hold, you can have a deadlock.</p>
</blockquote>

<p>Therefore, some rules to avoid deadlocks are:</p>

<ol>
  <li>try to avoid multiple locks</li>
  <li>if we are grabbing multiple locks, try to grab locks <em>in the same consistent order</em></li>
</ol>

<h4 id="dining-philosophers-problem">Dining Philosophers Problem</h4>

<p>Basically we have the setup that:</p>

<ul>
  <li>there are five philosophers, doing eating and thinking</li>
  <li>but there is one chop stick for each</li>
</ul>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-18_11-39-28.png" style="zoom:50%;" /></p>

<p>and:</p>

<ul>
  <li><strong>dead lock</strong> occurs if each person grabs its own chopstick, and is <em>circular waiting others to put it down</em></li>
</ul>

<h4 id="system-model">System Model</h4>

<p>In general, the system is basically doing this to resources:</p>

<ol>
  <li><strong>Request</strong>. The process requests the resource. If the request cannot be granted immediately (for example, if the resource is being used by another process), then the requesting process must <em>wait</em> until it can acquire the resource.</li>
  <li><strong>Use</strong>. The process can operate on the resource (for example, if the resource is a printer, the process can print on the printer).</li>
  <li><strong>Release</strong>. The process releases the resource.</li>
</ol>

<p>Examples of such resources include:</p>

<ul>
  <li>resources may be either <strong>physical resources</strong> (for example, printers, tape drives, memory space, and CPU cycles)</li>
  <li><strong>logical resources</strong> (for example, files, semaphores, and monitors)</li>
</ul>

<p>In the end, <strong>a system table</strong> records:</p>

<ul>
  <li>whether <em>each resource</em> is free or allocated</li>
  <li>for each resource that is allocated, the table also records the <em>process to which it  is allocated.</em></li>
</ul>

<p>Therefore:</p>

<blockquote>
  <p><strong>Two Broad Types of Deadlocks</strong></p>

  <ul>
    <li>Deadlocks with same resource type
      <ul>
        <li>process $P_1$ grabbed <code class="language-plaintext highlighter-rouge">resource1_1</code> and <em>attempts to grab</em> <code class="language-plaintext highlighter-rouge">resource1_2</code></li>
        <li>process $P_2$ grabbed <code class="language-plaintext highlighter-rouge">resource1_2</code> and <em>attempts to grab</em> <code class="language-plaintext highlighter-rouge">resource1_1</code></li>
      </ul>
    </li>
    <li>Deadlocks with different resource types
      <ul>
        <li>process $P_1$ grabbed <code class="language-plaintext highlighter-rouge">resource1</code> and <em>attempts to grab</em> <code class="language-plaintext highlighter-rouge">resource2</code></li>
        <li>process $P_2$ grabbed <code class="language-plaintext highlighter-rouge">resource2</code> and <em>attempts to grab</em> <code class="language-plaintext highlighter-rouge">resource1</code></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="resource-allocation-graph">Resource Allocation Graph</h4>

<blockquote>
  <p><strong>Vertices</strong></p>

  <ul>
    <li>${P_1, P_2, …, P_n}$, the set consisting of all the <em>active processes</em> in the
system</li>
    <li>${R_1, R_2, …, R_m}$, the set consisting of all <em>resource types</em>
      <ul>
        <li>Since resource type $R_j$ may <em>have more than one instance</em> (e,g, resource type <code class="language-plaintext highlighter-rouge">printer</code> may have 3 actual printers), we represent each such instance as a <em>dot</em></li>
      </ul>
    </li>
  </ul>

  <p><strong>Directed Edges</strong></p>

  <ul>
    <li>A directed edge $P_i → R_j$ is called a <strong>request edge</strong> ($P_i$ requested resource $R_j$)</li>
    <li>
      <p>A directed edge $R_j → P_i$ is called an <strong>assignment edge</strong> ($R_j$ is assigned to process $P_i$)</p>
    </li>
    <li>When this <em>request can be fulfilled</em>, the request edge is <strong>instantaneously transformed</strong> to an assignment edge</li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-18_20-49-43.png" style="zoom:80%;" /></p>

<p>which is fine</p>

<p><em>For Example: Dead Lock</em></p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-18_20-51-12.png" style="zoom:80%;" /></p>

<p>which has a deadlock.</p>

<blockquote>
  <p><strong>This means</strong></p>

  <ul>
    <li>If the graph contains <strong>no cycles</strong>, then <strong>no</strong> process in the system is <strong>deadlocked</strong>.</li>
    <li>If the graph does contain <strong>a cycle</strong>, then a <strong>deadlock may exist.</strong>
      <ul>
        <li>If each resource type has <em>several instances</em>, then a cycle does not necessarily imply that a deadlock has occurred</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><em>For Example: Cycle without Deadlock</em></p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-02-18_20-55-16.png" style="zoom:80%;" /></p>

<h4 id="handling-deadlocks">Handling Deadlocks</h4>

<blockquote>
  <p><strong>For OS</strong></p>

  <p>In the OS point of view, we can:</p>

  <ul>
    <li>We can use a protocol to <em>prevent or avoid deadlocks</em>, ensuring that the system will never enter a deadlocked state.</li>
    <li>We can allow the system to enter a deadlocked state, <em>detect it, and recover.</em></li>
    <li>We can ignore the problem altogether and <em>pretend that deadlocks never occur in the system</em>.
      <ul>
        <li>this is employed by UNIX and Windows</li>
      </ul>
    </li>
  </ul>
</blockquote>

<ol>
  <li>
    <p>Preventing or avoiding deadlocks</p>

    <ul>
      <li>
        <p><strong>Deadlock prevention</strong></p>

        <p>provides a set of methods for ensuring that <em>at least one of the four necessary conditions for deadlocks</em> cannot hold.</p>
      </li>
      <li>
        <p><strong>Deadlock avoidance</strong></p>

        <p>requires that the operating system be given in advance <em>additional information concerning which resources a process will request and use during its lifetime.</em></p>
      </li>
    </ul>
  </li>
</ol>

<h1 id="midterm-solution">Midterm Solution</h1>

<p><strong>Task</strong></p>

<ol>
  <li>Use a <em>Ring Buffer</em> to trace <em>all the system calls executed</em> by the OS</li>
</ol>

<p><strong>Solution</strong></p>

<ol>
  <li>
    <p>To trace it correctly, add it inside <code class="language-plaintext highlighter-rouge">arch/x86/entry/common.c</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/sctrace.h&gt;</span><span class="cp">
</span>   
<span class="cp">#ifdef CONFIG_X86_64
</span><span class="n">__visible</span> <span class="kt">void</span> <span class="nf">do_syscall_64</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">thread_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
   
	<span class="n">enter_from_user_mode</span><span class="p">();</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>
	<span class="n">ti</span> <span class="o">=</span> <span class="n">current_thread_info</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">_TIF_WORK_SYSCALL_ENTRY</span><span class="p">)</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">syscall_trace_enter</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
   
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nr</span> <span class="o">&lt;</span> <span class="n">NR_syscalls</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">array_index_nospec</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">NR_syscalls</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ax</span> <span class="o">=</span> <span class="n">sys_call_table</span><span class="p">[</span><span class="n">nr</span><span class="p">](</span><span class="n">regs</span><span class="p">);</span>
        <span class="c1">// added here</span>
        <span class="c1">// current information is accessible without passing it in</span>
		<span class="n">sctrace_add</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ax</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_X86_X32_ABI
</span>	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="n">__X32_SYSCALL_BIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			  <span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__X32_SYSCALL_BIT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">X32_NR_syscalls</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">array_index_nospec</span><span class="p">(</span><span class="n">nr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__X32_SYSCALL_BIT</span><span class="p">,</span>
					<span class="n">X32_NR_syscalls</span><span class="p">);</span>
		<span class="n">regs</span><span class="o">-&gt;</span><span class="n">ax</span> <span class="o">=</span> <span class="n">x32_sys_call_table</span><span class="p">[</span><span class="n">nr</span><span class="p">](</span><span class="n">regs</span><span class="p">);</span>
         <span class="c1">// optionally added here</span>
		<span class="n">sctrace_add</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">regs</span><span class="o">-&gt;</span><span class="n">ax</span><span class="p">);</span>
<span class="cp">#endif
</span>	<span class="p">}</span>
   	
	<span class="n">syscall_return_slowpath</span><span class="p">(</span><span class="n">regs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>The process of adding the my own <code class="language-plaintext highlighter-rouge">syscalls</code> are omitted, as they are trivial</p>
  </li>
  <li>
    <p>Now, the <strong>actual program</strong></p>

    <p>First, the header file looks like:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef _INCLUDE_PSTRACE_H
#define _INCLUDE_PSTRACE_H
</span>   
<span class="cp">#include</span> <span class="cpf">&lt;linux/atomic.h&gt;</span><span class="cp">
</span>   
<span class="k">struct</span> <span class="n">sctrace</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">syscall</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">tid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">comm</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>
   
<span class="cp">#define SCTRACE_BUF_SIZE	500
</span>   
<span class="cm">/* this is the circular buffer */</span>
<span class="k">struct</span> <span class="n">sctrace_buf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sctrace</span> <span class="n">entry</span><span class="p">[</span><span class="n">SCTRACE_BUF_SIZE</span><span class="p">];</span>
	<span class="n">bool</span> <span class="n">sctrace_enable</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">sctrace_lock</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">empty</span><span class="p">;</span>
<span class="p">};</span>
   
<span class="kt">void</span> <span class="nf">sctrace_add</span><span class="p">(</span><span class="kt">long</span> <span class="n">syscall</span><span class="p">,</span> <span class="kt">long</span> <span class="n">result</span><span class="p">);</span>
   
<span class="cp">#endif
</span></code></pre></div>    </div>

    <p>First, <code class="language-plaintext highlighter-rouge">sctrace_add</code> looks like:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/atomic.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/slab.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/uaccess.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/syscalls.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/sctrace.h&gt;</span><span class="cp">
</span>   
<span class="c1">// a circular buffer</span>
<span class="cm">/* struct sctrace entry[SCTRACE_BUF_SIZE]; 
is already initialized in header file*/</span>
<span class="k">struct</span> <span class="n">sctrace_buf</span> <span class="n">sct</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">SCTRACE_BUF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sctrace_lock</span> <span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="n">sctrace_lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">sctrace_enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
	<span class="p">.</span><span class="n">empty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
<span class="p">};</span>
   
<span class="kt">void</span> <span class="nf">sctrace_add</span><span class="p">(</span><span class="kt">long</span> <span class="n">syscall</span><span class="p">,</span> <span class="kt">long</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
   
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sct</span><span class="p">.</span><span class="n">sctrace_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sct</span><span class="p">.</span><span class="n">sctrace_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sct</span><span class="p">.</span><span class="n">sctrace_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
   	
	<span class="n">head</span> <span class="o">=</span> <span class="n">sct</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	<span class="n">tail</span> <span class="o">=</span> <span class="n">sct</span><span class="p">.</span><span class="n">tail</span><span class="p">;</span>
       
    <span class="cm">/* wraps around in the CIRCULAR BUFF */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail</span> <span class="o">==</span> <span class="n">SCTRACE_BUF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tail</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sct</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
   
    <span class="cm">/* upon first iteration, @head stays at 0
     * when it is full, it wraps arounf and then @head will be @tail+1
     */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="n">tail</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sct</span><span class="p">.</span><span class="n">empty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">head</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sct</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span> <span class="o">==</span> <span class="n">SCTRACE_BUF_SIZE</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">head</span><span class="p">;</span>
	<span class="p">}</span>
       
    <span class="cm">/* always add the data to the tail element */</span>
	<span class="n">sct</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">tail</span><span class="p">].</span><span class="n">syscall</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">;</span>
	<span class="n">sct</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">tail</span><span class="p">].</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">get_task_comm</span><span class="p">(</span><span class="n">sct</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">tail</span><span class="p">].</span><span class="n">comm</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">sct</span><span class="p">.</span><span class="n">entry</span><span class="p">[</span><span class="n">tail</span><span class="p">].</span><span class="n">tid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">sct</span><span class="p">.</span><span class="n">empty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sct</span><span class="p">.</span><span class="n">sctrace_lock</span><span class="p">);</span>
<span class="p">}</span>
   
<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">sctrace_start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
   
	<span class="c1">//spin_lock(&amp;sct.sctrace_lock);</span>
    <span class="cm">/* lock not needed since we are READING */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sct</span><span class="p">.</span><span class="n">sctrace_enable</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* ASSIGNMENT is also atomic */</span>
		<span class="n">sct</span><span class="p">.</span><span class="n">sctrace_enable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//spin_unlock(&amp;sct.sctrace_lock);</span>
   
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
   
<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">sctrace_stop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
   
	<span class="c1">//spin_lock(&amp;sct.sctrace_lock);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sct</span><span class="p">.</span><span class="n">sctrace_enable</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">sct</span><span class="p">.</span><span class="n">sctrace_enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">//spin_unlock(&amp;sct.sctrace_lock);</span>
   
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
   
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">sctrace_dump</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sctrace</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sctrace</span> <span class="o">*</span><span class="n">kbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">empty</span><span class="p">;</span>
   
	<span class="n">kbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctrace</span><span class="p">)</span> <span class="o">*</span> <span class="n">SCTRACE_BUF_SIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kbuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
   
   
    <span class="cm">/* lock and COPY DATA BACK */</span>
       
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sct</span><span class="p">.</span><span class="n">sctrace_lock</span><span class="p">);</span>
    <span class="cm">/* copy data from YOUR STACK RB to the MALLOCED data */</span>
    <span class="cm">/* alternatively, you can just have a loop to copy data back */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">kbuf</span><span class="p">,</span> <span class="n">sct</span><span class="p">.</span><span class="n">entry</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctrace</span><span class="p">)</span> <span class="o">*</span> <span class="n">SCTRACE_BUF_SIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">kbuf</span> <span class="o">+</span> <span class="n">SCTRACE_BUF_SIZE</span><span class="p">,</span> <span class="n">sct</span><span class="p">.</span><span class="n">entry</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctrace</span><span class="p">)</span> <span class="o">*</span> <span class="n">SCTRACE_BUF_SIZE</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">sct</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	<span class="n">tail</span> <span class="o">=</span> <span class="n">sct</span><span class="p">.</span><span class="n">tail</span><span class="p">;</span>
	<span class="n">empty</span> <span class="o">=</span> <span class="n">sct</span><span class="p">.</span><span class="n">empty</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sct</span><span class="p">.</span><span class="n">sctrace_lock</span><span class="p">);</span>
   
    <span class="cm">/* calculates how many entries copied here,
       and copies the data back to user
     */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SCTRACE_BUF_SIZE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">-</span> <span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
   
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">kbuf</span> <span class="o">+</span> <span class="n">head</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctrace</span><span class="p">)</span> <span class="o">*</span> <span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
   
   
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">kbuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Last but not least, the <code class="language-plaintext highlighter-rouge">test.c</code> file:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;wait.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span>   
<span class="cp">#define BUF_SIZE 500
</span>   
<span class="cp">#define __NR_SYSCALL_SCTRACE_START 436
#define __NR_SYSCALL_SCTRACE_STOP 437
#define __NR_SYSCALL_SCTRACE_DUMP 438
</span>   
<span class="k">struct</span> <span class="n">sctrace</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="n">syscall</span><span class="p">;</span>
        <span class="kt">long</span> <span class="n">result</span><span class="p">;</span>
        <span class="n">pid_t</span> <span class="n">tid</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">comm</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">};</span>
   
<span class="kt">void</span> <span class="nf">populate_buffer</span><span class="p">()</span>
<span class="p">{</span>
    	<span class="cm">/* will eventually calls a bunch of syscalls */</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"hello, world</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
   
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">sctrace</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
        <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
   
        <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sctrace</span><span class="p">)</span> <span class="o">*</span> <span class="n">BUF_SIZE</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
   
    	<span class="cm">/* starts tracing */</span>
        <span class="n">syscall</span><span class="p">(</span><span class="n">__NR_SYSCALL_SCTRACE_START</span><span class="p">);</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            	<span class="cm">/* child populates data */</span>
                <span class="n">populate_buffer</span><span class="p">();</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
                <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    	<span class="cm">/* parent calls the syscall and gets stuff */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">__NR_SYSCALL_SCTRACE_DUMP</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
                <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BUF_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">"SYSCALL: %s,%d,%ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                                <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">comm</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tid</span><span class="p">,</span>
                                <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">syscall</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">syscall</span><span class="p">(</span><span class="n">__NR_SYSCALL_SCTRACE_STOP</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
   
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<blockquote>
  <p><strong>Take Away Messages</strong></p>

  <ol>
    <li>
      <p>The <strong>Ring Buffer</strong> structure using <code class="language-plaintext highlighter-rouge">tail</code> and <code class="language-plaintext highlighter-rouge">head</code> integer position</p>

      <p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20201108143018/BufferPic.jpg" style="zoom:50%;" /></p>

      <p>The tail pointer and the size increment by one upon insertion of an element.</p>

      <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">struct</span> <span class="n">sctrace_buf</span> <span class="n">sct</span> <span class="o">=</span> <span class="o">{</span>
	<span class="o">.</span><span class="na">head</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span>
	<span class="o">.</span><span class="na">tail</span> <span class="o">=</span> <span class="no">SCTRACE_BUF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span>
 <span class="o">.</span><span class="na">sctrace_lock</span> <span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="o">(</span><span class="n">sctrace_lock</span><span class="o">),</span>
	<span class="o">.</span><span class="na">sctrace_enable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span>
	<span class="o">.</span><span class="na">empty</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span>
<span class="o">};</span>
      
<span class="kt">void</span> <span class="nf">sctrace_add</span><span class="o">(</span><span class="kt">long</span> <span class="n">syscall</span><span class="o">,</span> <span class="kt">long</span> <span class="n">result</span><span class="o">)</span>
<span class="o">{</span>
	<span class="kt">int</span> <span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">;</span>
   	   
	<span class="n">head</span> <span class="o">=</span> <span class="n">sct</span><span class="o">.</span><span class="na">head</span><span class="o">;</span>
	<span class="n">tail</span> <span class="o">=</span> <span class="n">sct</span><span class="o">.</span><span class="na">tail</span><span class="o">;</span>
          
 <span class="cm">/* wraps around in the CIRCULAR BUFF */</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">tail</span> <span class="o">==</span> <span class="no">SCTRACE_BUF_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
		<span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
 <span class="k">else</span>
		<span class="n">tail</span><span class="o">++;</span>
	<span class="n">sct</span><span class="o">.</span><span class="na">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
      
    <span class="cm">/* upon first iteration, @head stays at 0
     * when it is full, it wraps arounf and then @head will be @tail+1
  */</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">likely</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="n">tail</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sct</span><span class="o">.</span><span class="na">empty</span><span class="o">))</span> <span class="o">{</span>
		<span class="n">head</span><span class="o">++;</span>
		<span class="n">sct</span><span class="o">.</span><span class="na">head</span> <span class="o">=</span> <span class="n">head</span> <span class="o">==</span> <span class="no">SCTRACE_BUF_SIZE</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">head</span><span class="o">;</span>
	<span class="o">}</span>
          
    <span class="cm">/* always add the data to the tail element */</span>
	<span class="n">sct</span><span class="o">.</span><span class="na">entry</span><span class="o">[</span><span class="n">tail</span><span class="o">].</span><span class="na">syscall</span> <span class="o">=</span> <span class="n">syscall</span><span class="o">;</span>
	<span class="n">sct</span><span class="o">.</span><span class="na">entry</span><span class="o">[</span><span class="n">tail</span><span class="o">].</span><span class="na">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">;</span>
	<span class="n">get_task_comm</span><span class="o">(</span><span class="n">sct</span><span class="o">.</span><span class="na">entry</span><span class="o">[</span><span class="n">tail</span><span class="o">].</span><span class="na">comm</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
	<span class="n">sct</span><span class="o">.</span><span class="na">entry</span><span class="o">[</span><span class="n">tail</span><span class="o">].</span><span class="na">tid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
	<span class="n">sct</span><span class="o">.</span><span class="na">empty</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
	<span class="n">spin_unlock</span><span class="o">(&amp;</span><span class="n">sct</span><span class="o">.</span><span class="na">sctrace_lock</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>      </div>

      <p>therefore, to figure out the actual size:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span> <span class="cm">/* always be the case for full buffer */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">SCTRACE_BUF_SIZE</span><span class="p">;</span>
<span class="k">else</span> <span class="cm">/* not full buffer, @tail advances when new data added but @head does not move */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">-</span> <span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>      </div>
    </li>
  </ol>
</blockquote>

<h1 id="week-6---process-scheduling">Week 6 - Process Scheduling</h1>

<h2 id="process-scheduling-1">Process Scheduling</h2>

<p>In general, the Linux scheduler (on recent Linux kernels, e.g. 3.0 at least) is <strong>scheduling <em>schedulable tasks</em> or simply <em>tasks</em> <code class="language-plaintext highlighter-rouge">task_struct</code>.</strong></p>

<p>A task may be :</p>

<ul>
  <li>a single-threaded process (e.g. created by <code class="language-plaintext highlighter-rouge">fork</code> without any thread library)</li>
  <li>any <em>thread</em> inside a multi-threaded process (including its main thread), in particular <code class="language-plaintext highlighter-rouge">Posix</code> threads (<code class="language-plaintext highlighter-rouge">pthreads</code>)</li>
  <li>kernel tasks, which are started internally in the kernel and stay in kernel land (e.g. <code class="language-plaintext highlighter-rouge">kworker</code>, <code class="language-plaintext highlighter-rouge">nfsiod</code>, <code class="language-plaintext highlighter-rouge">kjournald</code> , <code class="language-plaintext highlighter-rouge">kauditd</code>, <code class="language-plaintext highlighter-rouge">kswapd</code> etc etc…)</li>
</ul>

<p>In other words, threads inside multi-threaded processes are scheduled like non-threaded - i.e. single threaded - processes.</p>

<h3 id="cpu-scheduler">CPU Scheduler</h3>

<blockquote>
  <p><strong>Scheduling</strong></p>

  <ul>
    <li><strong>Short-term scheduler</strong>, or <strong>CPU scheduler</strong>, does the job of:
      <ol>
        <li>maintains a queue of tasks
          <ul>
            <li>Note that the ready queue is <em>not necessarily</em> a first-in, first-out (FIFO) queue. It depends on the algorithm we want to use.</li>
          </ul>
        </li>
        <li><em>select</em> a task to run
          <ul>
            <li>in the end, runs it by doing a <em>context switch</em></li>
          </ul>
        </li>
        <li>decide how long it will run</li>
      </ol>
    </li>
    <li>scheduling is called in the <strong>following 4 context:</strong>
      <ol>
        <li>some running process <em>involuntarily</em> gives up the CPU (e.g. it gets blocked)
          <ul>
            <li>switches from <code class="language-plaintext highlighter-rouge">running-&gt;waiting</code> or from <code class="language-plaintext highlighter-rouge">running-&gt;ready</code></li>
          </ul>
        </li>
        <li>some running process <em>voluntarily</em> gives up CPU (e.g. it is done)
          <ul>
            <li>switches from <code class="language-plaintext highlighter-rouge">running-&gt;terminate</code></li>
          </ul>
        </li>
        <li>some special “task” becomes runnable
          <ul>
            <li>some special task switches from <code class="language-plaintext highlighter-rouge">waiting-&gt;ready</code></li>
          </ul>
        </li>
        <li>scheduling parameters of the task change (e.g. priority of some task changed)</li>
      </ol>
    </li>
    <li>You can call a schedule:
      <ul>
        <li>directly</li>
        <li>indirectly by some <code class="language-plaintext highlighter-rouge">NEED_RESCHED</code> flag (e.g. when a process exits, it checks the flag)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>
      <p><strong>Long-term scheduling</strong> involves selecting the processes from the storage pool in the secondary memory and <em>loading them into the ready queue</em> in the main memory for execution.</p>

      <p>The long-term scheduler controls the degree of multiprogramming. It <em>must select a careful mixture of I/O bound and CPU bound processes to yield optimum system throughput</em>. If it selects too many CPU bound processes then the I/O devices are idle and if it selects too many I/O bound processes then the processor has nothing to do.</p>
    </li>
  </ul>
</blockquote>

<h4 id="cpu-io-burst-cycle">CPU-I/O Burst Cycle</h4>

<blockquote>
  <p><strong>Definition</strong></p>

  <ul>
    <li>process execution consists of a cycle of <em>CPU execution</em> and <em>I/O wait</em>, so that <strong>every process alternate between these two states</strong>.
      <ul>
        <li>this means that: process execution begins with a burst, then goes to I/O burst, then goes to CPU burst, etc.</li>
      </ul>
    </li>
  </ul>

  <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-03_21-24-50.png" style="zoom:50%;" /></p>
</blockquote>

<p>Typically:</p>

<ul>
  <li>An I/O-bound program typically has <em>many short CPU bursts</em>.</li>
  <li>A CPU-bound program might have a <em>few long CPU bursts</em>.</li>
</ul>

<h4 id="preemptive-scheduling">Preemptive Scheduling</h4>

<blockquote>
  <p><em>Reminder</em></p>

  <p>Below was the <em>four conditions</em> when CPU scheduling needs to decide what goes next:</p>

  <ol>
    <li>When a process switches from the running state to the waiting state</li>
    <li>When a process switches from the running state to the ready state (for example, when an interrupt occurs)</li>
    <li>When a process switches from the waiting state to the ready state (for example, at completion of I/O)</li>
    <li>When a process terminates</li>
  </ol>
</blockquote>

<ul>
  <li>When scheduling takes place only under circumstances 1 and 4, we say that the scheduling scheme is <strong>non-preemptive</strong> or <strong>cooperative</strong>.</li>
  <li>Otherwise, it is <strong>preemptive</strong>.</li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>Preemptive scheduling can result in <em>race conditions</em> when data are shared among several processes</li>
    <li>Therefore, sections of code are not accessed concurrently by several processes, they <em>disable interrupts at entry and reenable interrupts at exit</em></li>
  </ul>
</blockquote>

<h4 id="dispatcher">Dispatcher</h4>

<blockquote>
  <p><strong>Dispatcher</strong></p>

  <ul>
    <li>The dispatcher is the module that <em>gives control of the CPU to the process</em> selected by the short-term scheduler.</li>
    <li>This does the following:
      <ol>
        <li>Switching context</li>
        <li>Switching to user mode
          <ul>
            <li>recall that this is also where it checks if there are <em>signals</em></li>
          </ul>
        </li>
        <li>Jumping to the proper <em>location in the user program</em> to restart that program</li>
      </ol>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Dispatcher Latency</strong></p>

  <ul>
    <li>The <em>time</em> it takes for the dispatcher to <em>stop one process and start another running</em> is known as the <strong>dispatch latency</strong>.</li>
  </ul>
</blockquote>

<h3 id="scheduling-criteria">Scheduling Criteria</h3>

<p>Many criteria have been suggested for <em>comparing CPU-scheduling algorithms</em></p>

<blockquote>
  <p><strong>Scheduling Criteria</strong></p>

  <ol>
    <li>
      <p><strong>CPU utilization.</strong></p>

      <p>We want to <em>keep the CPU as busy as possible</em>. In a real system, it should range from 40 percent (for a lightly loaded system) to 90 percent (for a heavily loaded system).</p>
    </li>
    <li>
      <p><strong>Throughput.</strong></p>

      <p>If the CPU is busy executing processes, then work is being done. One measure of work is the <em>number of processes that are completed per time unit</em>, called throughput</p>
    </li>
    <li>
      <p><strong>Turnaround time.</strong></p>

      <p>From the <em>point of view of a particular process</em>, the important criterion is how long it takes to execute that process. The interval from the <em>time of submission</em> of a process <em>to the time of completion</em> is the
turnaround time.</p>
    </li>
    <li>
      <p><strong>Waiting time.</strong></p>

      <p>The CPU-scheduling algorithm does not affect the amount of time during which a process executes or does I/O. It affects only the <em>amount of time</em> that a process spends <em>waiting in the ready queue</em></p>

      <ul>
        <li>Shorted-Job/Burst-First minimizes this</li>
      </ul>
    </li>
    <li>
      <p><strong>Response time.</strong></p>

      <p>In an interactive system, often, a process can <em>produce some output fairly early</em> and can continue computing new results. Thus, another measure is the <em>time from the submission of a request</em> until the <em>first response is produced</em>. This measure, called response time, is the time it takes to start responding, not the time it takes to output the response.</p>
    </li>
  </ol>
</blockquote>

<p>Therefore, It is desirable to <strong>maximize</strong> <em>CPU utilization and throughput</em> and to <strong>minimize</strong> <em>turnaround time, waiting time, and response time</em>.</p>

<ul>
  <li>In most cases, we optimize the average measure.</li>
  <li>However, under some circumstances, we prefer to <em>optimize the minimum or maximum</em> values rather than the average.
    <ul>
      <li>For example, to guarantee that all users get good service,we may want to minimize the maximum response time.</li>
    </ul>
  </li>
</ul>

<h3 id="scheduling-algorithms">Scheduling Algorithms</h3>

<p>CPU scheduling deals with the problem of <strong>deciding which of the processes in the ready queue</strong> is to be allocated the CPU.</p>

<p>The measure of comparison in this section is the <strong>average waiting time</strong>.</p>

<h4 id="first-come-first-served-scheduling">First-Come, First Served Scheduling</h4>

<p>The implementation of the FCFS policy is easily managed with a <em>FIFO queue.</em>.</p>

<blockquote>
  <p><strong>Disadvantage</strong></p>

  <ol>
    <li>
      <p>On the negative side, the <strong>average waiting time</strong> under the FCFS policy is often quite long.</p>

      <ul>
        <li>i.e. the average waiting time under an FCFS policy is generally not minimal and <em>may vary substantially</em> if the processes’ CPU burst times vary greatly.</li>
      </ul>
    </li>
    <li>
      <p>There is a <strong>convoy effect</strong> as all the other processes wait for the one big process to get off the CPU.</p>

      <ul>
        <li>
          <p>e.g. all the <em>I/O processes end up waiting</em> in the ready queue <em>until the CPU-bound process</em> is done. Then, when all the I/O-bound processes run, which have short CPU bursts, they execute quickly and move back to the I/O queues. At this point, the <em>CPU sits idle</em>.</p>
        </li>
        <li>
          <p>This effect results in <strong>lower CPU and device utilization</strong> than might be possible if the shorter processes were allowed to go first.</p>
        </li>
      </ul>
    </li>
  </ol>
</blockquote>

<p><em>For Example</em></p>

<p>Consider the following set of processes that <em>arrive at time 0</em>, with the length of the <em>CPU burst</em> given in milliseconds:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_11-22-54.png" alt="" /></p>

<p>If the processes <em>arrive in the order P1, P2, P3</em>, and are served in FCFS order, we get the result shown in the following <strong>Gantt chart</strong> (which is a bar chart that illustrates a particular schedule)</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_11-23-47.png" alt="" /></p>

<p>where:</p>

<ul>
  <li>the <strong>average waiting time</strong> is $(0+24 + 27)/3 = 17$ milliseconds</li>
</ul>

<p>If the processes <em>arrive in the order P2, P3, P1</em>, however, the results will be as shown in the following Gantt chart</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_11-25-06.png" alt="" /></p>

<p>where:</p>

<ul>
  <li>The <strong>average waiting time</strong> is now $(6 + 0 + 3)/3 = 3$ milliseconds. This reduction is substantial.</li>
</ul>

<h4 id="shortest-job-first-scheduling">Shortest-Job-First Scheduling</h4>

<p>This algorithm associates with each process the <em>length of the process’s <strong>next</strong> CPU burst</em>.</p>

<blockquote>
  <p><strong>Shortest-Job-First Scheduling</strong></p>

  <ul>
    <li>When the CPU is available, it is assigned to the process that has the smallest <strong>next</strong> CPU burst.</li>
    <li>The real difficulty with the algorithm is knowing the <em>length of the next CPU request.</em>
      <ul>
        <li>This is often <em>guessed</em> using the <strong>exponential average</strong> of the measured lengths of previous CPU bursts</li>
      </ul>
    </li>
    <li>The SJF algorithm can be either <strong>preemptive</strong> or <strong>non-preemptive</strong>.
      <ul>
        <li>The choice arises when a new process arrives at the ready queue while a previous process is still executing. The next CPU burst of the <em>newly arrived process may be shorter than what is left of the currently executing process</em>. A preemptive SJF algorithm will <em>preempt the currently executing process</em></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Exponential Average Method</strong></p>

  <ul>
    <li>
      <p>Let $t_n$ be the <em>length</em> of the $n$-th CPU burst, and let $\tau_{n+1}$ be our <em>predicted value</em> for the next CPU burst. Then, for $\alpha$, $0 \le \alpha \le 1$, define:
\(\tau_{n+1} = \alpha t_n + (1-\alpha)\tau_{n}\)</p>
    </li>
    <li>
      <p>Notice that this means:</p>

      <ul>
        <li>$t_n$ contains our <em>most recent</em> information</li>
        <li>$\tau_n$ stores the <em>past history.</em></li>
      </ul>

      <p>because:
\(\tau_{n+1}=\alpha t_n + \left[(1-\alpha)\alpha t_{n-1}+(1-\alpha)^2\alpha t_{n-2}+...+(1-\alpha)^{n+1}\alpha t_{0}+(1-\alpha)^{n+1} \tau_{0}\right]\)
and the initial $\tau_0$ can be defined as <em>a constant</em> or as an <em>overall system average</em></p>
    </li>
  </ul>
</blockquote>

<p><em>For Example: Exponential Average</em></p>

<p>Taking $\alpha=1/2$ and $\tau_0 = 10$</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_13-02-53.png" style="zoom:80%;" /></p>

<hr />

<p><em>For Example: Preemptive SJF</em>:</p>

<p>Consider the following four processes with <strong>next burst</strong> time:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_13-05-22.png" alt="" /></p>

<p>Then, the <em>preemptive SJF</em> will do:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_13-05-55.png" alt="" /></p>

<p>where:</p>

<ul>
  <li>for example, process $P_2$ arrives at time 1. The remaining time for process $P_1$ (7 milliseconds) is larger than the time required by process $P_2$ (4 milliseconds), <em>so process $P_1$ is preempted</em>, and process $P_2$ is scheduled</li>
  <li>The <em>average waiting time</em> for this example is $[(10 − 1) + (1 − 1) + (17 − 2) + (5 − 3)]/4 = 26/4 = 6.5 $milliseconds. Non-preemptive SJF scheduling would result in an average waiting time of $7.75$ milliseconds.</li>
</ul>

<hr />

<blockquote>
  <p><strong>Disadvantages</strong></p>

  <ol>
    <li>
      <p>Obviously one thing is that the prediction might not always be accurate</p>
    </li>
    <li>
      <p>Some sort of <em>starving</em> might happen</p>
    </li>
    <li>
      <p>Interactive Processes, such as Web Browsers that <em>will be running for a long time</em> but <strong>we would like it to be high responsiveness</strong>.</p>

      <ul>
        <li>a solution to this would be to using a <em>multi-level feedback idea</em>, so that if you were <em>blocked (e.g. waiting for I/O)</em>, you will get popped up</li>
        <li>but then this <em>does not solve the <code class="language-plaintext highlighter-rouge">Zoom</code> application problem</em>. (always running, but also high priority)</li>
      </ul>

      <p>Therefore, today, many schedulers have <strong>removed SJF as a scheduling policy</strong>.</p>
    </li>
  </ol>
</blockquote>

<h4 id="priority-scheduling">Priority Scheduling</h4>

<blockquote>
  <p><strong>Priority Scheduling</strong></p>

  <ul>
    <li>A <em>priority is associated with each process</em>, and the CPU is allocated to the <em>process with the highest priority</em>.
      <ul>
        <li>The SJF algorithm is a special case of the general priority-scheduling algorithm, where <em>priority</em> (p) is the <em>inverse of the (predicted) next CPU burst</em>.</li>
      </ul>
    </li>
    <li>Priority scheduling can be either preemptive or non-preemptive. When a <em>new process arrives</em> at the ready queue:
      <ul>
        <li>A preemptive priority scheduling algorithm will <em>preempt the CPU if the priority of the newly arrived process is higher</em> than the priority of the currently running process</li>
        <li>A non-preemptive priority scheduling algorithm will simply put the <em>new process at the head of the ready queue</em>.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Priority of a Process</strong></p>

  <ul>
    <li>Priorities can be defined either <em>internally</em> or <em>externally</em>.
      <ol>
        <li><strong>Internally</strong> defined priorities use <em>some measurable quantity</em> or quantities to compute the priority
of a process. For example, time limits, memory requirements, etc.</li>
        <li><strong>External</strong> priorities are set by criteria <em>outside the operating system</em>, such as the importance of the process, the type and amount of funds being paid for computer use, etc.</li>
      </ol>
    </li>
    <li>Some systems use low numbers to represent low priority; others use low numbers for high priority
      <ul>
        <li><strong>In this text, we assume that low numbers represent high priority</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<p>Consider the following setup, assumed to have arrived at time 0 in the order $P_1, P_2,…, P_5$.</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_14-16-02.png" alt="" /></p>

<p>then the Gantt Chart gives:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_14-16-51.png" alt="" /></p>

<p>and the average waiting time is 8.2 milliseconds</p>

<blockquote>
  <p><strong>Disadvantages</strong></p>

  <ul>
    <li>A major problem with priority scheduling algorithms is indefinite blocking (here it refers to being in the ready queue but never becoming <code class="language-plaintext highlighter-rouge">running</code>), or <strong>starvation</strong>, i.e. leave some <em>low priority processes waiting indefinitely</em>.
      <ul>
        <li>A solution to this is the method of <strong>aging</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Aging</strong></p>

  <ul>
    <li>Aging involves <em>gradually increasing the priority of processes</em> that <em>wait</em> in the system for a long time.
      <ul>
        <li>For example, if priorities range from 127 (low) to 0 (high), we could increase the priority of a waiting process by 1 every 15 minutes</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Implementation-wise</strong></p>

  <ul>
    <li>
      <p>One problem here is that we might need to <em>search through the array to find the largest priority task</em>. However, since there is a <em>discrete number of priority</em>, this is how it becomes implemented commonly:</p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-09_12-18-58.png" style="zoom:80%;" /></p>

      <p>where we see that:</p>

      <ul>
        <li>each priority essentially has an array, then it is just a FIFO/Round Robin for each <em>priority level</em></li>
        <li>additionally, there could be a further optimization of storing an <em>array of bitmap</em> indicating which array has entries</li>
      </ul>

      <p>This is the <strong>actual idea of <code class="language-plaintext highlighter-rouge">rt</code> scheduling class in Linux</strong></p>
    </li>
  </ul>
</blockquote>

<h4 id="round-robin-scheduling">Round-Robin Scheduling</h4>

<p>The round-robin (RR) scheduling algorithm is designed especially for timesharing systems.</p>

<blockquote>
  <p><strong>Time Quantum</strong></p>

  <ul>
    <li>A time quantum is generally from 10 to 100 milliseconds in length. This is generally defined based on how you want to implement it.</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Round-Robin Scheduling</strong></p>

  <ul>
    <li>
      <p>Basically, It is similar to FCFS scheduling, but preemption is added to enable the system to switch between processes.</p>

      <ol>
        <li>New processes are added to the tail of the <strong>circular ready queue</strong>.</li>
        <li>The CPU scheduler picks the first process from the ready queue, <strong>sets a timer to interrupt after 1 time quantum</strong>, and dispatches the process.</li>
      </ol>
    </li>
    <li>
      <p>In the RR scheduling algorithm, <em>no process is allocated the CPU for more than 1 time quantum in a row</em> (unless it is the only runnable process)</p>
    </li>
    <li>
      <p>Notice that the <em>circular ready queue</em> makes it work such that if there is only <em>one runnable process</em> in total, it will “look like” this is happening:</p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_14-45-28.png" alt="" /></p>
    </li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<p>Consider the following set of processes that arrive at time 0, with the length of the CPU burst given in milliseconds:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_14-48-34.png" alt="" /></p>

<p>If I use a <strong>time quantum of 4 seconds</strong>:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_14-49-14.png" alt="" /></p>

<p>where:</p>

<ul>
  <li>$P_1$ waits for 6 milliseconds ($10 - 4$), $P_2$ waits for 4 milliseconds, and $P_3$ waits for 7 milliseconds. Thus, the <em>average waiting time</em> is $17/3 = 5.66$ milliseconds.</li>
</ul>

<hr />

<p><em>For Example</em></p>

<p>Given three processes of 10 time units each and a quantum of 1 time unit, and they are <em>all submitted at $t=0$,</em> then</p>

<ul>
  <li>the <em>average turnaround time</em> is $(28+29+30)/3=29$.</li>
</ul>

<p>If the time quantum is 10, however:</p>

<ul>
  <li>the <em>average turnaround time drops</em> to $(10+20+30)/3=20$.</li>
</ul>

<hr />

<blockquote>
  <p><strong>Choice for Time Quantum</strong></p>

  <ul>
    <li>If the context-switch time is approximately 10 percent of the time quantum, then about 10 percent of the CPU time will be spent in context switching. Thus
      <ul>
        <li>we want the <em>time quantum to be large with respect to the context switch time</em>.</li>
        <li>however, if the time quantum is extremely large, the RR policy becomes the same as FCFS policy. A rule of thumb is that <em>80 percent of the bursts should be shorter than the time CPU quantum</em>.</li>
      </ul>
    </li>
    <li>In practice, most modern systems have time quanta ranging from 10 to 100 milliseconds. The time required for a context switch is typically less than 10 microseconds</li>
  </ul>
</blockquote>

<h4 id="weighted-rr-and-weighted-fq">Weighted RR and Weighted FQ</h4>

<blockquote>
  <p><strong>Weighted RR</strong></p>

  <ul>
    <li>Basically, now the <strong>time slice</strong> for each <strong>running task</strong> is calculated based on:
\(\text{time quantum} \times \text{weight}\)</li>
  </ul>

  <p>where the <code class="language-plaintext highlighter-rouge">weight</code> could be assigned by a user</p>
</blockquote>

<blockquote>
  <p><strong>Problem with RR and WRR</strong></p>

  <ul>
    <li>In the end, they are similar, and they have the same problem of <em>causing an application to</em> <strong>freeze periodically</strong>, which would damage interactive-ness</li>
    <li>Also, it might be bugged if a user assigned <code class="language-plaintext highlighter-rouge">weight=3000</code>, which would be problematic</li>
  </ul>
</blockquote>

<p>However, the problem of <code class="language-plaintext highlighter-rouge">weight=3000</code> can be solved with <strong>Weighted Fair Queue</strong> (WFQ):</p>

<blockquote>
  <p><strong>Weighted Fair Queue</strong></p>

  <p>First, we need <strong>each task to have</strong></p>

  <ul>
    <li>an execution time <code class="language-plaintext highlighter-rouge">runtime</code></li>
    <li>a weighted associated <code class="language-plaintext highlighter-rouge">weight</code></li>
  </ul>

  <p>Then, the algorithm <strong>picks the smallest <code class="language-plaintext highlighter-rouge">vruntime</code>:</strong>
\(\frac{\text{runtime}}{\text{weight}} = \text{vruntime}\)
where:</p>

  <ul>
    <li>you will soon notice that the Linux <code class="language-plaintext highlighter-rouge">CFS</code> has <em>its idea based off from here</em></li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<p>Consider at <code class="language-plaintext highlighter-rouge">t=0</code>, three processes comes in with <code class="language-plaintext highlighter-rouge">weight=3,2,1</code> respectively:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-11_15-54-01.png" style="zoom: 33%;" /></p>

<p>where you will see that:</p>

<ul>
  <li>the net result <em>over time</em> would be $P_3$ will be ran <strong>3 times more often</strong> than $P_2$, and $P_2$ will be ran <strong>2 times more often</strong> than $P_1$</li>
  <li>one minor thing in the above is that at <code class="language-plaintext highlighter-rouge">t=0</code>, we don’t know who to run. This is solved by <strong>virtual running time</strong></li>
</ul>

<blockquote>
  <p><strong>Virtual Running Time</strong></p>

  <ul>
    <li>
      <p>This is defined as:
\(\text{vruntime} + \frac{\text{time quantum time}}{\text{weight}}\)
so that even at $t=0$, we have an <strong>offset</strong></p>

      <ul>
        <li>so if the <code class="language-plaintext highlighter-rouge">time_quantum = 1</code>, we would have:
          <ul>
            <li>at $t=0$, $P_3 = 1/3, P_2 = 1/2, P_1 = 1$</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Nominal Time</strong></p>

  <ul>
    <li>What if after <code class="language-plaintext highlighter-rouge">3000</code> cycles, a <strong>new process</strong> comes in? Then the <code class="language-plaintext highlighter-rouge">vruntime</code> of the existing process will be already large, such that the <em>new process will basically just run for a lot of cycles in a row</em></li>
    <li>This is solved by <strong>assigning a new process with a nominal time as <code class="language-plaintext highlighter-rouge">vruntime</code></strong>
      <ul>
        <li>e.g. the nominal time could be the <em>average of <code class="language-plaintext highlighter-rouge">vruntime</code>s of other processes</em></li>
        <li>e.g. using the <code class="language-plaintext highlighter-rouge">global_virtual_time</code> $\frac{\text{Wall Time}}{\sum \text{weights}}$</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="multilevel-queue-scheduling">Multilevel Queue Scheduling</h4>

<p>This class of algorithms has been created for situations in which processes are easily <em>classified into different groups</em></p>

<ul>
  <li>e.g. foreground (interactive) processes and background (batch) processes</li>
</ul>

<blockquote>
  <p><strong>Multilevel Queue Scheduling</strong></p>

  <ul>
    <li>A <strong>multilevel queue scheduling</strong> algorithm <em>partitions the ready queue into several separate queues</em>.
      <ul>
        <li>Each queue has its own scheduling algorithm.</li>
        <li>This also means there must be <strong>scheduling among the queues</strong>:
          <ol>
            <li>commonly implemented as <strong>fixed-priority preemptive scheduling</strong>.
              <ul>
                <li>For example, the foreground queue may have absolute priority over the background queue</li>
              </ul>
            </li>
            <li><strong>time-slice</strong> among the queues
              <ul>
                <li>For instance, the <em>foreground queue</em> can be given <em>80 percent of the CPU time</em> for RR scheduling among its processes, while the <em>background queue</em> receives <em>20 percent of the CPU</em> to give to its processes on an FCFS basis.</li>
              </ul>
            </li>
          </ol>
        </li>
      </ul>
    </li>
    <li>The processes are <em>permanently assigned to one of the queues</em>, generally based on some property of the process, such as memory size, process priority, or process type.</li>
  </ul>
</blockquote>

<p><em>For Example</em>:</p>

<p>A multilevel queue scheduling algorithm with five queues, listed below <em>in order of (fixed) priority</em>:</p>
<ol>
  <li>System processes</li>
  <li>Interactive processes</li>
  <li>Interactive editing processes</li>
  <li>Batch processes</li>
  <li>Student processes</li>
</ol>

<p>Then:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-04_16-14-42.png" style="zoom: 80%;" /></p>

<p>where, in this case of a <em>fixed-priority preemptive scheduling among queues</em></p>

<ul>
  <li>No process in the batch queue, for example, could run unless the queues for system processes, interactive processes, and interactive editing processes were all empty.</li>
  <li>If an interactive editing process entered the ready queue while a batch process was running, the batch process would be preempted.</li>
</ul>

<h4 id="multilevel-feedback-queue-scheduling">Multilevel Feedback Queue Scheduling</h4>

<p>In multilevel queue scheduling, since processes do not change their foreground or background nature, this setup has the <em>advantage of low scheduling overhead</em>, but it is <strong>inflexible</strong>.</p>

<blockquote>
  <p><strong>Multilevel Feedback Queue Scheduling</strong></p>

  <ul>
    <li>The multilevel feedback queue scheduling algorithm, in contrast, allows a process to <strong>move between queues</strong>. The idea is to separate processes according to the characteristics of their CPU bursts.
      <ul>
        <li>If a process uses <em>too much CPU time at once</em>, it will be moved to <em>a lower-priority queue</em>. This scheme leaves I/O-bound and interactive processes in the higher-priority queues.</li>
        <li>a process that <em>waits too long in a lower-priority queue</em> may be moved to a <em>higher-priority queue</em> (so that starvation is prevented)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><em>For Example</em>:</p>

<p>Consider the following setup, with the top queue with the highest priority, and going down:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-05_09-40-39.png" style="zoom:80%;" /></p>

<p>where, <strong>same</strong> as multilevel queue scheduling:</p>

<ul>
  <li>processes in queue 2 will be <em>executed only if queues 0 and 1 are empty</em>, and etc.</li>
  <li>a process that arrives for queue 1 will <em>preempt a process in queue 2</em>, and etc.</li>
</ul>

<p>This scheduling algorithm gives <strong>highest priority to any process with a CPU burst of 8 milliseconds or less</strong> (e.g. a process that needs <code class="language-plaintext highlighter-rouge">8 ms CPU -&gt; I/O -&gt; 6 ms CPU</code> would also stay here)</p>

<ul>
  <li>for example, a process entering the ready queue is put in queue 0.
    <ol>
      <li>A process in queue 0 is given a time quantum of 8 milliseconds.</li>
      <li>If it does not finish within this time, it is <em>moved to the tail of queue 1</em>.</li>
      <li>If queue 0 is empty, the process at the head of queue 1 is given a quantum of 16 milliseconds.</li>
      <li>If it does not complete, it is <em>preempted and is put into queue 2</em></li>
      <li>etc.</li>
    </ol>
  </li>
</ul>

<hr />

<blockquote>
  <p><strong>Customization</strong></p>

  <p>In general, a multilevel feedback queue scheduler is defined by the following <strong>parameters</strong>:</p>

  <ul>
    <li>The number of queues</li>
    <li>The scheduling algorithm for each queue</li>
    <li>The method used to determine <em>when to upgrade</em> a process to a higher priority queue</li>
    <li>The method used to determine <em>when to demote</em> a process to a lower priority queue</li>
    <li>The method used to determine <em>which queue a process will enter</em> when that process needs service</li>
  </ul>
</blockquote>

<h3 id="thread-scheduling">Thread Scheduling</h3>

<p>First, some concepts will help.</p>

<blockquote>
  <p><strong>Lightweight Process (LWP)</strong></p>

  <ul>
    <li>
      <p>Light-weight process are threads in the <em>user space that acts as an interface</em> for the ULT to <em>access the physical CPU resources</em>. Thread library schedules which thread of a process to run on which LWP and how long.</p>
    </li>
    <li>
      <p>The <em>number of LWP created</em> by the thread library depends on the type of application.</p>
    </li>
    <li>in an <em>I/O bound application</em>, the number of LWP is equal to the number of the ULT (because  when an LWP is blocked on an I/O operation, then to invoke the other ULT the thread library needs to create and schedule another LWP)</li>
    <li>
      <p>in a <em>CPU bound application</em>, it depends only on the application.</p>
    </li>
    <li>
      <p><strong>Each LWP</strong> is attached to a <strong>separate kernel-level thread</strong>.</p>

      <p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20200519120539/first-boundary-of-thread-sheduling.png" alt="" /></p>
    </li>
  </ul>
</blockquote>

<p><strong>Scheduling of threads</strong> involves two boundary scheduling,</p>

<ul>
  <li><em>Scheduling of user level threads (ULT)</em> to kernel level threads (KLT) via <em>lightweight process (LWP)</em> by the application developer.</li>
  <li><em>Scheduling of kernel level threads</em> by the system scheduler to perform different unique OS functions.</li>
</ul>

<h4 id="contention-scope">Contention Scope</h4>

<blockquote>
  <p><strong>Contention Scope</strong></p>

  <p>The word contention here refers to the <strong>competition or fight among the User level threads to access the kernel resources</strong>. Thus, this control defines the extent to which and <strong>where contention takes place</strong>.</p>

  <ol>
    <li><strong>Process Contention Scope (PCS) –</strong>
The contention takes place among threads <em>(ULT) within a same process</em>. The thread library schedules the <em>high-prioritized</em> PCS thread to access the resources <em>via available LWPs</em> (priority as specified by the application developer during thread creation).</li>
    <li><strong>System Contention Scope (SCS) –</strong>
The contention takes place among <em>all (KLT) threads in the system</em>. In this case, <em>every SCS thread is associated to each LWP</em> by the thread library and are scheduled by the system scheduler to access the kernel resources.</li>
  </ol>
</blockquote>

<h4 id="pthread-scheduling">Pthread Scheduling</h4>

<p>Pthreads identifies the following <em>contention scope values</em>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PTHREAD_SCOPE_PROCESS</code> schedules threads using PCS scheduling.</li>
  <li><code class="language-plaintext highlighter-rouge">PTHREAD_SCOPE_SYSTEM</code> schedules threads using SCS scheduling.</li>
</ul>

<p>The Pthread IPC (Interprocess Communication) provides two functions for <strong>getting and setting the contention scope policy</strong>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_attr_setscope(pthread_attr t *attr, int scope)</code></li>
  <li><code class="language-plaintext highlighter-rouge">pthread_attr_getscope(pthread_attr t *attr, int *scope)</code></li>
</ul>

<p>where:</p>

<ul>
  <li>The first parameter for both functions contains a <em>pointer to the attribute set</em> for the thread.</li>
  <li>The second parameter for the <code class="language-plaintext highlighter-rouge">pthread_attr_setscope()</code> function is passed either the <code class="language-plaintext highlighter-rouge">PTHREAD_SCOPE_SYSTEM</code> or the <code class="language-plaintext highlighter-rouge">PTHREAD_SCOPE_PROCESS</code> value, indicating how the contention scope is to be set.
    <ul>
      <li>In the case of <code class="language-plaintext highlighter-rouge">pthread_attr_getscope()</code>, this second parameter contains a <em>pointer to an int value</em> that is set to the current value of the contention scope.</li>
      <li>If an <em>error occurs</em>, each of these functions returns a <em>nonzero value</em>.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>For example, Linux and Mac OS X systems allow <strong>only</strong> <code class="language-plaintext highlighter-rouge">PTHREAD_SCOPE_SYSTEM</code></li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#define NUM THREADS 5
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">scope</span><span class="p">;</span>
    <span class="n">pthread</span> <span class="n">t</span> <span class="n">tid</span><span class="p">[</span><span class="n">NUM</span> <span class="n">THREADS</span><span class="p">];</span>
    <span class="n">pthread</span> <span class="n">attr</span> <span class="n">t</span> <span class="n">attr</span><span class="p">;</span>
    <span class="cm">/* get the default attributes */</span>
    <span class="n">pthread</span> <span class="n">attr</span> <span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
    <span class="cm">/* first inquire on the current scope */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pthread</span> <span class="n">attr</span> <span class="n">getscope</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scope</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Unable to get scheduling scope</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">scope</span> <span class="o">==</span> <span class="n">PTHREAD</span> <span class="n">SCOPE</span> <span class="n">PROCESS</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"PTHREAD SCOPE PROCESS"</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">scope</span> <span class="o">==</span> <span class="n">PTHREAD</span> <span class="n">SCOPE</span> <span class="n">SYSTEM</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"PTHREAD SCOPE SYSTEM"</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Illegal scope value.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* set the scheduling algorithm to PCS or SCS */</span>
    <span class="n">pthread</span> <span class="n">attr</span> <span class="n">setscope</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD</span> <span class="n">SCOPE</span> <span class="n">SYSTEM</span><span class="p">);</span>
    <span class="cm">/* create the threads */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM</span> <span class="n">THREADS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">pthread</span> <span class="n">create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span><span class="n">runner</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="cm">/* now join on each thread */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM</span> <span class="n">THREADS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">pthread</span> <span class="n">join</span><span class="p">(</span><span class="n">tid</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/* Each thread will begin control in this function */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">runner</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* do some work ... */</span>
    <span class="n">pthread</span> <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="multi-processor-scheduling">Multi-Processor Scheduling</h3>

<p>If multiple CPUs are available, <em>load sharing becomes possible</em> - but scheduling problems become correspondingly <em>more complex</em>.</p>

<ul>
  <li>e.g. consider a system with an device attached to a private bus of one processor I/O</li>
</ul>

<h4 id="approaches-to-multiple-processor-scheduling">Approaches to Multiple-Processor Scheduling</h4>

<blockquote>
  <p><strong>Asymmetric Multiprocessing</strong></p>

  <ul>
    <li><em>all scheduling decisions</em>, I/O processing, and other system activities <em>handled by a single processor</em>— the master server. The other processors execute only user code.</li>
    <li>simple because only one processor accesses the system data structures, <strong>reducing the need for data sharing</strong>.</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Symmetric Multiprocessing (SMP)</strong></p>

  <ul>
    <li>each processor is <em>self-scheduling</em>. All processes may be in a <em>common ready queue</em>, or each processor may have its own private queue of ready processes</li>
    <li>if we have multiple processors trying to <strong>access and update a common data structure</strong>, the scheduler must be programmed carefully. We must ensure that <em>two separate processors do not choose to schedule the same process</em></li>
  </ul>
</blockquote>

<p><em>Virtually all modern operating systems support SMP</em>, including Windows, Linux, and Mac OS X.</p>

<h4 id="processor-affinity">Processor Affinity</h4>

<blockquote>
  <p><em>Reminder</em></p>

  <ul>
    <li>The <strong>data most recently accessed</strong> by the process <strong>populate the cache</strong> for the processor. As a result, successive memory accesses by the process are often satisfied in cache memory</li>
  </ul>

  <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-05_12-00-34.png" style="zoom:80%;" /></p>
</blockquote>

<p>Now consider what happens if the <em>process migrates to another processor</em>.</p>

<ul>
  <li>The contents of cache memory must be <em>invalidated</em> for the first processor</li>
  <li>and the cache for the second processor must be <em>repopulated</em></li>
</ul>

<p>Therefore <strong>most SMP</strong> systems try to <strong>avoid migration of processes from one processor to another</strong> and instead attempt to keep a process running on the same processor.</p>

<blockquote>
  <p><strong>Processor Affinity</strong></p>

  <ul>
    <li>A process has an <em>affinity for the processor on which it is currently running</em>, i.e. avoid migration of processes from one processor to another</li>
    <li>Processor affinity takes several forms:
      <ol>
        <li>Soft affinity</li>
        <li>Hard affinity</li>
      </ol>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Soft Affinity</strong></p>

  <ul>
    <li>Operating system has a policy of attempting to keep a process running on the same processor, but not guaranteeing that it will do so.</li>
    <li>Here, the operating system will attempt to keep a process on a single processor, but it is <em>possible for a process to migrate between processors</em></li>
  </ul>
</blockquote>

<p>Linux implements soft affinity but it also provides the system call, which supports <code class="language-plaintext highlighter-rouge">sched_setaffinity()</code> hard affinity.</p>

<blockquote>
  <p><strong>Hard Affinity</strong></p>

  <ul>
    <li>allowing a process to specify a subset of processors on which it may run</li>
  </ul>
</blockquote>

<h4 id="load-balancing">Load Balancing</h4>

<blockquote>
  <p><strong>Load Balancing</strong></p>

  <ul>
    <li>Load balancing attempts to <em>keep the workload evenly distributed across all processors</em> in an <strong>SMP</strong> system.
      <ul>
        <li>It is important to note that load balancing is typically <strong>necessary</strong> only on systems where each processor has its own <strong>private queue of eligible processes to execute</strong>. (On systems with a common run queue, load balancing is often unnecessary, because once a processor becomes idle, it immediately extracts a runnable process from the common run queue.)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>There are <em>two general approaches</em> to load balancing :</p>

<ol>
  <li><strong>Push Migration –</strong> In push migration a <em>task</em> routinely checks the load on each processor and if it finds an imbalance then it <em>evenly distributes load on each processors</em> by moving the processes from overloaded to idle or less busy processors.</li>
  <li><strong>Pull Migration –</strong> Pull Migration occurs when an <em>idle processor pulls a waiting task</em> from a busy processor for its execution.</li>
</ol>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>Load balancing often <strong>counteracts the benefits of processor affinity</strong>, so that either pulling or pushing a process from one processor to another removes this benefit</li>
  </ul>
</blockquote>

<h4 id="multicore-processors">Multicore Processors</h4>

<blockquote>
  <p><em>Reminder</em></p>

  <ul>
    <li>Each <em>core</em> maintains its architectural state and thus appears to the operating system to be a separate <strong>physical processor</strong></li>
    <li>From an operating-system perspective, each <em>hardware thread</em> appears as a <strong>logical processor</strong> that is available to run a software thread</li>
    <li>Thus, on a <em>dual-threaded, dual-core system</em>, four logical processors are presented to the operating system.</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Dual-Threaded Processor Core</strong></p>

  <ul>
    <li>Basically this attempts to solve the problem of a <strong>memory stall</strong>:
      <ul>
        <li>when a processor accesses <em>memory</em>, it spends a significant amount of time waiting for the data to become available. This situation, known as a memory stall, may occur for various reasons, such as a <em>cache miss</em></li>
      </ul>
    </li>
    <li>Therefore, recent hardware designs multithreaded processor cores in which <strong>two (or more) hardware threads are assigned to each core</strong>. That way, if one thread stalls while waiting for memory <code class="language-plaintext highlighter-rouge">M</code>, the core can switch to another thread.</li>
  </ul>

  <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-05_12-43-25.png" style="zoom:80%;" /></p>
</blockquote>

<p>However, this also means that <strong>multithreaded multicore processor</strong> actually <strong>requires two different levels of scheduling</strong>.</p>

<ol>
  <li>Scheduling decisions that must be made by the operating system as it <em>chooses which software thread to run</em> on each hardware thread (logical processor). Here, operating system may choose any scheduling algorithm that we have discussed before.</li>
  <li>Scheduling specifies how <em>each core decides which hardware thread to run</em>
    <ul>
      <li>for example, the UltraSPARC T3 uses a simple round robin algorithm to schedule the eight hardware threads to each core.</li>
    </ul>
  </li>
</ol>

<h3 id="real-time-cpu-scheduling">Real-Time CPU Scheduling</h3>

<blockquote>
  <p><strong>Real Time OS</strong></p>

  <ul>
    <li><strong>Real time operating systems (RTOS)</strong> are used in environments where a large number of <em>events</em>, mostly <em>external</em> to the computer system, <strong>must</strong> <em>be accepted and processed in a short time or within certain deadlines</em>.</li>
  </ul>
</blockquote>

<p>The real time operating systems can be of <em>2 types:</em></p>

<ol>
  <li>
    <p><strong>Hard Real Time operating system:</strong></p>

    <p>These operating systems <em>guarantee</em> that <em>critical tasks be completed within a range of time</em>.</p>

    <p>For example, a robot is hired to weld a car body, if robot welds too early or too late, the car cannot be sold, so it is a hard real time system that require to complete car welding by robot hardly on the time.</p>
  </li>
  <li>
    <p><strong>Soft real time operating system:</strong></p>

    <p>This operating systems provides <em>some relaxation in time limit</em>.</p>
  </li>
</ol>

<h4 id="minimizing-latency">Minimizing Latency</h4>

<blockquote>
  <p><strong>Minimizing Latency</strong></p>

  <ul>
    <li>When an event occurs, the system must respond to and service it as quickly as possible. We refer to <strong>event latency</strong> as the <em>amount of time that elapses from when an event occurs to when it is serviced</em></li>
  </ul>

  <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-05_14-59-01.png" style="zoom:80%;" /></p>
</blockquote>

<p><strong>Two types of latencies</strong> affect the performance of real-time systems:</p>

<ol>
  <li>Interrupt latency</li>
  <li>Dispatch latency</li>
</ol>

<blockquote>
  <p><strong>Interrupt Latency</strong></p>

  <ul>
    <li>Interrupt latency refers to the period of time <em>from the arrival of an interrupt</em> at the CPU to the <em>start of the routine that services</em> the interrupt</li>
    <li>minimize interrupt latency to ensure that <strong>real-time tasks receive immediate attention</strong></li>
    <li>Recall that when an interrupt occurs, the operating system must
      <ol>
        <li>first complete the instruction it is executing</li>
        <li>determine the type of interrupt that occurred</li>
        <li>save the state of the current process</li>
        <li>service the interrupt using the specific interrupt service routine (ISR).</li>
      </ol>
    </li>
  </ul>

  <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-05_15-01-10.png" style="zoom:80%;" /></p>
</blockquote>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>One important factor contributing to interrupt latency is the amount of time <strong>interrupts may be disabled</strong> while kernel data structures are being updated. Real-time operating systems require that <em>interrupts be disabled for only very short periods of time.</em></li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Dispatch Latency</strong></p>

  <ul>
    <li>The amount of time required for the scheduling <em>dispatcher to stop one process</em> and <em>start another</em> is known as <strong>dispatch latency</strong>.</li>
    <li>Providing real-time tasks with immediate access to the CPU mandates that real-time operating systems minimize this latency as well.
      <ul>
        <li>The most effective technique for keeping dispatch latency low is to provide <em>preemptive kernels</em></li>
      </ul>
    </li>
  </ul>

  <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-05_15-05-11.png" style="zoom:80%;" /></p>

  <p>where the <em>conflict phase</em> of dispatch latency has <strong>two components</strong>:</p>

  <ol>
    <li><em>Preemption</em> of any process running in the kernel</li>
    <li><em>Release</em> by low-priority processes of <em>resources</em> needed by a high-priority process</li>
  </ol>
</blockquote>

<h4 id="priority-based-scheduling">Priority-Based Scheduling</h4>

<p>The most important feature of a real-time operating system is to <em>respond immediately to a real-time process</em> as soon as that process requires the CPU.</p>

<ul>
  <li>As a result, the scheduler for a real-time operating system must <em>support a</em>
<em>priority-based algorithm</em> with preemption</li>
  <li>Linux, Windows, and Solaris operating systems, each of these systems assigns <strong>real-time processes the highest scheduling priority</strong></li>
</ul>

<blockquote>
  <p><strong>Characteristics of Real-Time Processes</strong></p>

  <ol>
    <li>
      <p>First, the processes are considered periodic. That is, they require the CPU at constant intervals (periods).</p>
    </li>
    <li>
      <p>Once a periodic process has acquired the CPU, it has:</p>

      <ul>
        <li>a <strong>fixed processing time</strong> $t$</li>
        <li>a <strong>deadline</strong> $d$ by which it must be serviced by the CPU <em>by the start of its next period</em></li>
        <li>a <strong>period</strong> $p$.</li>
      </ul>
    </li>
    <li>
      <p>The <em>rate</em> of a periodic task is $1/p$.</p>
    </li>
    <li>
      <p>The relationship of the processing time, the deadline, and the period can be expressed as
\(0 ≤ t ≤ d ≤ p.\)</p>
    </li>
  </ol>

  <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-06_12-11-02.png" style="zoom:80%;" /></p>
</blockquote>

<p>Therefore, this form of scheduling means a <em>process may have to announce its deadline requirements</em> to the scheduler.</p>

<p>Then, using a technique known as an <strong>admission-control algorithm</strong>, the scheduler does one of two things.</p>

<ol>
  <li>It either <em>admits</em> the process, guaranteeing that the process will complete on time</li>
  <li>or <em>rejects</em> the request as impossible if it cannot guarantee that the task will be serviced by its deadline.</li>
</ol>

<h4 id="rate-monotonic-scheduling">Rate-Monotonic Scheduling</h4>

<blockquote>
  <p><strong>Rate-Monotonic Scheduling</strong></p>

  <ul>
    <li>The rate-monotonic scheduling algorithm schedules periodic tasks using a <strong>static priority policy</strong> with <strong>preemption</strong></li>
    <li>Upon entering the system, each periodic task is <em>assigned a priority</em> <strong>inversely based on its period</strong>.
      <ul>
        <li>so, the shorter the period, the higher the priority; the longer the period, the lower the priority</li>
      </ul>
    </li>
    <li>rate-monotonic scheduling <em>assumes</em> that the <em>processing time</em> of a periodic process is the <em>same for each CPU burst</em></li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<p>We have two processes, P1 and P2.</p>

<ul>
  <li>The <em>periods</em> for $P_1$ and $P_2$ are $50$ and $100$, respectively—that is, $p_1 = 50$ and $p_2 = 100$.</li>
  <li>The <em>processing times</em> are $t_1 = 20$ for $P_1$ and $t_2 = 35$ for $P_2$.</li>
  <li>The <em>deadline</em> for each process requires that it complete its CPU burst by the start of its next period.</li>
</ul>

<p>First, we need to consider if it is at all possible.</p>

<ul>
  <li>If we measure the CPU utilization of a process $P_i$ as the ratio of its burst to its period—$t_i/p_i$ —the CPU utilization of $P_1$ is $20/50 = 0.40$ and that of $P_2$ is $35/100 = 0.35$, for a <strong>total CPU utilization of $75$ percent.</strong></li>
  <li>Therefore, it <strong>seems</strong> we can schedule these tasks in such a way that both meet their deadlines and still leave the CPU with available cycles</li>
</ul>

<p>Now suppose we use rate-monotonic scheduling, in which we assign $P_1$ a <strong>higher priority</strong> than $P_2$ because the period of $P_1$ is shorter than that of $P_2$.</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-06_12-19-45.png" alt="" /></p>

<p>where we see that it works:</p>

<ul>
  <li>$P_2$ completes its burst at time $75$, also meeting its first deadline. The
CPU system is idle until time $100$, when $P_1$ is scheduled again.</li>
</ul>

<hr />

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>
      <p>Rate-monotonic scheduling is considered <strong>optimal</strong> in that if a set of processes cannot be scheduled by this algorithm, it <em>cannot be scheduled by any other algorithm</em> that assigns static priorities</p>
    </li>
    <li>
      <p>Despite being optimal, then, rate-monotonic scheduling has a limitation:</p>

      <ul>
        <li><strong>CPU utilization is bounded</strong>, and it is not always possible fully to maximize CPU resources. The <strong>worst-case CPU utilization</strong> for scheduling $N$ processes is
\(N(2^{1/N}-1)\)</li>
      </ul>
    </li>
  </ul>

</blockquote>

<h4 id="earliest-deadline-first-scheduling">Earliest-Deadline-First Scheduling</h4>

<blockquote>
  <p><strong>Earliest-Deadline-First Scheduling</strong></p>

  <ul>
    <li>Earliest-deadline-first (EDF) scheduling <em>dynamically assigns priorities</em> according to deadline (i.e. deadline changes as time proceeds).</li>
    <li>Under the EDF policy, when a process becomes runnable, it must <em>announce its deadline requirements</em> to the system</li>
    <li><em>theoretically</em>, it can schedule processes so that each process <em>can meet its deadline requirements</em> and <em>CPU utilization will be 100 percent</em>.</li>
    <li><em>In practice</em>, however, it is <em>impossible</em> to achieve this level of CPU utilization due to the cost of context switching between processes and interrupt handling.</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Difference with Rate-Monotonic Algorithm</strong></p>

  <ul>
    <li>Unlike the rate-monotonic algorithm, EDF scheduling <strong>does not require</strong> that processes be <strong>periodic</strong>, <strong>nor</strong> must a process require a <strong>constant amount of CPU time per burst</strong>.</li>
    <li>The <strong>only requirement</strong> is that a process <strong>announce its deadline</strong> to the scheduler when it becomes runnable.</li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<p>Consider the setup of</p>

<ul>
  <li>$P_1$ has values of $p_1 = 50$ and $t_1 = 25$</li>
  <li>$P_2$ has values of $p_2 = 80$ and $t_2 = 35$</li>
  <li>The <em>deadline</em> for each process requires that it complete its CPU burst by the start of its next period</li>
</ul>

<p>The <strong>EDF scheduling</strong> of these processes is shown below:</p>

<ul>
  <li>note that rate-monotonic algorithm actually <em>cannot</em> solve this problem</li>
</ul>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-06_12-43-54.png" alt="" /></p>

<p>where we see that:</p>

<ul>
  <li>Process $P_1$ has the earliest deadline, so its initial <em>priority</em> is higher than that of process $P_2$.</li>
  <li>However, whereas rate-monotonic scheduling allows $P_1$ to preempt $P_2$, at the beginning of its next period at time $50$, EDF scheduling <strong>allows process</strong> <strong>P2 to continue running</strong>. This is because $P_2$ now has a <strong>higher priority</strong> than $P_1$ because its <strong>next deadline (at time $80$) is earlier</strong> than that of $P_1$ (at time $100$).</li>
</ul>

<h3 id="os-scheduling-examples">OS Scheduling Examples</h3>

<p>Here, we are In fact describing</p>

<ul>
  <li>the scheduling of <strong>kernel threads</strong> with <em>Solaris</em> and <em>Windows</em> systems</li>
  <li>the scheduling of <strong>tasks</strong> with the <em>Linux</em> scheduler.</li>
</ul>

<h4 id="linux-scheduling">Linux Scheduling</h4>

<p>In release 2.6.23 of the kernel, the <strong>Completely Fair Scheduler (CFS)</strong> became the <em>default Linux scheduling algorithm</em>.</p>

<blockquote>
  <p><strong>Scheduling in Linux</strong></p>

  <ul>
    <li>
      <p>Scheduling in the Linux system is based on <strong>scheduling classes</strong>.</p>

      <p><em>Each class</em> is assigned a <em>specific priority</em>. By using different scheduling classes, the kernel can <em>accommodate different scheduling algorithms</em> based on the needs of the system and its processes.</p>

      <p>(Essentially, it <em>looks like a multi-level queue</em> system)</p>
    </li>
    <li>To decide which task to run next, the scheduler <strong>selects the highest-priority task</strong> belonging to the <strong>highest-priority scheduling class.</strong></li>
    <li>Standard Linux kernels implement two scheduling classes:
      <ol>
        <li>a <em>default scheduling class</em> using the <em>CFS</em> scheduling algorithm</li>
        <li>a <em>real-time scheduling class</em>.</li>
      </ol>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>CFS in Linux</strong></p>

  <ul>
    <li>
      <p>the CFS scheduler assigns a proportion of CPU processing time to each task. This proportion is <em>calculated based on the</em> <strong>nice value</strong> assigned to each task.</p>
    </li>
    <li>
      <p><strong>Nice values</strong> range from $−20$ to $+19$, where a numerically <em>lower nice value indicates a higher relative priority</em>. (i.e. low nice value means being not “nice” to other processes)</p>
    </li>
    <li>
      <p>CFS doesn’t use discrete values of time slices and instead identifies a <strong>targeted latency</strong>, which is an <em>interval of time</em> during which every runnable task <em>should run at least once</em>.</p>

      <ul>
        <li>Therefore, proportions of CPU time are allocated from the value of targeted latency.</li>
      </ul>
    </li>
    <li>
      <p>The CFS scheduler doesn’t directly assign priorities. Rather, it records how long each task has run by <em>maintaining the virtual run time of each task</em> using the per-task variable <code class="language-plaintext highlighter-rouge">vruntime</code>.</p>

      <ul>
        <li>
          <p>The virtual run time is associated with a <strong>decay factor based on the priority (<code class="language-plaintext highlighter-rouge">nice</code> value) of a task</strong>: lower-priority tasks have higher rates of decay than higher-priority tasks. 
\(vruntime += timeRanJustNow * decayOrGrowthFactor\)</p>
        </li>
        <li>
          <p>For tasks at normal priority (nice values of 0), virtual run time is identical to actual physical run time.</p>

          <p>However, if a <em>lower-priority task</em> runs for 200 milliseconds, its <code class="language-plaintext highlighter-rouge">vruntime</code> will be higher than 200 milliseconds</p>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>In summary:</p>

<ul>
  <li><strong>proportion of processing time</strong> is calculated based on <code class="language-plaintext highlighter-rouge">nice</code> value</li>
  <li><strong>priority</strong> is calculated based on <code class="language-plaintext highlighter-rouge">vruntime</code>, which depends on <em>actual runtime</em> and <code class="language-plaintext highlighter-rouge">nice</code> <em>value</em></li>
</ul>

<p>Since this is <em>priority-based preemption</em>, this is how the processes are structured using a red-black tree (priority queue)</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-06_13-10-35.png" style="zoom:80%;" /></p>

<p>where tasks that have been given more processing time (<em>lower priority</em>) are on the <em>right side</em></p>

<p><em>For Example</em></p>

<p>Assume that two tasks have the <strong>same nice values</strong>. One task is <strong>I/O-bound</strong> and the other is <strong>CPU-bound</strong>.</p>

<ul>
  <li>Typically, the I/O-bound task will run only for short periods before blocking for additional I/O, and the CPU-bound task will exhaust its time period whenever it has an opportunity to run on a processor.</li>
</ul>

<p>Therefore, the value of <code class="language-plaintext highlighter-rouge">vruntime</code> will eventually be <em>lower for the I/O-bound task</em> than for the CPU-bound task, giving the I/O-bound task higher priority than the CPU-bound task.</p>

<p>At that point, if the CPU-bound task is executing when the I/O-bound task becomes eligible to run (for example, when I/O the task is waiting for becomes available), the <em>I/O-bound task will preempt the CPU-bound task</em>.</p>

<hr />

<blockquote>
  <p><strong>Real-Time Tasks In Linux</strong></p>

  <ul>
    <li>Any task scheduled using either the <code class="language-plaintext highlighter-rouge">SCHED_FIFO</code> or the <code class="language-plaintext highlighter-rouge">SCHED_RR</code> real-time policy runs at a <em>higher priority than normal</em></li>
    <li>Linux uses two separate priority ranges, one for real-time tasks
and a second for normal tasks.</li>
  </ul>

  <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-06_13-17-01.png" style="zoom:80%;" /></p>

  <ul>
    <li><strong>Normal</strong> tasks are assigned a priority based on their <strong><code class="language-plaintext highlighter-rouge">nice</code> values</strong>, where a value of $–20$ maps to priority $100$ and a nice value of $+19$ maps to $139$</li>
    <li><strong>Real-time</strong> tasks are assigned <em>static priorities</em> within the range of $0$ to $99$, and normal (i.e. non real-time) tasks are assigned priorities from $100$ to $139$.</li>
  </ul>
</blockquote>

<h3 id="actual-linux-implementation">Actual Linux Implementation</h3>

<blockquote>
  <p><strong>Linux Scheduling</strong></p>

  <p>In general, the Linux scheduling is done in <code class="language-plaintext highlighter-rouge">kernel/sched/core.c</code>, and it has the <em>functionality of</em>:</p>

  <ol>
    <li><em>pick</em> the next task to run</li>
    <li><em>re-order</em> tasks on the run queue</li>
    <li><em>put</em> tasks on the run queue (e.g. when it is <code class="language-plaintext highlighter-rouge">runnable</code>)</li>
    <li><em>remove</em> tasks from run queue (e.g. when it is <code class="language-plaintext highlighter-rouge">blocked</code>)</li>
    <li>have different policies by having different <em>scheduling classes</em> (e.g. <code class="language-plaintext highlighter-rouge">real-time</code> scheduling class as an example for later section)</li>
  </ol>
</blockquote>

<p>In terms of code, this is what happened:</p>

<ol>
  <li>
    <p>we <strong>start</strong> with <code class="language-plaintext highlighter-rouge">schedule()</code> in <code class="language-plaintext highlighter-rouge">kernel/sched/core.c</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">asmlinkage</span> <span class="n">__visible</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">schedule</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
   
	<span class="n">sched_submit_work</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
        <span class="cm">/* here it does the main schedule */</span>
		<span class="n">__schedule</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
		<span class="n">sched_preempt_enable_no_resched</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">());</span>
	<span class="n">sched_update_worker</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">schedule</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>then Inside <code class="language-plaintext highlighter-rouge">__schedule()</code>: which does:</p>

    <ol>
      <li>
        <p>gets the run queue as well as the run queue lock</p>
      </li>
      <li>
        <p>picks the next task</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="n">notrace</span> <span class="nf">__schedule</span><span class="p">(</span><span class="n">bool</span> <span class="n">preempt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">switch_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
      
          
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
    <span class="cm">/* 1. gets the run queue as well as the run queue lock */</span>
    <span class="cm">/* RUN QUEUE PER CPU! */</span>
	<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
    <span class="cm">/* some code omitted */</span>
	<span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
          
          
    <span class="cm">/* 2. picks the next task */</span>
	<span class="n">switch_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nivcsw</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">preempt</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">prev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* not runnable tasks are removed */</span>
			<span class="n">deactivate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">DEQUEUE_SLEEP</span> <span class="o">|</span> <span class="n">DEQUEUE_NOCLOCK</span><span class="p">);</span>
      
			<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">in_iowait</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_iowait</span><span class="p">);</span>
				<span class="n">delayacct_blkio_start</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">switch_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nvcsw</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="cm">/* picks the next task */</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
    <span class="cm">/* some code omitted */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* if there is only one job, then prev = next since running job
         * by default is still on the queue
         */</span>
      
         <span class="cm">/* this is when the prev=current job stops running, and the next one starts*/</span>
		<span class="cm">/* Also unlocks the rq: */</span>
		<span class="n">rq</span> <span class="o">=</span> <span class="n">context_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_update_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RQCF_ACT_SKIP</span><span class="o">|</span><span class="n">RQCF_REQ_SKIP</span><span class="p">);</span>
		<span class="n">rq_unlock_irq</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
	<span class="p">}</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <p>then the <code class="language-plaintext highlighter-rouge">pick_next_task()</code> will go to:</p>

        <ul>
          <li>
            <p>this will call the <em>scheduling algorithm specific to each <code class="language-plaintext highlighter-rouge">sched_class</code></em></p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pick_next_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">class</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        
    <span class="cm">/*
	 * Optimization: we know that if all tasks are in the fair class we can
	 * call that function directly, but only if the @prev task wasn't of a
	 * higher scheduling class, because otherwise those loose the
	 * opportunity to pull in more work from other CPUs.
	 */</span>
    <span class="cm">/* this is just optimization since the DEFAULT sched class is CFS
     * therefore, it picks from this directly if the condition holds
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">idle_sched_class</span> <span class="o">||</span>
                <span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
               <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">==</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">.</span><span class="n">h_nr_running</span><span class="p">))</span> <span class="p">{</span>
        
        <span class="cm">/* 1. picks next task by a SCHEDULER CLASS */</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">fair_sched_class</span><span class="p">.</span><span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">RETRY_TASK</span><span class="p">))</span>
            <span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
        
        <span class="cm">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">))</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">idle_sched_class</span><span class="p">.</span><span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
        
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* CLASS SPECIFIC LOAD BALANCING before pick_next_task */</span>
    <span class="n">for_class_range</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idle_sched_class</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">balance</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rf</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
        
    <span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
        
    <span class="cm">/* 2. Picks by each SCHEDULER CLASS. MAIN ENTRY POINT */</span>
    <span class="n">for_each_class</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* calls the particular class's function */</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>            </div>
            <p>where:</p>

            <ul>
              <li>each ` struct sched_class *class<code class="language-plaintext highlighter-rouge"> would have its **own scheduling algorithm** </code>class-&gt;pick_next_task(rq, NULL, NULL);`, such as based on priority. This allows some customization.</li>
              <li>this basically looks like the mechanism of a <a href="#Multilevel-Queue-Scheduling">Multilevel Queue Scheduling</a></li>
            </ul>

            <blockquote>
              <p><em>For Example</em></p>

              <p>There is an idle <code class="language-plaintext highlighter-rouge">sched_class</code> which basically runs when there is no process running.</p>

              <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span>
<span class="nf">pick_next_task_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span>
		<span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>

	<span class="n">set_next_task_idle</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

<span class="cm">/* basically runs the a PREDEFINED IDLE task */</span>
	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* some code omitted here */</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">idle_sched_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* .next is NULL */</span>
	<span class="cm">/* no enqueue/yield_task for idle tasks */</span>

	<span class="cm">/* dequeue is not valid, we print a debug message there: */</span>
	<span class="p">.</span><span class="n">dequeue_task</span>		<span class="o">=</span> <span class="n">dequeue_task_idle</span><span class="p">,</span>

	<span class="p">.</span><span class="n">check_preempt_curr</span>	<span class="o">=</span> <span class="n">check_preempt_curr_idle</span><span class="p">,</span>

<span class="cm">/* defined pick_next_task function */</span>
	<span class="p">.</span><span class="n">pick_next_task</span>		<span class="o">=</span> <span class="n">pick_next_task_idle</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_prev_task</span>		<span class="o">=</span> <span class="n">put_prev_task_idle</span><span class="p">,</span>
    <span class="p">.</span><span class="n">set_next_task</span>          <span class="o">=</span> <span class="n">set_next_task_idle</span><span class="p">,</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">};</span>
</code></pre></div>              </div>
            </blockquote>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>When a <strong>new task is created</strong>, you will need to:</p>

    <ol>
      <li>assign <em>static priority number</em> (which will be later converted to nice values)</li>
      <li>assign <em>scheduling classes</em></li>
    </ol>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sched_fork</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
   
	<span class="n">__sched_fork</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_NEW</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">normal_prio</span><span class="p">;</span>
   
	<span class="n">uclamp_fork</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
   
	<span class="cm">/* 1. assign priority/ static priority */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_has_dl_policy</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">task_has_rt_policy</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">=</span> <span class="n">SCHED_NORMAL</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt_priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PRIO_TO_NICE</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">static_prio</span> <span class="o">=</span> <span class="n">NICE_TO_PRIO</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">normal_prio</span> <span class="o">=</span> <span class="n">__normal_prio</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">set_load_weight</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
   
		<span class="cm">/*
		 * We don't need the reset flag anymore after the fork. It has
		 * fulfilled its duty:
		 */</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_reset_on_fork</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
       
    <span class="cm">/* 2. assign schedulng class */</span>
   
	<span class="k">if</span> <span class="p">(</span><span class="n">dl_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rt_prio</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_sched_class</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">;</span>
       
    <span class="cm">/* some code omitted htere */</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <blockquote>
      <p><strong>Note</strong></p>

      <ul>
        <li>
          <p>Again, this <code class="language-plaintext highlighter-rouge">sched_fork</code> is <em>called</em> by <code class="language-plaintext highlighter-rouge">copy_process()</code> in <code class="language-plaintext highlighter-rouge">kernel/fork.c</code>, which will be <em>called</em> by <code class="language-plaintext highlighter-rouge">do_fork()</code>, from <code class="language-plaintext highlighter-rouge">fork()/clone()</code></p>

          <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">__latent_entropy</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">copy_process</span><span class="p">(</span>
					<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">trace</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kernel_clone_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pidfd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">multiprocess_signals</span> <span class="n">delayed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">pidfile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">clone_flags</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
    
	<span class="cm">/*
	 * Don't allow sharing the root directory with processes in a different
	 * namespace
	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">CLONE_NEWNS</span><span class="o">|</span><span class="n">CLONE_FS</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">CLONE_NEWNS</span><span class="o">|</span><span class="n">CLONE_FS</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
    
	<span class="cm">/* some code omitted here */</span>
    
	<span class="cm">/* Perform scheduler related setup. Assign this task to a CPU. */</span>
    <span class="cm">/* calls sched_fork */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">sched_fork</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
        
    <span class="cm">/* some code omitted hetre */</span>
        
    <span class="cm">/* and then duplicates the data from the other process */</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">dup_task_struct</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        
    <span class="cm">/* some code omitted herte */</span>
<span class="p">}</span>
</code></pre></div>          </div>

          <p>and then <code class="language-plaintext highlighter-rouge">dup_task_struct</code> will do:</p>

          <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">dup_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">stack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_struct</span> <span class="o">*</span><span class="n">stack_vm_area</span> <span class="n">__maybe_unused</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
    
	<span class="cm">/* some code omitted here */</span>
    
	<span class="n">err</span> <span class="o">=</span> <span class="n">arch_dup_task_struct</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">orig</span><span class="p">);</span>
  	  
	<span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>          </div>

          <p>which in turn calls the <em>architecture specific</em> <code class="language-plaintext highlighter-rouge">arch_dup_task_struct</code>:</p>

          <ul>
            <li>here, I am looking at the <code class="language-plaintext highlighter-rouge">x86</code> one:</li>
          </ul>

          <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">arch_dup_task_struct</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* just does a memory copy */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">arch_task_struct_size</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_VM86
</span>	<span class="n">dst</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">.</span><span class="n">vm86</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif
</span>    
	<span class="k">return</span> <span class="n">fpu__copy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>          </div>
        </li>
      </ul>
    </blockquote>
  </li>
</ol>

<hr />

<blockquote>
  <p><strong>Note</strong></p>

  <ol>
    <li>
      <p>In general (also mentioned above), there will be a <strong>private run queue per scheduler</strong></p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-09_11-33-24.png" alt="" /></p>

      <p>this is very common, because:</p>

      <ul>
        <li>if there is a <em>common run queue</em> for all CPUs, then there is the <em>bottleneck</em> of all reading/editing one run queue -&gt; needs locking
       - therefore, we need to somehow <strong>decide which run queues/CPU</strong> a process/task should go to</li>
      </ul>
    </li>
    <li>
      <p>If a <strong>process is created from <code class="language-plaintext highlighter-rouge">fork()</code></strong>, then by default it will <strong>inherit the scheduling class</strong> of its parent</p>
    </li>
  </ol>
</blockquote>

<h4 id="related-schedh">Related sched.h</h4>

<p>In general, you might need to change <strong>two <code class="language-plaintext highlighter-rouge">sched.h</code></strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">include/linux/sched.h</code></li>
  <li><code class="language-plaintext highlighter-rouge">kernel/sched/sched.h</code></li>
</ol>

<p>This section will focus on the <strong>example of the <code class="language-plaintext highlighter-rouge">real-time scheduling class</code></strong>.</p>

<p><strong>Inside the file <code class="language-plaintext highlighter-rouge">kernel/sched/sched.h</code></strong> for scheduling in Linux, which <strong>defines most of the structures</strong> in an almost <em>Object Oriented Fashion</em>.</p>

<p>Inside <code class="language-plaintext highlighter-rouge">kernel/sched/sched.h</code></p>

<ol>
  <li>
    <p>add the <code class="language-plaintext highlighter-rouge">rt_rq</code> to the per CPU <code class="language-plaintext highlighter-rouge">rq</code></p>
  </li>
  <li>
    <p>(if needed) add the <code class="language-plaintext highlighter-rouge">rt_rq</code> and class related <em>initialization</em> code</p>

    <ul>
      <li>
        <p>this will be <strong>called</strong> in <code class="language-plaintext highlighter-rouge">void __init sched_init(void)</code> inside <code class="language-plaintext highlighter-rouge">kernel/sched/core.c</code> at start up</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">__init</span> <span class="nf">sched_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* some code omitted here */</span>
     
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
     
		<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">raw_spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/* initializes RUN QUEUES */</span>
		<span class="n">init_cfs_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cfs</span><span class="p">);</span>
		<span class="n">init_rt_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">);</span>
		<span class="n">init_dl_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">dl</span><span class="p">);</span>
         <span class="cm">/* some code omitted here */</span>
	<span class="p">}</span>
    <span class="cm">/* some code omitted here */</span>
     
	<span class="cm">/* other initialization */</span>
	<span class="n">init_sched_fair_class</span><span class="p">();</span>
     
	<span class="n">init_schedstats</span><span class="p">();</span>
     
	<span class="n">psi_init</span><span class="p">();</span>
     
	<span class="n">init_uclamp</span><span class="p">();</span>
     
	<span class="n">scheduler_running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* defines the highest priority sched class */</span>
<span class="cp">#ifdef CONFIG_SMP
#define sched_class_highest (&amp;stop_sched_class)
#else
#define sched_class_highest (&amp;dl_sched_class)
#endif
</span>
<span class="cm">/* defines the "Parent" sched class structure */</span>
<span class="k">struct</span> <span class="n">sched_class</span> <span class="p">{</span>
    <span class="cm">/* 1. tells us what is the NEXT scheduling class afterwards */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">enqueue_task</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dequeue_task</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">yield_task</span><span class="p">)</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">yield_to_task</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">bool</span> <span class="n">preempt</span><span class="p">);</span>

	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">pick_next_task</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">);</span>
	<span class="cm">/* some code omitted here */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rq</span> <span class="p">{</span>
	<span class="cm">/* runqueue lock: */</span>
	<span class="n">raw_spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
    
    <span class="cm">/* some code omitted here */</span>

    <span class="cm">/* 1. add the `rt_rq` to the per CPU `rq` */</span>
	<span class="k">struct</span> <span class="n">cfs_rq</span>		<span class="n">cfs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_rq</span>		<span class="n">rt</span><span class="p">;</span>  <span class="cm">/* scheduling class specific rq  */</span>
	<span class="k">struct</span> <span class="n">dl_rq</span>		<span class="n">dl</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Real-Time classes' related field in a runqueue: */</span>
<span class="k">struct</span> <span class="n">rt_rq</span> <span class="p">{</span>
    <span class="cm">/* the actual queue for rt_rq */</span>
	<span class="k">struct</span> <span class="n">rt_prio_array</span>	<span class="n">active</span><span class="p">;</span>
    
    <span class="cm">/* some code omitted here */</span>
	<span class="k">struct</span> <span class="n">rq</span>		<span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_group</span>	<span class="o">*</span><span class="n">tg</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* 2. rt sched class initialization code */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">init_sched_rt_class</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li>essentially, the per CPU <code class="language-plaintext highlighter-rouge">struct rq</code> is just a <em>nominal placeholder</em> for the different run queues of the different  <code class="language-plaintext highlighter-rouge">sched_class</code></li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ol>
    <li>
      <p>You will see that in many <code class="language-plaintext highlighter-rouge">sched_class</code> implementations in kernel, <strong>not all methods need to be implemented</strong></p>

      <p>This also means that sometimes, if the kernel <em>has explicit checks</em> if a method is <code class="language-plaintext highlighter-rouge">null</code>, then it is fine. Some other times, you might need to <em>implement no-op functions</em>.</p>

      <p>For example:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* inside idle sched_class */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_curr_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></div>      </div>
    </li>
  </ol>
</blockquote>

<p>Now, for implementation, this is more important.</p>

<p><strong>Inside <code class="language-plaintext highlighter-rouge">include/linux/sched.h</code></strong>, we need to have:</p>

<ol>
  <li>
    <p>defines the <em>actual structure to be queued in the private run queues</em>. This is because, for <em>group scheduling mechanism</em> in Linux, so that sometimes you can enqueue group of tasks (not required for this course).</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_THREAD_INFO_IN_TASK
</span>	<span class="cm">/* some code omitted here */</span>
   
    <span class="cm">/* 1. defines the actual structure to be queued in the private run queues */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">rt_priority</span><span class="p">;</span> <span class="cm">/* rt class specific parameters */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span>	<span class="o">*</span><span class="n">sched_class</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_entity</span>		<span class="n">se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span>		<span class="n">rt</span><span class="p">;</span> <span class="cm">/* in the rq */</span>
    <span class="cm">/* some code omitted here */</span>
       
    <span class="cm">/* sometimes, a sched class can have MULTIPLE policies
     * in this case, this thing has to be set
     */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">policy</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>then, inside the <code class="language-plaintext highlighter-rouge">rt_priority</code>, this is inside <code class="language-plaintext highlighter-rouge">kernel/sched/sched.h</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">rt_prio_array</span> <span class="p">{</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">MAX_RT_PRIO</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* include 1 bit for delimiter */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queue</span><span class="p">[</span><span class="n">MAX_RT_PRIO</span><span class="p">];</span> <span class="cm">/* ARRAYS OF QUEUES */</span>
<span class="p">};</span>
</code></pre></div>    </div>

    <p>where:</p>

    <ul>
      <li>it uses an array of run queue because its implementation idea is similar to <a href="#Priority-Scheduling">Priority Scheduling</a></li>
    </ul>
  </li>
</ol>

<h4 id="real-time-sched-class-implementation">Real-time sched class Implementation</h4>

<p>Last but not least, let us look at the <em>actual implementations</em> for the needed methods</p>

<ul>
  <li>this is inside <code class="language-plaintext highlighter-rouge">kernel/sched/rt.c</code></li>
</ul>

<p>Here, we see that:</p>

<ol>
  <li>
    <p>The <em>implementation</em> of the <code class="language-plaintext highlighter-rouge">sched_class</code> object:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">rt_sched_class</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* next sched_class */</span>
	<span class="p">.</span><span class="n">next</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">fair_sched_class</span><span class="p">,</span>
    <span class="cm">/* defintely needed, used by activate_task */</span>
	<span class="p">.</span><span class="n">enqueue_task</span>		<span class="o">=</span> <span class="n">enqueue_task_rt</span><span class="p">,</span>  <span class="cm">/* add a new task into the queue */</span>
    <span class="cm">/* defintely needed, used by deactivate_task */</span>
	<span class="p">.</span><span class="n">dequeue_task</span>		<span class="o">=</span> <span class="n">dequeue_task_rt</span><span class="p">,</span>  
	<span class="p">.</span><span class="n">yield_task</span>		<span class="o">=</span> <span class="n">yield_task_rt</span><span class="p">,</span>
   
	<span class="p">.</span><span class="n">check_preempt_curr</span>	<span class="o">=</span> <span class="n">check_preempt_curr_rt</span><span class="p">,</span>
   
    <span class="cm">/* defintely needed */</span>
	<span class="p">.</span><span class="n">pick_next_task</span>		<span class="o">=</span> <span class="n">pick_next_task_rt</span><span class="p">,</span>  <span class="cm">/* picks next task */</span>
	<span class="p">.</span><span class="n">put_prev_task</span>		<span class="o">=</span> <span class="n">put_prev_task_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_next_task</span>          <span class="o">=</span> <span class="n">set_next_task_rt</span><span class="p">,</span>
   
<span class="cp">#ifdef CONFIG_SMP
</span>    <span class="cm">/* needed if have load balancing */</span>
	<span class="p">.</span><span class="n">balance</span>		<span class="o">=</span> <span class="n">balance_rt</span><span class="p">,</span>
    <span class="cm">/* needed if multiprocessor */</span>
	<span class="p">.</span><span class="n">select_task_rq</span>		<span class="o">=</span> <span class="n">select_task_rq_rt</span><span class="p">,</span> <span class="cm">/* decides which CPU to use */</span>
	<span class="p">.</span><span class="n">set_cpus_allowed</span>       <span class="o">=</span> <span class="n">set_cpus_allowed_common</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rq_online</span>              <span class="o">=</span> <span class="n">rq_online_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rq_offline</span>             <span class="o">=</span> <span class="n">rq_offline_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">task_woken</span>		<span class="o">=</span> <span class="n">task_woken_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">switched_from</span>		<span class="o">=</span> <span class="n">switched_from_rt</span><span class="p">,</span>
<span class="cp">#endif
</span>   
    <span class="cm">/* needed if have timer interrupts */</span>
	<span class="p">.</span><span class="n">task_tick</span>		<span class="o">=</span> <span class="n">task_tick_rt</span><span class="p">,</span> <span class="cm">/* manages time quantum */</span>
   
	<span class="p">.</span><span class="n">get_rr_interval</span>	<span class="o">=</span> <span class="n">get_rr_interval_rt</span><span class="p">,</span>
   
	<span class="p">.</span><span class="n">prio_changed</span>		<span class="o">=</span> <span class="n">prio_changed_rt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">switched_to</span>		<span class="o">=</span> <span class="n">switched_to_rt</span><span class="p">,</span>
   
	<span class="p">.</span><span class="n">update_curr</span>		<span class="o">=</span> <span class="n">update_curr_rt</span><span class="p">,</span>
   
<span class="cp">#ifdef CONFIG_UCLAMP_TASK
</span>	<span class="p">.</span><span class="n">uclamp_enabled</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div>    </div>

    <blockquote>
      <p><strong>Note</strong></p>

      <ul>
        <li>Most of the time, we you enter your <em>scheduling class specific code</em>, a <strong><code class="language-plaintext highlighter-rouge">lock</code> will have been held already for you</strong>.</li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">enqueue_task_rq</code>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Adding/removing a task to/from a priority array:
 */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">enqueue_task_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* ENQUEUES the ENTITY, not the task directly */</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>
   
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_WAKEUP</span><span class="p">)</span>
		<span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   
	<span class="n">enqueue_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
   
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_current</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">enqueue_pushable_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>then, this calls <code class="language-plaintext highlighter-rouge">enqueue_rt_entity</code>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">enqueue_rt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq_of_rt_se</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
   
	<span class="n">dequeue_rt_stack</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="cm">/* this loop is to deal with the sched_group */</span>
	<span class="n">for_each_sched_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)</span>
		<span class="n">__enqueue_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">enqueue_top_rt_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>where:</p>

    <ul>
      <li>if we <em>do not need to deal with sched groups</em>, then only a single call to <code class="language-plaintext highlighter-rouge">__enqueue_rt_entity(rt_se, flags)</code> would be fine.</li>
    </ul>

    <p>lastly, the <code class="language-plaintext highlighter-rouge">__enqueue_rt_entity</code>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">__enqueue_rt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* first gets the queue */</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span> <span class="o">=</span> <span class="n">rt_rq_of_se</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rt_prio_array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">group_rq</span> <span class="o">=</span> <span class="n">group_rt_rq</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">+</span> <span class="n">rt_se_prio</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
   
	<span class="cm">/* some code omitted here */</span>
       
	<span class="k">if</span> <span class="p">(</span><span class="n">move_entity</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">on_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ENQUEUE_HEAD</span><span class="p">)</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
		<span class="k">else</span> <span class="cm">/* add a NEW task to the end of run queue */</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
   
		<span class="n">__set_bit</span><span class="p">(</span><span class="n">rt_se_prio</span><span class="p">(</span><span class="n">rt_se</span><span class="p">),</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
		<span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">on_list</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <blockquote>
      <p><strong>Note</strong></p>

      <ul>
        <li>
          <p>this function <code class="language-plaintext highlighter-rouge">enqueue_task_rt</code> gets called by the following mechanism</p>

          <ol>
            <li>
              <p>First, the scheduler calls in <code class="language-plaintext highlighter-rouge">kernel/sched/core.c</code>:</p>

              <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">wake_up_new_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
     
	<span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">,</span> <span class="n">rf</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
         
    <span class="n">rq</span> <span class="o">=</span> <span class="n">__task_rq_lock</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
         
    <span class="cm">/* some code omitted here */</span>
     
    <span class="cm">/* wakes up task from a RUN QUEUE */</span>
	<span class="n">activate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ENQUEUE_NOCLOCK</span><span class="p">);</span>
         
    <span class="cm">/* some code omitted here */</span>
    <span class="n">task_rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>              </div>

              <p>where:</p>

              <ul>
                <li>notice that the <code class="language-plaintext highlighter-rouge">rq_lock</code> is added here <strong>already</strong></li>
              </ul>
            </li>
            <li>
              <p>then the <code class="language-plaintext highlighter-rouge">activate_task</code> goes to</p>

              <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">activate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_contributes_to_load</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_uninterruptible</span><span class="o">--</span><span class="p">;</span>
     
    <span class="cm">/* actual enqueue task */</span>
	<span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
     
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="n">TASK_ON_RQ_QUEUED</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>              </div>
            </li>
            <li>
              <p>Lastly, the <strong>per scheduling class method</strong> is called here:</p>

              <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">enqueue_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* some code omitted here */</span>
	<span class="n">uclamp_rq_inc</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="cm">/* per scheduling class method, just using TASK_STRUCT */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">enqueue_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>              </div>

              <p>where:</p>

              <ul>
                <li>this also explained why you need to add some <em>extra information in the task struct</em></li>
              </ul>
            </li>
          </ol>
        </li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p>Now, we need a <code class="language-plaintext highlighter-rouge">_pick_next_task</code>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">_pick_next_task_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>
   
	<span class="k">do</span> <span class="p">{</span>
        <span class="cm">/* the actual algorithm */</span>
		<span class="n">rt_se</span> <span class="o">=</span> <span class="n">pick_next_rt_entity</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rt_rq</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rt_se</span><span class="p">);</span>
		<span class="n">rt_rq</span> <span class="o">=</span> <span class="n">group_rt_rq</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rt_rq</span><span class="p">);</span>
   
	<span class="k">return</span> <span class="n">rt_task_of</span><span class="p">(</span><span class="n">rt_se</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>then, it calls ` pick_next_rt_entity`</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="nf">pick_next_rt_entity</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_prio_array</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt_rq</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
   
    <span class="cm">/* looks up the bitmap */</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">sched_find_first_bit</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">MAX_RT_PRIO</span><span class="p">);</span>
   
    <span class="cm">/* picks the FIRST task from the top priority queue */</span>
	<span class="n">queue</span> <span class="o">=</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">+</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_rt_entity</span><span class="p">,</span> <span class="n">run_list</span><span class="p">);</span>
   
	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Now, since <code class="language-plaintext highlighter-rouge">rt_sched</code> has two policies <em>(FIDO AND round-robin</em>), the round-robin one <strong>needs a timer interrupt</strong> (since it has a <em>time quantum</em>). This is <strong>achieved by <code class="language-plaintext highlighter-rouge">task_tick</code></strong>:</p>

    <ol>
      <li>if the policy is not <code class="language-plaintext highlighter-rouge">rr</code>, then do <em>nothing</em> (since FIFO doesn’t care how long it runs)</li>
      <li>if it is <code class="language-plaintext highlighter-rouge">rr</code>, then <em>decrement the time slice</em></li>
      <li>lastly, when the <em>time slice reached 0</em>, <strong>requeue it</strong>, and then</li>
    </ol>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_tick_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queued</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="o">*</span><span class="n">rt_se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">;</span>
   
	<span class="n">update_curr_rt</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">update_rt_rq_load_avg</span><span class="p">(</span><span class="n">rq_clock_pelt</span><span class="p">(</span><span class="n">rq</span><span class="p">),</span> <span class="n">rq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
   
	<span class="n">watchdog</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
   
	<span class="cm">/*
	 * RR tasks need a special form of timeslice management.
	 * FIFO tasks have no timeslices.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">policy</span> <span class="o">!=</span> <span class="n">SCHED_RR</span><span class="p">)</span> <span class="cm">/* 1. if the policy is not `rr`, then do nothing */</span>
		<span class="k">return</span><span class="p">;</span>
   
    <span class="cm">/* 2. decrement the time slice */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">time_slice</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
   
    <span class="cm">/* 3. give it a new time slice, and REQUEUE it */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">time_slice</span> <span class="o">=</span> <span class="n">sched_rr_timeslice</span><span class="p">;</span>
   
	<span class="cm">/*
	 * Requeue to the end of queue if we (and all of our ancestors) are not
	 * the only element on the queue
	 */</span>
	<span class="n">for_each_sched_rt_entity</span><span class="p">(</span><span class="n">rt_se</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">.</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">rt_se</span><span class="o">-&gt;</span><span class="n">run_list</span><span class="p">.</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
             <span class="cm">/* requeue it by removing and putting it to TAIL */</span>
			<span class="n">requeue_task_rt</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
             <span class="cm">/* attemps to let SCHEDULER to RESCHEDULE for a new TASK by SETTING A SIGNAL FLAG _TIF_NEED_RESCHED */</span>
			<span class="n">resched_curr</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>where:</p>

    <ul>
      <li>
        <p>the <code class="language-plaintext highlighter-rouge">resched_curr</code> actually <strong>does not call the scheduler directly</strong> (<em>because we are at a Timer Interrupt</em>)</p>

        <ol>
          <li>It sets a flag for reschedule for the <code class="language-plaintext highlighter-rouge">curr</code> process</li>
          <li>similar to <code class="language-plaintext highlighter-rouge">SIGPEND</code>, this will be <strong>processed at the</strong> <code class="language-plaintext highlighter-rouge">exit_to_usermode</code></li>
        </ol>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">resched_curr</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
     
	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
     
	<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_need_resched</span><span class="p">(</span><span class="n">curr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
     
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpu_of</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
     
	<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">smp_processor_id</span><span class="p">())</span> 
         <span class="cm">/* 1. sets a flag for reschedule */</span>
		<span class="n">set_tsk_need_resched</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
		<span class="n">set_preempt_need_resched</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
     
	<span class="cm">/* some code omitted here */</span>
<span class="err">}</span>
</code></pre></div>        </div>

        <p>then to be processed:</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* rescheule flag definition */</span>
<span class="cp">#define EXIT_TO_USERMODE_LOOP_FLAGS				\
	(_TIF_SIGPENDING | _TIF_NOTIFY_RESUME | _TIF_UPROBE |	\
	 _TIF_NEED_RESCHED | _TIF_USER_RETURN_NOTIFY | _TIF_PATCH_PENDING)
</span>     
<span class="k">static</span> <span class="kt">void</span> <span class="nf">exit_to_usermode_loop</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cached_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*
	 * In order to return to user mode, we need to have IRQs off with
	 * none of EXIT_TO_USERMODE_LOOP_FLAGS set.  Several of these flags
	 * can be set at any time on preemptible kernels if we have IRQs on,
	 * so we need to loop.  Disabling preemption wouldn't help: doing the
	 * work to clear some of the flags can sleep.
	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We have work to do. */</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
     
        <span class="cm">/* if need to reschedule, reschedule here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cached_flags</span> <span class="o">&amp;</span> <span class="n">_TIF_NEED_RESCHED</span><span class="p">)</span>
			<span class="n">schedule</span><span class="p">();</span>
             
             
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>

    <blockquote>
      <p><strong>Note</strong></p>

      <ul>
        <li>
          <p>If we need something like a Round-Robin algorithm, we need a timer interrupt. This is achieved by <code class="language-plaintext highlighter-rouge">scheduler_tick()</code> inside <code class="language-plaintext highlighter-rouge">kernel/sched/core.c</code>, which eventually <strong>calls per sched-class <code class="language-plaintext highlighter-rouge">task_tick</code></strong>:</p>

          <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * This function gets called by the timer code, with HZ frequency.
 * We call it with interrupts disabled.
 */</span>
<span class="kt">void</span> <span class="nf">scheduler_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* some code omitted here */</span>
    
	<span class="n">sched_clock_tick</span><span class="p">();</span>
    
  <span class="n">rq_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
    
  <span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
    <span class="cm">/* calls per sched class task_tick */</span>
  <span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_tick</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">calc_global_load_tick</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
	<span class="n">psi_task_tick</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
    
	<span class="n">rq_unlock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rf</span><span class="p">);</span>
 
	<span class="n">perf_event_task_tick</span><span class="p">();</span>
 
<span class="cp">#ifdef CONFIG_SMP
</span>  <span class="n">rq</span><span class="o">-&gt;</span><span class="n">idle_balance</span> <span class="o">=</span> <span class="n">idle_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
	<span class="n">trigger_load_balance</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div>          </div>
        </li>
      </ul>

    </blockquote>
  </li>
  <li>
    <p>To know <em>which CPU to run on</em> (e.g. you need to know <em>which lock/run queue to grab</em>), it uses the:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* DETERMINES WHICH CPU to RUN ON */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">select_task_rq_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_flag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
   
	<span class="cm">/* For anything but wake ups, just return the task_cpu */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd_flag</span> <span class="o">!=</span> <span class="n">SD_BALANCE_WAKE</span> <span class="o">&amp;&amp;</span> <span class="n">sd_flag</span> <span class="o">!=</span> <span class="n">SD_BALANCE_FORK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
   
	<span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
   
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">curr</span> <span class="o">=</span> <span class="n">READ_ONCE</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">);</span> <span class="cm">/* unlocked access */</span>
   
	<span class="cm">/* some code omitted here */</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
   
    <span class="cm">/* most of the time, the same CPU passed in */</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <blockquote>
      <p><strong>Note</strong></p>

      <ul>
        <li>
          <p>the <code class="language-plaintext highlighter-rouge">select_task_rq_rt</code> is called in <strong>many scenarios</strong> (e.g. load-balancing). Here, the example is when a <em>new task is created</em>:</p>

          <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">wake_up_new_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rq_flags</span> <span class="n">rf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
    
	<span class="cm">/* some code omitted here */</span>
        
    <span class="cm">/* assigns WHICH CPU to run on */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">recent_used_cpu</span> <span class="o">=</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">__set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">SD_BALANCE_FORK</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>          </div>

          <p>where it actually calls the <code class="language-plaintext highlighter-rouge">select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0)</code>:</p>

          <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">select_task_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sd_flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pi_lock</span><span class="p">);</span>
    
    <span class="cm">/* calls the scheduler based select_task_rq */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nr_cpus_allowed</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">select_task_rq</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">sd_flags</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">cpumask_any</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cpus_ptr</span><span class="p">);</span>
    
	<span class="cm">/* some code omitted here */</span>
    
	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>          </div>
        </li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p>Additionally, if some <em>initialization is needed for the queue/sched class</em>, you can have:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">init_rt_rq</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_rq</span> <span class="o">*</span><span class="n">rt_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_prio_array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
   
	<span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <blockquote>
      <p><strong>Note</strong></p>

      <ul>
        <li>
          <p>this initialization code is called by <code class="language-plaintext highlighter-rouge">void __init sched_init(void)</code> inside <code class="language-plaintext highlighter-rouge">kernel/sched/core.c</code>, which is in turn called by <code class="language-plaintext highlighter-rouge">init/main.c</code> at <strong>start up of kernel</strong></p>

          <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">asmlinkage</span> <span class="n">__visible</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">start_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">command_line</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">after_dashes</span><span class="p">;</span>
        
    <span class="cm">/* some code omitted here */</span>
    
	<span class="cm">/*
	 * Set up the scheduler prior starting any interrupts (such as the
	 * timer interrupt). Full topology setup happens at smp_init()
	 * time - but meanwhile we still have a functioning scheduler.
	 */</span>
	<span class="n">sched_init</span><span class="p">();</span>
    <span class="cm">/* some code omitted heret */</span>
<span class="p">}</span>
</code></pre></div>          </div>
        </li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p>More interestingly, if you do <strong>load balancing</strong>, and the method <code class="language-plaintext highlighter-rouge">balance()</code> will be doing the job:</p>

    <ul>
      <li>
        <p>in short, the kernel will first do <code class="language-plaintext highlighter-rouge">balance() -&gt; pick_next_task</code></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span>
<span class="nf">pick_next_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* some code omitted here */</span>
         
    <span class="cm">/* first balance */</span>
	<span class="n">for_class_range</span><span class="p">(</span><span class="n">class</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idle_sched_class</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">class</span><span class="o">-&gt;</span><span class="n">balance</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">rf</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="n">put_prev_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
     
    <span class="cm">/* then pick_next_class */</span>
	<span class="n">for_each_class</span><span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">class</span><span class="o">-&gt;</span><span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>but now, since we are accessing <em>other CPU’s run queues</em>, we need to <strong>grab other run queue’s lock</strong>, then you might need to deal with <em>deadlock situations</em></p>

        <blockquote>
          <p><strong>Deadlocks for Load Balancing</strong></p>

          <ol>
            <li>
              <p>One possibility is as follows: if <code class="language-plaintext highlighter-rouge">rq1</code> wants to do some load balancing, <strong>and at the same time</strong> <code class="language-plaintext highlighter-rouge">rq2</code> also wants to do some load balancing, this <strong>deadlock</strong> might happen:</p>

              <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-11_14-49-27.png" style="zoom: 33%;" /></p>

              <p>where we see the <strong>solution is to</strong> grab the lock in the <strong>same order</strong>:</p>

              <ol>
                <li>release your own lock (if you are not <code class="language-plaintext highlighter-rouge">CPU1</code>/lowest CPU)
                  <ul>
                    <li>so you need to be aware that <em>state might change</em> at the same time</li>
                  </ul>
                </li>
                <li>attempt to grab lock starting from the lowest CPU</li>
              </ol>
            </li>
          </ol>
        </blockquote>
      </li>
    </ul>

    <p>Now, to the <strong>actual definition of <code class="language-plaintext highlighter-rouge">rt</code> class</strong>:</p>

    <ol>
      <li>essentially, it calls <code class="language-plaintext highlighter-rouge">pull_rt_task()</code>, which <em>goes through each CPU</em>, and does the <strong>Pull Migration</strong></li>
    </ol>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">balance_rt</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">on_rt_rq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">need_pull_rt_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*
		 * This is OK, because current is on_cpu, which avoids it being
		 * picked for load-balance and preemption/IRQs are still
		 * disabled avoiding further scheduler activity on it and we've
		 * not yet started the picking loop.
		 */</span>
		<span class="n">rq_unpin_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
        <span class="cm">/* 1. the main entry point */</span>
		<span class="n">pull_rt_task</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
		<span class="n">rq_repin_lock</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>
	<span class="p">}</span>
   
	<span class="k">return</span> <span class="n">sched_stop_runnable</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">||</span> <span class="n">sched_dl_runnable</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">||</span> <span class="n">sched_rt_runnable</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p>then the <code class="language-plaintext highlighter-rouge">pull_rt_task()</code> does an <em>iteration for ALL CPU’s RUNQUEUE</em> (now, you need to do the <strong>deadlock prevention via <code class="language-plaintext highlighter-rouge">double_lock_balance()</code></strong>), and then:</p>

        <ol>
          <li><em>select</em> which task to be pulled</li>
          <li>deactivate/remove that task from the <code class="language-plaintext highlighter-rouge">src</code> run queue</li>
          <li>activate/add that task to the <code class="language-plaintext highlighter-rouge">this_rq</code> run queue</li>
        </ol>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">pull_rt_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">this_cpu</span> <span class="o">=</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">resched</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">src_rq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rt_overload_count</span> <span class="o">=</span> <span class="n">rt_overloaded</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
     
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">rt_overload_count</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
     
	<span class="cm">/* some code omitted here */</span>
     
    <span class="cm">/* LOOPS OVER EACH CPU AND LOAD BALANCE */</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">rto_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* some code omitted here */</span>
     
		<span class="cm">/*
		 * We can potentially drop this_rq's lock in
		 * double_lock_balance, and another CPU could
		 * alter this_rq
		 */</span>
		<span class="n">double_lock_balance</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">src_rq</span><span class="p">);</span>
     
        <span class="cm">/* 1. DECIDES WHICH TASK TO PULL */</span>
		<span class="cm">/*
		 * We can pull only a task, which is pushable
		 * on its rq (NOT RUNNING), and no others.
		 */</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">pick_highest_pushable_task</span><span class="p">(</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
     
		<span class="cm">/*
		 * Do we have an RT task that preempts
		 * the to-be-scheduled task?
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">rt</span><span class="p">.</span><span class="n">highest_prio</span><span class="p">.</span><span class="n">curr</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* some code omitted here */</span>
     
            <span class="cm">/* 2. REMOVE A TASK FROM A RUN QUEUE */</span>
			<span class="n">deactivate_task</span><span class="p">(</span><span class="n">src_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">set_task_cpu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">this_cpu</span><span class="p">);</span>
            <span class="cm">/* 3. ADD A TASK TO MY RUN QUEUE */</span>
			<span class="n">activate_task</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/*
			 * We continue with the search, just in
			 * case there's an even higher prio task
			 * in another runqueue. (low likelihood
			 * but possible)
			 */</span>
		<span class="p">}</span>
<span class="nl">skip:</span>
		<span class="n">double_unlock_balance</span><span class="p">(</span><span class="n">this_rq</span><span class="p">,</span> <span class="n">src_rq</span><span class="p">);</span>
	<span class="p">}</span>
     
	<span class="k">if</span> <span class="p">(</span><span class="n">resched</span><span class="p">)</span>
		<span class="n">resched_curr</span><span class="p">(</span><span class="n">this_rq</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <p>where the <code class="language-plaintext highlighter-rouge">double_lock_balance</code> in the end goes to:</p>

        <ul>
          <li>
            <p><code class="language-plaintext highlighter-rouge">_double_lock_balance</code>:</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">_double_lock_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">this_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">busiest</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
       
    <span class="cm">/* TRIES LOCK! IF I CAN GRAB IT, I AM DONE, RETURN */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">raw_spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)))</span> <span class="p">{</span>
        <span class="cm">/* IF I CANNOT, THEN MAKE SURE I GRAB THE LOCK IN THE RIGHT ORDER */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">busiest</span> <span class="o">&lt;</span> <span class="n">this_rq</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* if I am grabbing a lower CPU lock, release my lock and then grab */</span>
			<span class="n">raw_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">raw_spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
					      <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="cm">/* otherwise, grab it right away */</span>
			<span class="n">raw_spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">busiest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span>
					      <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>            </div>

            <p>where basically we wan to:</p>

            <ul>
              <li>make sure <strong>locks of CPUs are in the SAME ORDER</strong> (i.e. lowest CPU -&gt; highest CPU)</li>
              <li>this is abstract enough so that <strong>other code can also use it</strong></li>
            </ul>

            <blockquote>
              <p><strong>Note</strong></p>

              <ul>
                <li>However, this <em>does not re-check the state of run queue</em> when the lock is released</li>
              </ul>
            </blockquote>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h1 id="week-7---memory-management">Week 7 - Memory Management</h1>

<blockquote>
  <p><em>Reminder</em></p>

  <ul>
    <li>There are two addresses, <strong>physical addresses</strong> (RAM) and <strong>virtual/logical addresses</strong>
      <ul>
        <li>Therefore, in the end there is a <strong>mapping from the physical to the virtual/logical</strong></li>
      </ul>
    </li>
    <li>Processes have their own <strong>independent</strong> (virtual) <strong>address spaces</strong>
      <ul>
        <li>by default, you are using the <em>virtual addresses</em></li>
        <li>though there <em>is a way to code to the physical addresses</em> (HW1)</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>We are using virtual addresses due the following <strong>advantages</strong></p>

<ol>
  <li>don’t need to worry about addresses used by <em>other processes</em></li>
</ol>

<p>How do you map the addresses?</p>

<blockquote>
  <p><strong>Heuristics</strong></p>

  <ol>
    <li>At Compile Time, using compilers. Compiler needs to know ahead of time and map everything correctly
      <ul>
        <li>not a good idea since not all programs will run in the end</li>
        <li>you still need to <em>keep in mind of other programs</em> while writing your own code</li>
      </ul>
    </li>
    <li>At Load Time, when I <strong>actually load the program into RAM</strong>.
      <ul>
        <li>this is a better approach, as it solves the previous problems</li>
        <li>to do this, you can do:
          <ol>
            <li>just keep track of the <code class="language-plaintext highlighter-rouge">base</code> address, which will be <em>added to</em> the <em>start of the virtual address of the loaded program</em>, and then <em>update the <code class="language-plaintext highlighter-rouge">base</code></em></li>
            <li>however, since <code class="language-plaintext highlighter-rouge">stack</code> and <code class="language-plaintext highlighter-rouge">heap</code> are <em>dynamic</em>, how would you deal with that?</li>
          </ol>
        </li>
      </ul>
    </li>
  </ol>
</blockquote>

<p>The solution is to do it during <strong>execution time</strong></p>

<ul>
  <li>when a process is <em>actually running</em>, we map the address to the physical memory <em>while it is running</em></li>
  <li>however, this needs some <em>special hardware support</em></li>
</ul>

<h2 id="memory-mapping">Memory Mapping</h2>

<p>So, this mapping happens at <strong>execution time</strong>, and the following happens:</p>

<ol>
  <li>CPU <strong>runs</strong> your program, and <em>gets an address</em> (that you need to use)</li>
  <li>You need to <strong>map</strong> that address to a physical address</li>
</ol>

<blockquote>
  <p><strong>General Idea</strong></p>

  <ul>
    <li>
      <p>To do the mapping, a simple idea would be from the <em>load time idea</em></p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\image-20210315233900485.png" style="zoom:50%;" /></p>

      <p>where:</p>

      <ul>
        <li>we want to keep a sort of <code class="language-plaintext highlighter-rouge">base address</code> in a <code class="language-plaintext highlighter-rouge">relocation</code> register</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>In reality, there is a page table:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-15_23-46-18.png" style="zoom:50%;" /></p>

<p>This is actually <strong>done in hardware</strong>.</p>

<ol>
  <li>You execute instructions such as <code class="language-plaintext highlighter-rouge">load</code></li>
  <li><strong>CPU</strong> processes the instruction by <em>looking up/index into the Page Table</em>
    <ul>
      <li>this Page Table will be stored in <strong>hardware</strong></li>
    </ul>
  </li>
  <li>The Page Table then tells us the <em>physical address</em></li>
  <li>Then this is finally used</li>
</ol>

<blockquote>
  <p><em>Reminder</em>:</p>

  <p>Some basic conversions:</p>

  <ul>
    <li>If Logical <strong>Address</strong> = 31 bit, then Logical Address Space = 231 words = 2G words (1 G = $2^{30}$)</li>
    <li>If Logical <strong>Address Space</strong> = 128 M words = $2^7 * 2^{20}$ words, then Logical Address = $log_2(2^{27})$ = 27 bits</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Page Table</strong></p>

  <ul>
    <li>
      <p>Since we essentially need to <em>index the virtual address</em> to get a physical address, we need away to ==TODO?==</p>
    </li>
    <li>
      <p>The <em>virtual address</em> will be split into two parts, <strong>page number</strong> and <strong>offset</strong>:</p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-16_11-18-37.png" alt="" /></p>

      <p>where:</p>

      <ul>
        <li>a <code class="language-plaintext highlighter-rouge">Page</code> is usually a fixed size (e.g. <code class="language-plaintext highlighter-rouge">2^10</code>) of <em>memory</em></li>
        <li>the <em>physical memory</em> will be <strong>broken up to <code class="language-plaintext highlighter-rouge">#page</code></strong> number of <strong>pages</strong>
          <ul>
            <li>in reality, you refer to the <code class="language-plaintext highlighter-rouge">#page</code> as the <strong><code class="language-plaintext highlighter-rouge">#frame</code> for physical address</strong></li>
            <li>in reality, you refer to the <code class="language-plaintext highlighter-rouge">#page</code> as the <strong><code class="language-plaintext highlighter-rouge">#page</code> for virtual address</strong></li>
          </ul>
        </li>
        <li>usually the <code class="language-plaintext highlighter-rouge">page</code> and <code class="language-plaintext highlighter-rouge">frame</code> <em>size is the same</em>
          <ul>
            <li>so it is just the problem of <strong>which <code class="language-plaintext highlighter-rouge">#page</code> maps to which <code class="language-plaintext highlighter-rouge">#frame</code></strong></li>
          </ul>
        </li>
        <li>an <code class="language-plaintext highlighter-rouge">offset</code> is just an offset</li>
      </ul>
    </li>
    <li>
      <p>Then the actual <strong>computation/mapping</strong> is this:</p>

      <ol>
        <li>use <code class="language-plaintext highlighter-rouge">#page</code> (top bits of <em>virtual address</em>) to <strong>index into Page Table</strong> and get the <code class="language-plaintext highlighter-rouge">#frame</code></li>
        <li>the <code class="language-plaintext highlighter-rouge">#frame</code> will be the top bits of the <em>physical address</em></li>
        <li>add the <code class="language-plaintext highlighter-rouge">offset</code> to the <code class="language-plaintext highlighter-rouge">#frame</code> to get the <em>actual physical address</em></li>
      </ol>
    </li>
    <li>
      <p>And since we need to essential solve the problem of two virtual address mapping to different physical address, we have:</p>

      <ul>
        <li><strong>each process has its own DISTINCT page table</strong>, so that they are mapped to <em>different areas of RAM</em>
          <ul>
            <li>here, you see the <strong>role of the OS</strong></li>
          </ul>
        </li>
        <li>so at <em>context switches</em>, the <code class="language-plaintext highlighter-rouge">PTBR</code>(<code class="language-plaintext highlighter-rouge">CR3</code> in <code class="language-plaintext highlighter-rouge">x86</code>) register needs to be re-loaded as well
          <ul>
            <li>so if you are switching to shared<code class="language-plaintext highlighter-rouge">threads</code> for <em>shared data</em>, you won’t need to re-load the page table because it is the same for them</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Then, the question remains: who controls the <strong>contents of the Page Table</strong>?</p>

<ul>
  <li>the <strong>OS</strong> <em>puts/loads mapping into the page table</em> (decides)</li>
  <li>the <strong>Hardware</strong> <em>will use the page table and translate addresses for you</em> (translates)</li>
</ul>

<p>So a full picture looks like:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-16_11-16-38.png" style="zoom: 67%;" /></p>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>in the end, the hardware will have a <em>address</em> in<code class="language-plaintext highlighter-rouge">pagetable base register</code> (``PTBR<code class="language-plaintext highlighter-rouge">/</code>CR3<code class="language-plaintext highlighter-rouge"> in </code>x86`)</li>
    <li>the OS will load data into that <code class="language-plaintext highlighter-rouge">pagetable</code></li>
    <li>the hardware then will use that <em>address</em> in<code class="language-plaintext highlighter-rouge">pagetable base register</code></li>
  </ul>
</blockquote>

<p><em>For Example</em>:</p>

<p>Consider the setup:</p>

<ul>
  <li><em>logical</em> address with <strong>page number</strong> of <code class="language-plaintext highlighter-rouge">2 bits</code> and <strong>page offset</strong> of <code class="language-plaintext highlighter-rouge">2 bits</code>
    <ul>
      <li>so the number of entries in a page is $2^2 = 4$</li>
      <li>if each <strong>page entry is $1$ byte</strong> (size of data contained in each entry of page table)</li>
      <li>the <strong>page size</strong> is $4*1=4$ bytes</li>
    </ul>
  </li>
  <li><em>physical</em> address with <em>total memory</em> of <code class="language-plaintext highlighter-rouge">32 bytes</code>
    <ul>
      <li>so the physical address has $log_2 32 = 5$ bits</li>
      <li>since <strong>frame size</strong> = page size, we have $32/4=8$ frames, which translates to $log_2 8 = 3$ bits for <strong>frame number</strong>, so $5-3=2$ bits for <strong>frame offset</strong></li>
    </ul>
  </li>
</ul>

<p>Then the mapping looks like this:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-16_11-23-13.png" style="zoom: 80%;" /></p>

<p>where:</p>

<ul>
  <li>the <em>virtual</em> address <code class="language-plaintext highlighter-rouge">00 00</code> maps to physical address of ​<code class="language-plaintext highlighter-rouge">101 00</code>​, where ​ a is stored
    <ul>
      <li>first, <em>page number</em> $00$ is indexed into page table to get $5 = 101$</li>
      <li>the <em>page offset</em> is $00$</li>
      <li>then, the physical address is assembled $101\,\,00$</li>
    </ul>
  </li>
  <li>the <em>virtual</em> address <code class="language-plaintext highlighter-rouge">00 01</code> maps to physical address of <code class="language-plaintext highlighter-rouge">101 01</code>, where $b$ is stored</li>
  <li>etc.</li>
</ul>

<hr />

<p><em>For Example</em></p>

<p>Consider:</p>

<ul>
  <li>Page size = 8KB = $2^{13}$ B
    <ul>
      <li>size of a <em>page</em>, <strong>not</strong> size of <em>page table</em>, two different things.</li>
    </ul>
  </li>
  <li>Virtual address space size = $2^{46}$ B</li>
  <li>PTE (page table entry) = 4B = $2^2$ B</li>
</ul>

<p>Then, we can <strong>get</strong>:</p>

<ul>
  <li>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Number of pages or number of entries <span class="k">in </span>page table, 
<span class="o">=</span> <span class="o">(</span>virtual address space size<span class="o">)</span> / <span class="o">(</span>page size<span class="o">)</span> 
<span class="o">=</span> 2^46 B/2^13 B 
<span class="o">=</span> 2^33
</code></pre></div>    </div>

    <p>which means that</p>

    <ul>
      <li>we need $2^{33}$ pages,</li>
      <li><em>or it means we need to be able to index $2^{33}$ different pages</em>, hence we will have $2^{33}$ <strong>entries in (a single level) page table</strong></li>
    </ul>
  </li>
</ul>

<p>Now, we can also calculate the <strong>size of page TABLE</strong>:</p>

<ul>
  <li>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">=</span> <span class="o">(</span>number of entries <span class="k">in </span>page table<span class="o">)</span><span class="k">*</span><span class="o">(</span>size of PTE<span class="o">)</span> 
  <span class="o">=</span> 2^33 <span class="k">*</span> 2^2 B 
  <span class="o">=</span> 2^35 B 
</code></pre></div>    </div>
  </li>
</ul>

<p>which looks obvious</p>

<p>Now, notice that:</p>

<ul>
  <li>we have size of page table &gt; page size! This is not ideal.</li>
  <li>hence, we need <strong>multilevel paging</strong></li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>
      <p>this also means that you could map a <em>larger</em> virtual space to a <em>smaller</em> physical space</p>

      <ul>
        <li>in this case, you would need to deal with <strong>collisions</strong></li>
        <li>so basically, the concept is the same as the <em>caches</em> in the FUNDI class</li>
      </ul>
    </li>
    <li>
      <p>for example, typically in modern systems, we have <code class="language-plaintext highlighter-rouge">64</code> bits system (which is big, so usually only 48 bits -&gt; $2^{48}=256 TB$ of space)</p>

      <ul>
        <li>
          <p>however, remember, not all addresses is used in a virtual address space:</p>

          <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-16_11-46-16.png" style="zoom:50%;" /></p>

          <p>where there is a <em>big hole between heap and stack</em></p>

          <ul>
            <li>this is solved by <em>further breaking up the addresses</em> into a <strong>multilevel page table</strong></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="multilevel-page-table">Multilevel Page Table</h3>

<blockquote>
  <p><strong>Multilevel Page Table</strong></p>

  <ul>
    <li>
      <p>the core principle is to <strong>keep</strong>:
\(\text{size of page table } \le \text{size of page}\)</p>
    </li>
    <li>
      <p>In the end, if we use multilevel page table:</p>
      <ul>
        <li><em>only one of PAGE TABLE</em> would be in your RAM at a time. If you have indexed and needed the next Page Table, the next one <em>then</em> is loaded in replacement
          <ul>
            <li>this is obviously the <strong>advantage of Multi-level Paging</strong></li>
          </ul>
        </li>
        <li>this would be slow for software to do this. But hardware (Cache/TLB) has support so that <em>memory access will be usually fast</em></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Now, consider the following setup:</p>

<ul>
  <li>a <strong>page size</strong> of <code class="language-plaintext highlighter-rouge">4KB</code> = $2^{12}$ bytes</li>
  <li>a <strong>page entry</strong> of <code class="language-plaintext highlighter-rouge">8B</code> = $2^3$ bytes
    <ul>
      <li>contains the <em>frame number</em> (e.g. for the next level), and some extra flag information</li>
    </ul>
  </li>
  <li>a <strong>virtual address space</strong> of $2^{64}$ bytes
    <ul>
      <li>i.e. 64-bit system</li>
    </ul>
  </li>
  <li>we need a <strong>two level paging</strong></li>
</ul>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-16_23-59-03.png" style="zoom: 67%;" /></p>

<p>To solve this, <strong>always keep this in mind</strong></p>

<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20190608174704/multilevel.png" style="zoom: 67%;" /></p>

<ol>
  <li>
    <p>first, consider the <em>offset</em>. Basically, at the very last, we need the offset to get the <em>entry of a <strong>PAGE</strong></em>, which would be the <em>final place to PUT THE BYTE DATA</em>. Therefore:</p>

    <ul>
      <li>since a <em>page</em> has size of $2^{12}$ bytes, we would need $12$ bits to <strong>identify each byte</strong></li>
      <li>hence the offset is $12$ bit</li>
    </ul>
  </li>
  <li>
    <p>then, the second last level. We need to achieve two things:</p>

    <ul>
      <li>the <strong>size of the page table</strong> needs to be $\le$ <strong>size of a page</strong>. Hence let us pick <em>size of page table = $2^{12}$ = size of a page</em></li>
      <li>now, the idea is that <strong>each entry</strong> in this level page table tells us <em>which (next level) PAGE</em> we need to look at
        <ul>
          <li>think of this level telling us <strong><em>which page to go to</em></strong>, and the offset level tells us <strong><em>which line on this page to go to</em></strong> (like a book)</li>
        </ul>
      </li>
      <li>now, since size of page table here is $2^{12}$, and a page entry size is mentioned in the prompt ($2^3$), we have $2^{12} / 2^3 = 2^9$ entries. Hence we need $9$ bits to <strong>identify each entry</strong></li>
    </ul>
  </li>
  <li>
    <p>Now, we are basically done. We just have $64 - 9 - 12 = 43$ bits left. Check to see if this makes sense:</p>

    <ul>
      <li>
        <p>if we have $43$ bits left in in this level, and each page table entry is $2^3$, then we have $2^{46}$ bytes as the <em>size of page table</em></p>

        <ul>
          <li>hints at the fact that Linux uses more than 2 level of paging (<strong>in fact, Linux uses 5 levels</strong>)</li>
        </ul>
      </li>
      <li>
        <p>but working from this level (<em>first level paging</em>), we get this:</p>

        <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-17_00-30-57.png" style="zoom:67%;" /></p>

        <p>where:</p>

        <ul>
          <li>first, we use $43$ bits to <strong>index</strong> and get an <em>entry</em> of the first level page table.
            <ul>
              <li>This would contain a <em>frame number</em>, call it $f_1=3$</li>
            </ul>
          </li>
          <li>use the frame number $f_1$ to <strong>know</strong> <em>which second level page table to look at</em>. So we are looking at the $f_1=3$-rd second level page table</li>
          <li>then, we use $9$ bits to <strong>index</strong> and get an <em>entry</em> of the second level page table
            <ul>
              <li>This would contain a <em>frame number</em>, call it $f_2=10$</li>
            </ul>
          </li>
          <li>use the frame number $f_2$ to <strong>know</strong> <em>which (last level) PAGE</em> to look at. So we are looking at the $f_2=10$-th page</li>
          <li>finally, we use $12$ bits to <strong>index</strong> and get the <em>byte</em> stored at that page</li>
        </ul>

        <p>Notice that we in the end have <strong>covered a total of $43+9+12 = 64$</strong> possible combinations. Hence this is a 64-bit system, as expected</p>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p><strong>Potential Problem</strong></p>

  <ul>
    <li>As Linux is having 5 levels of paging, this means you need to <em>index 5 times to get to the actual place</em>. This might make memory access slow and inefficient
      <ul>
        <li>to solve this, we use <strong>caching</strong>, which is based on the principle of <strong>(space and time) locality</strong>
          <ul>
            <li>in reality, this works pretty well/most things goes in cache (possibly even higher than $95\%$ hit rate)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="cachetlb">Cache/TLB</h3>

<p>Now, to solve the above problem, I can <em>cache my most recent</em> virtual address -&gt; physical address <em>translation</em></p>

<ul>
  <li>otherwise, I would need to look at the actual page tables</li>
  <li>this cache is known as the <strong>translation lookaside buffer (TLB)</strong></li>
</ul>

<blockquote>
  <p><strong>Cache</strong></p>

  <ul>
    <li>Cache is also known as static RAM, or <strong>SRAM</strong>, which is faster than the usual RAM, which is technically called dynamic RAM, or <strong>DRAM</strong></li>
    <li>Since Cache is usually <em>small in storage size but FAST</em>, the following happens:
      <ol>
        <li>first, the CPU asks the cache if it has the translation for a virtual address</li>
        <li>if not, CPU then <em>redo the indexing in DRAM</em> and finds the address</li>
      </ol>
    </li>
    <li>All of the above is <strong>done in hardware</strong></li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<p>Consider a setup of:</p>

<ul>
  <li>2 level of paging</li>
  <li>DRAM access time of 100 ns</li>
  <li>SRAM access time of 10 ns</li>
  <li>$99\%$ cache <em>hit rate</em></li>
</ul>

<p>Then we have the long term memory access time of:
\(0.99(10+100) + 0.01(10+100+100+100)=112ns\)</p>

<p>where:</p>

<ul>
  <li>the $10+100$ comes from a <strong>hit in cache (10)</strong> (got the address), and then <strong>accessing the address (100)</strong></li>
  <li>the $10+100+100+100$ comes from a <strong>miss in cache (10)</strong>, and then <strong>indexing twice to get the Page (100+100)</strong>, and finally <strong>accessing the address (100)</strong></li>
</ul>

<hr />

<blockquote>
  <p><strong>Flushing TLB</strong></p>

  <ul>
    <li>
      <p>Now, suppose process $A$ has a virtual address $0x5$, and then process $B$ <em>gets context switched in</em>. Then, you need to <strong>flush the TLB</strong></p>

      <ul>
        <li>all the old entries are invalid since the cached address is per <em>process</em></li>
        <li>
          <p>if we are switching between <em>threads</em>, which shares the <strong>same address space</strong>, then we don’t need to flush</p>
        </li>
        <li>However, this can be optimized using <strong>tagging</strong></li>
      </ul>
    </li>
    <li>
      <p>Or, consider when we are <em>updating the Page Table</em></p>

      <ul>
        <li>then we would need to flush for updates since the mapping is no longer valid</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="tlb-optimization">TLB Optimization</h4>

<blockquote>
  <p><strong>Tagging</strong></p>

  <ul>
    <li>basically, we have an <em>address space identifier</em> $ASID$ to <strong>identity each TLB entry to a process</strong>
      <ul>
        <li>so that we can save all the flushing and cache misses for <em>context switches</em></li>
        <li>obviously, this would then help the performance</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<ul>
  <li>if we have a process $A$ with $pid=1$, and process $B$ with $pid=5$</li>
  <li>process $A$ had a virtual address of $0x5$ translated to $0x9$
    <ul>
      <li><strong>this entry</strong> would have $ASID=pid=1$</li>
    </ul>
  </li>
  <li>process $B$ had a virtual address of $0x5$ translated to $0x19$
    <ul>
      <li><strong>this entry</strong> would have $ASID=pid=5$</li>
    </ul>
  </li>
</ul>

<hr />

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>now, we only need to flush the TLB when we are <em>updating the PAGE TABLE</em></li>
    <li>this would mean that we need to <em>increase the TLB sizes</em> (for $ASID$)</li>
  </ul>
</blockquote>

<h2 id="accessing-memory">Accessing Memory</h2>

<p>For a user, we use the memory by:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">malloc()</code></li>
  <li><code class="language-plaintext highlighter-rouge">mmap()</code></li>
</ul>

<h3 id="malloc">Malloc</h3>

<p>What happens when a user in his/her program <strong>does <code class="language-plaintext highlighter-rouge">malloc()</code>?</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">malloc</code> eventually goes to <code class="language-plaintext highlighter-rouge">sbrk</code> in the system call, which would:
    <ol>
      <li>increases your Heap by moving up the pointer if needed (because <code class="language-plaintext highlighter-rouge">free()</code> actually <em>does not decrease the Heap</em>)
        <ul>
          <li>so <code class="language-plaintext highlighter-rouge">malloc()</code> will first see if there are some spaces in your Heap left. If not, increases the space.</li>
        </ul>
      </li>
      <li>done</li>
    </ol>
  </li>
  <li>all it says is that “you <strong>can</strong> use more <strong>virtual addresses</strong>”. It <strong>does not</strong> actually assign any <strong>physical memory</strong> to you
    <ul>
      <li>there will <strong>not</strong> be a place in your Page Table that translates these virtual address</li>
    </ul>
  </li>
  <li>only at the point when you are <strong>storing data</strong>, they physical memory is assigned
    <ul>
      <li>but first, a page fault will happen (see below)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Page Fault and Memory Access</strong></p>

  <ul>
    <li>
      <p>now, consider if you did:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(...);</span> <span class="cm">/* e.g. address 0x10 */</span>
<span class="n">y</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
</code></pre></div>      </div>

      <p>then,t the following would happen:</p>

      <ol>
        <li><code class="language-plaintext highlighter-rouge">malloc</code> does not actually assign you physical address, i.e. there is no entry for that address $0x10$ in page table</li>
        <li>the <strong>hardware</strong> will get  <strong>page fault</strong> while trying to <em>translate the address $0x10$</em></li>
        <li>the <strong>OS traps</strong> the exception, looks at it, and realizes that $0x10$ is <strong>valid for you to use</strong> (you have <code class="language-plaintext highlighter-rouge">malloc</code>ed), so it <strong>now assigns you the physical address by adding entry in page table</strong>:
          <ul>
            <li>this means that the OS assigns you physical address <em>on the fly</em></li>
          </ul>
        </li>
        <li>restart the instruction</li>
        <li>then everything would work</li>
      </ol>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Read Fault and Write Fault</strong></p>

  <ul>
    <li>
      <p>Basically when a memory is already given to you by <code class="language-plaintext highlighter-rouge">malloc()</code>, it is not yet created physically, so it would <em>have no page table entries</em></p>

      <ul>
        <li>
          <p>then, attempting to write into it would generate a <em>write fault</em>, after which you will have data actually written and <em>protection bits looking like</em></p>

          <table>
            <thead>
              <tr>
                <th>young (access) bit</th>
                <th>dirty bit</th>
                <th>write bit</th>
                <th>user bit</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td>1</td>
                <td>1</td>
                <td>1</td>
              </tr>
            </tbody>
          </table>
        </li>
        <li>
          <p>or, if you <em>attempted to read</em>, it will generate a <em>read fault</em>, and the page table entries <strong>will also be initialized</strong> and you would have:</p>

          <table>
            <thead>
              <tr>
                <th>young (access) bit</th>
                <th>dirty bit</th>
                <th>write bit</th>
                <th>user bit</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td>0</td>
                <td>1</td>
                <td>1</td>
              </tr>
            </tbody>
          </table>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="mmap">Mmap</h3>

<p><code class="language-plaintext highlighter-rouge">mmap</code> again allocates <em>virtual address space</em>, but you have <strong>more controls</strong></p>

<ul>
  <li>e.g. you can control at what (range of) <code class="language-plaintext highlighter-rouge">address</code> of the virtual memory you will be given</li>
  <li>e.g. you can specify <em>permissions</em>, such as read-only <code class="language-plaintext highlighter-rouge">PRUT_READ</code></li>
  <li>e.g. what type of memory you are given, such as the normal memory<code class="language-plaintext highlighter-rouge">MAP_ANONUMOUS</code>, or an actual <em>file</em></li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>this means that your Heap does <strong>not grow contiguously</strong></li>
    <li>this would be useful when you need some <strong>precise control on what memory address you get</strong></li>
  </ul>
</blockquote>

<h2 id="kernel-space-memory">Kernel Space Memory</h2>

<p>The story is a little bit <strong>different</strong> in kernel memory than dealing with <strong>user space memory</strong></p>

<ol>
  <li>since physical memories are <strong>already mapped in for kernel</strong>, <code class="language-plaintext highlighter-rouge">kmalloc()</code> actually gives you <strong>physical memory</strong>
    <ul>
      <li>as compared to the user space, where addresses are <em>not backed with physical memory at first</em></li>
    </ul>
  </li>
</ol>

<p><strong>Similar</strong> to user space, we are:</p>

<ol>
  <li><strong>allocating/using</strong> kernel space memory in terms of a <strong>page/frame</strong>. Additionally, the kernel is/should be able to allocate <strong>physically contiguous memories</strong>.
    <ul>
      <li>one need for this would be doing large amount of<code class="language-plaintext highlighter-rouge">I/O</code> where <em>DMA/Direct Memory Access</em> is used, so that the device can store/pull <code class="language-plaintext highlighter-rouge">I/O</code> data in a large amount at once <em>without going to the CPU each time</em></li>
      <li>in general, the kernel does this by <strong>trying to save large areas of memory to be free</strong> (i.e. if you needed it later), <strong>by giving you the smallest area of memory that fits your need</strong></li>
    </ul>
  </li>
</ol>

<h3 id="buddy-algorithm">Buddy Algorithm</h3>

<p>This is the algorithm for kernel to achieve that <em>large areas of memory are saved for future uses</em></p>

<blockquote>
  <p><strong>Buddy Algorithm</strong></p>

  <p>==TODO==</p>

  <p><img src="\lectures\images\typora-user-images\image-20210326153029152.png" alt="image-20210326153029152" style="zoom:50%;" /></p>

  <ul>
    <li>split into pieces and gives you the smallest amount</li>
    <li>buddy algorithm will keep track of the <strong>spitted, free memory</strong>, each chunk being $2^n$, for $n$ being the <strong>order</strong>
      <ul>
        <li>e.g. $2^0=1$ means allocation of <strong>one page of memory</strong></li>
        <li>a</li>
      </ul>
    </li>
    <li>when you allocate and free, the memory with its order will be updated</li>
    <li>when it is <em>possible to merge some unused areas</em>, the kernel will do so by:
      <ol>
        <li>merge the area</li>
        <li>put the area back to the <strong>correct order</strong></li>
      </ol>
    </li>
  </ul>
</blockquote>

<p>Now, besides allocating space in kernel space, you might want to deal with the case that</p>

<ul>
  <li>sometimes, you <strong>don’t need a <code class="language-plaintext highlighter-rouge">page</code> size of space</strong>. For example, you might just need one byte.</li>
  <li>this is optimized by a <strong>page cache</strong>, which basically stores some (partially) free pages for use later</li>
</ul>

<h3 id="slab">Slab</h3>

<blockquote>
  <p><strong>Slab in Page Cache</strong></p>

  <ul>
    <li>There is a <strong>slab allocator for the page cache</strong></li>
    <li>A slab is a <strong>contiguous region of physical memory</strong> given <em>from the buddy allocator</em> to the <strong>page cache</strong></li>
    <li>then, in the end, instead of <em>going every time to construct a page</em>, you just need to <strong>ask the slab allocator</strong> if there is some <code class="language-plaintext highlighter-rouge">page</code> left in the <strong>slab</strong> for use.
      <ul>
        <li>in general, this would be more efficient due to the overhead of doing the walk every time</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="page-replacement">Page Replacement</h2>

<p>This is something that occurs when the system has <strong>low memory</strong>, so that it wants to <strong>reclaim memory</strong></p>

<ol>
  <li>it needs to <strong>decide</strong> which already using<code class="language-plaintext highlighter-rouge">page</code> to <strong>free</strong> (needs an algorithm)</li>
  <li>writing those data to <strong>disk</strong> (i.e. we are swapping to disk)</li>
  <li><strong>free</strong> the page/frame</li>
  <li><strong>assign</strong> it to the new process</li>
</ol>

<p>Alike scheduling algorithm, there are many possible solutions:</p>

<ol>
  <li><strong>FIFO</strong> - replacing the <em>first memory <strong>allocated</strong></em></li>
  <li><strong>LRU</strong></li>
  <li><strong>LRU Approximation</strong></li>
</ol>

<blockquote>
  <p><strong>In kernel</strong></p>

  <ul>
    <li>the entire page replacement job is done by the process <code class="language-plaintext highlighter-rouge">kswapd</code>
      <ul>
        <li>periodically woken up when a zone of memory <em>drops below the watermark/threshold</em></li>
        <li>then does the <strong>page replacement when needed</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="fifo">FIFO</h3>

<p>Consider the case that we have</p>

<p><img src="\lectures\images\typora-user-images\image-20210326215039257.png" alt="image-20210326215039257" style="zoom: 33%;" /></p>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1F</code> means accessing <code class="language-plaintext highlighter-rouge">1</code>, and having a <code class="language-plaintext highlighter-rouge">Page_Fault</code></li>
</ul>

<blockquote>
  <p><strong>Belady’s Anomaly</strong></p>

  <ul>
    <li>with certain algorithm, if you <em>increase the amount of memory</em>, you <em>increase the amount of  Page Faults</em></li>
    <li>this basically says that <strong>those algorithms are bad algorithms</strong></li>
  </ul>
</blockquote>

<h3 id="furthest-in-the-future">Furthest In the Future</h3>

<blockquote>
  <p><strong>Best Algorithm</strong></p>

  <ul>
    <li>cannot perform better than this</li>
    <li>but we <em>do not know the future</em></li>
  </ul>
</blockquote>

<p><img src="\lectures\images\typora-user-images\image-20210326215509422.png" alt="image-20210326215509422" style="zoom:50%;" /></p>

<p>where notice that we <strong>no longer has Belady’s Anomaly</strong>.</p>

<p>Therefore, instead, we should try:</p>

<ul>
  <li>look in the past, and replace the <strong>furthest in the past</strong>, i.e. <strong>least recently used</strong></li>
</ul>

<h3 id="least-recently-used">Least Recently Used</h3>

<p>This is basically based on the <strong>idea</strong> of furthest in the future</p>

<p><img src="\lectures\images\typora-user-images\image-20210326220105075.png" alt="image-20210326220105075" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>there is no <strong>Belady’s Anomaly</strong></li>
  <li>this is not <em>commonly used even though it is good</em>. Because we essentially need to store <strong>what has been accessed</strong>, which is some big overhead</li>
</ul>

<blockquote>
  <p><strong>In General</strong></p>

  <ul>
    <li>the behavior that is the same across algorithms is: when the <em>memory of goes low</em>, this will cause <strong>many page faults</strong></li>
  </ul>
</blockquote>

<h3 id="lru-approximation">LRU Approximation</h3>

<p>We can’t keep track of all the information, e.g. a <code class="language-plaintext highlighter-rouge">timestamp</code>, there will be an <strong>access bit</strong></p>

<ul>
  <li>goes from $0 \to 1$ if it is <em>accessed</em>, and the <strong>hardware will set the bit</strong></li>
</ul>

<p>Then the algorithm is called the <strong>second chance</strong>. If you needed some memory replacement, you would <em>loop over the pages and</em>:</p>

<ul>
  <li>see if accessed (i.e. <code class="language-plaintext highlighter-rouge">access</code> bit = 1),
    <ul>
      <li>if yes, <strong>clear</strong> the bit</li>
      <li>else, (i.e. the access bit for a memory is <em>not set</em>) <strong>replace</strong> this page</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>this means only <code class="language-plaintext highlighter-rouge">1</code> bit of information. However, this can be <strong>improved</strong> if we in the <strong>OS</strong>, <strong>store the last access bit</strong>
      <ul>
        <li>then we now have a <code class="language-plaintext highlighter-rouge">2</code> bit information</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><img src="\lectures\images\typora-user-images\image-20210326221222955.png" alt="image-20210326221222955" style="zoom:50%;" /></p>

<h3 id="thrashing">Thrashing</h3>

<p>As a result, we see that low memory -&gt; memory replacement -&gt; page faults.</p>

<blockquote>
  <p><strong>Thrashing</strong></p>

  <ul>
    <li>processes <em>spend more time doing page faulting</em> (e.g. due to page replacement) than executing programs.
      <ul>
        <li>the result is to hear your disks spinning very fast</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>The main solution is to <strong>reduced the number of processes</strong>:</p>

<ol>
  <li><strong><em>swap the entire process with its memory out to disk</em></strong> (i.e. that process is consuming much memory)</li>
  <li><strong><em>kill processes</em></strong></li>
</ol>

<p>To know <em>which process to kill/swap</em>:</p>

<blockquote>
  <p><strong>Working Set</strong></p>

  <ul>
    <li>Measure of how much memory a process needs.</li>
    <li>Some approximation/calculation of it would be:
      <ul>
        <li>using <em>page fault rate</em></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="improve-page-performance">Improve Page Performance</h3>

<blockquote>
  <p><strong>Increase Page Performance</strong></p>

  <ul>
    <li><em>increase page size</em> - larger page given to you when you have a page fault (so overhead of doing page faults are lower)
      <ul>
        <li>using <code class="language-plaintext highlighter-rouge">huge_page</code></li>
        <li><strong>downside</strong> is that you might just waste those space =&gt; causing more <em>page replacement -&gt; page faults</em></li>
      </ul>
    </li>
    <li><em>pre-paging</em> - doing page faults ahead of time, so that when you actually need it, no overhead
      <ul>
        <li>rather than getting the memory on demand</li>
        <li><strong>downside</strong> is that
          <ul>
            <li>same phenomena of wasting those space</li>
            <li>if your <code class="language-plaintext highlighter-rouge">I/O</code> <strong>bandwidth is limited</strong>, then pre-paging/fetching data from RAM = causes <code class="language-plaintext highlighter-rouge">I/O</code> usage could limit <code class="language-plaintext highlighter-rouge">I/O</code> of <em>other processes</em></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><em>program structure</em>
      <ul>
        <li>see below, basically could affect <em>cache misses</em></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p><em>For Example: Program Structure</em></p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-03-30_16-23-23.png" style="zoom:50%;" /></p>

<p>where the <strong>number needs of accessing different pages</strong> (could also <em>increase page faults if limited memory left/cache miss</em>) is different depending on:</p>

<ul>
  <li>if the <code class="language-plaintext highlighter-rouge">A[0][0]</code>’s address is <em>right next to</em> <code class="language-plaintext highlighter-rouge">A[0][1]</code> or <code class="language-plaintext highlighter-rouge">A[1][0]</code>, i.e. whether they are <em>one the same page</em></li>
</ul>

<h2 id="actual-linux-implementation-1">Actual Linux Implementation</h2>

<h3 id="linux-memory-management">Linux Memory Management</h3>

<p>In short, everything will be in <code class="language-plaintext highlighter-rouge">/mm</code>, and recall that:</p>

<ul>
  <li>
    <p>inside <code class="language-plaintext highlighter-rouge">task_struct</code>, we have:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">task_struct</span><span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="k">struct</span> <span class="n">mm_struct</span>		<span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span>		<span class="o">*</span><span class="n">active_mm</span><span class="p">;</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p><strong>Some Really Useful Documents</strong></p>

  <ul>
    <li>https://www.kernel.org/doc/gorman/html/understand/understand006.html</li>
  </ul>
</blockquote>

<h4 id="struct-mm_struct"><code class="language-plaintext highlighter-rouge">struct</code> mm_struct</h4>

<p>Inside <code class="language-plaintext highlighter-rouge">include/linux/mm_types.h</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">mm_struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">mmap</span><span class="p">;</span>		<span class="cm">/* list of VMAs = VM Area; pointer to the first vm_area_struct */</span>
        								  <span class="cm">/* each continguous address in use */</span>
        <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">mm_rb</span><span class="p">;</span>				<span class="cm">/* vma in rb-tree, for faster access */</span>
        
        <span class="cm">/* some code omitted here */</span>
		
		<span class="n">pgd_t</span> <span class="o">*</span> <span class="n">pgd</span><span class="p">;</span> <span class="cm">/* base address of the highest level page table */</span>
        			<span class="cm">/* this will get linked to other levels such as p4d, pte, etc. */</span>

    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">struct vm_area_struct *mmap</code> is <strong>contiguous</strong>, so that</p>

    <ul>
      <li>
        <p>every time you are mallocing, this would be <em>likely</em> the place where it increases</p>
      </li>
      <li>
        <p>so we have the field <code class="language-plaintext highlighter-rouge">vm_start</code> and <code class="language-plaintext highlighter-rouge">vm_end</code></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="p">{</span>
	<span class="cm">/* The first cache line has the info for VMA tree walking. */</span>
    
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_start</span><span class="p">;</span>		<span class="cm">/* Our start address within vm_mm. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_end</span><span class="p">;</span>		<span class="cm">/* The first byte after our end address
					   within vm_mm. */</span>
        
    <span class="n">pgprot_t</span> <span class="n">vm_page_prot</span><span class="p">;</span>		<span class="cm">/* Access permissions of this VMA. */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">;</span>	     <span class="cm">/* e.g. mmap specifies read-only */</span>
        
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <p>in fact, the kernel also does some <em>optimization of merging neighboring, contiguous <code class="language-plaintext highlighter-rouge">vm_area</code>s</em></p>

        <ul>
          <li>note that the <code class="language-plaintext highlighter-rouge">unsigned long vm_flag</code> and <code class="language-plaintext highlighter-rouge">pgprot_t vm_page_prot</code> tells you permissions</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>
      <p>recall that the virtual address space also contains the <em>kernel</em> portion (shared among all processes). This means that the kernel itself is using the <em>virtual address space</em>, and <strong>has its own page table</strong> for accessing physical addresses</p>
    </li>
    <li>
      <p>however, for modern <code class="language-plaintext highlighter-rouge">64</code> bit systems (though only <code class="language-plaintext highlighter-rouge">48</code> bits are used for most systems), we have around <code class="language-plaintext highlighter-rouge">256TB</code> of virtual memory, and that:</p>

      <ul>
        <li>half of it <code class="language-plaintext highlighter-rouge">128TB</code> is given to kernel</li>
        <li>other half to user</li>
      </ul>

      <p>Therefore, in the end, since your RAM is most likely no<code class="language-plaintext highlighter-rouge">128TB</code>, you will end up having <strong>all your RAM already mapped into the kernel’s virtual space</strong></p>

      <ul>
        <li>therefore, <code class="language-plaintext highlighter-rouge">kmalloc()</code> in kernel would <em>actually assign you with physical addresses</em></li>
        <li>the field <code class="language-plaintext highlighter-rouge">pgd_t * pgd</code> is technically <em>virtual address</em> of kernel space, but its entry is <strong>always available in page table, mapping to a physical address</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="struct-pgd_t"><code class="language-plaintext highlighter-rouge">struct</code> pgd_t</h4>

<p>this is the field in <code class="language-plaintext highlighter-rouge">mm_struct</code> where you actually find the page tables</p>

<ul>
  <li>first, <code class="language-plaintext highlighter-rouge">typedef struct { pgdval_t pgd; } pgd_t;</code></li>
  <li>essentially, this is the <strong>address of the starting entry of a page table</strong></li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>since this is hardware dependent, we look at the <code class="language-plaintext highlighter-rouge">x86</code> one inside the directory <code class="language-plaintext highlighter-rouge">/arch/x86/include/asm/pgtable_types.h</code></li>
    <li>the below is a structure of the entire, single <em>page table</em></li>
  </ul>
</blockquote>

<blockquote>
  <p><em>Reminder</em></p>

  <ul>
    <li>
      <p>the Main Memory is divided into parts called as ‘Frames’ and the process’s virtual memory is divided into ‘Pages’</p>
    </li>
    <li>
      <p>A Page Table keeps track of the pages and where they are present in the Main Memory.</p>
    </li>
    <li>
      <p>The pages can be present in any frame. The frames need not be contiguous.</p>
    </li>
    <li>
      <p>Page Size = Frame Size.</p>
    </li>
    <li>
      <p>and that the entry looks like:</p>

      <p><img src="https://media.geeksforgeeks.org/wp-content/uploads/Capture-24.png" style="zoom:50%;" /></p>
    </li>
  </ul>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* basically, those are associated to the frame number of an entry */</span>
<span class="cp">#define _PAGE_BIT_PRESENT	0	</span><span class="cm">/* if that page/frame of the entry is present */</span><span class="cp">
#define _PAGE_BIT_RW		1	</span><span class="cm">/* writeable */</span><span class="cp">
#define _PAGE_BIT_USER		2	</span><span class="cm">/* userspace addressable */</span><span class="cp">
#define _PAGE_BIT_PWT		3	</span><span class="cm">/* page write through */</span><span class="cp">
#define _PAGE_BIT_PCD		4	</span><span class="cm">/* page cache disabled */</span><span class="cp">
#define _PAGE_BIT_ACCESSED	5	</span><span class="cm">/* was accessed (raised by CPU) */</span><span class="cp">
#define _PAGE_BIT_DIRTY		6	</span><span class="cm">/* was written to (raised by CPU) */</span><span class="cp">
</span></code></pre></div></div>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>essentially, the <code class="language-plaintext highlighter-rouge">permission</code> flags of <code class="language-plaintext highlighter-rouge">vm_area_struct</code> is <em>independent</em> of the permissions of the <strong>page table entry</strong>. So that you could have:
      <ul>
        <li>a writable <code class="language-plaintext highlighter-rouge">vm_area_struct</code>, so OS allows it (i.e. for virtual address space)</li>
        <li>a not-writable <code class="language-plaintext highlighter-rouge">page_table_entry</code>, so hardware will not write it (i.e. for physical address space)</li>
        <li>then you will get a page fault</li>
      </ul>
    </li>
    <li>those bits are <strong>essentially stored in the lower 12 bits of the <code class="language-plaintext highlighter-rouge">pte</code> entry</strong>
      <ul>
        <li>basically stored like a bit map, so that <code class="language-plaintext highlighter-rouge">000000000101</code> means present and user accessible</li>
        <li>makes sense since the <em>page offset</em> (in the frame/page) is <code class="language-plaintext highlighter-rouge">12</code> bits</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="struct-page"><code class="language-plaintext highlighter-rouge">struct</code> page</h4>

<p>this is how the kernel <em>mages the frame</em> for each actual address</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">page</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>		<span class="cm">/* Atomic flags, some possibly
					 * updated asynchronously */</span>
	<span class="cm">/*
	 * Five words (20/40 bytes) are available in this union.
	 * WARNING: bit 0 of the first word is used for PageTail(). That
	 * means the other users of this union MUST NOT use the bit to
	 * avoid collision and false-positive PageTail().
	 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>	<span class="cm">/* Page cache and anonymous pages */</span>
			<span class="cm">/**
			 * @lru: Pageout list, eg. active_list protected by
			 * pgdat-&gt;lru_lock.  Sometimes used as a generic list
			 * by the page owner.
			 */</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="n">lru</span><span class="p">;</span>
			<span class="cm">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span>
			<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
			<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>		<span class="cm">/* Our offset within mapping. */</span>
			<span class="cm">/**
			 * @private: Mapping-private opaque data.
			 * Usually used for buffer_heads if PagePrivate.
			 * Used for swp_entry_t if PageSwapCache.
			 * Indicates order in the buddy system if PageBuddy.
			 */</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">private</span><span class="p">;</span>
		<span class="p">};</span>
		<span class="cm">/* some code omitted here */</span>
		<span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="func-do_page_fault"><code class="language-plaintext highlighter-rouge">func</code> do_page_fault()</h4>

<p>when a page fault happens, it <strong>within instruction</strong>, namely, an exception/trap (instead of an interrupt)</p>

<ul>
  <li>
    <p>similar to interrupt handlers, those traps also have handlers</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">idtentry</span> <span class="n">page_fault</span>		<span class="n">do_page_fault</span>		<span class="n">has_error_code</span><span class="o">=</span><span class="mi">1</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>then the <code class="language-plaintext highlighter-rouge">do_page_fault</code> does:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span>
<span class="nf">__do_page_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hw_error_code</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prefetchw</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">kmmio_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">address</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Was the fault on kernel-controlled part of the address space? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fault_in_kernel_space</span><span class="p">(</span><span class="n">address</span><span class="p">)))</span>
		<span class="n">do_kern_addr_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">do_user_addr_fault</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span> <span class="cm">/* most likely */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>then the <code class="language-plaintext highlighter-rouge">do_user_addr_fault();</code> knows:</p>

<ul>
  <li>what is the error code</li>
  <li>
    <p>which address this is happening</p>
  </li>
  <li>
    <p>and then <strong>does</strong>:</p>

    <ol>
      <li>gets the process that causes this</li>
      <li>does some checks and append a few flags to the error code based on what is done</li>
      <li>finds the <code class="language-plaintext highlighter-rouge">vm_area</code> associated with that address
        <ol>
          <li>if no <code class="language-plaintext highlighter-rouge">vm_area</code> returns, then it means this address is not <em>granted at all</em></li>
        </ol>
      </li>
      <li>memory is valid, now check if we have some access errors
        <ol>
          <li>e.g. trying to do a write, but <code class="language-plaintext highlighter-rouge">vm_area</code> is <em>not writable</em></li>
        </ol>
      </li>
      <li>handles the fault with <code class="language-plaintext highlighter-rouge">handle_mm_fault()</code></li>
    </ol>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Handle faults in the user portion of the address space */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">do_user_addr_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hw_error_code</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">vm_fault_t</span> <span class="n">fault</span><span class="p">,</span> <span class="n">major</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">FAULT_FLAG_ALLOW_RETRY</span> <span class="o">|</span> <span class="n">FAULT_FLAG_KILLABLE</span><span class="p">;</span>
  
    <span class="cm">/* 1. gets the task of problem, and its memory space */</span>
	<span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
  
    <span class="cm">/* 2. does some checks and append a few flags to the error code */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hw_error_code</span> <span class="o">&amp;</span> <span class="n">X86_PF_WRITE</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">;</span>
  
    <span class="cm">/* 3. finds the `vm_area` associated with that address */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span> <span class="cm">/* essentially traverses the rb-tree in logN */</span>
    <span class="cm">/* 3.1 if this address is not *granted at all* */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bad_area</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
  	
    <span class="cm">/* some code omitted here */</span>
	<span class="cm">/*
	 * Ok, we have a good vm_area for this memory access, so
	 * we can handle it..
	 */</span>
<span class="nl">good_area:</span>
    <span class="cm">/* 4. memory is valid, now check if we have some access errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">access_error</span><span class="p">(</span><span class="n">hw_error_code</span><span class="p">,</span> <span class="n">vma</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">bad_area_access_error</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
  
	<span class="cm">/*
	 * If for any reason at all we couldn't handle the fault,
	 * make sure we exit gracefully rather than endlessly redo
	 * the fault.  Since we never set FAULT_FLAG_RETRY_NOWAIT, if
	 * we get VM_FAULT_RETRY back, the mmap_sem has been unlocked.
	 *
	 * Note that handle_userfault() may also release and reacquire mmap_sem
	 * (and not return with VM_FAULT_RETRY), when returning to userland to
	 * repeat the page fault later with a VM_FAULT_NOPAGE retval
	 * (potentially after handling any pending signal during the return to
	 * userland). The return to userland is identified whenever
	 * FAULT_FLAG_USER|FAULT_FLAG_KILLABLE are both set in flags.
	 */</span>
    <span class="cm">/* 5. handles the fault with `handle_mm_fault()` */</span>
	<span class="n">fault</span> <span class="o">=</span> <span class="n">handle_mm_fault</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">major</span> <span class="o">|=</span> <span class="n">fault</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_MAJOR</span><span class="p">;</span>
      
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>then the <code class="language-plaintext highlighter-rouge">handle_mm_fault()</code> does:</p>

    <ul>
      <li>
        <p>` __handle_mm_fault(vma, address, flags);`, which does:</p>

        <ol>
          <li>we have already get the error, and done some basic checks</li>
          <li>actually go to the <code class="language-plaintext highlighter-rouge">page_table_entry</code> to see what has gone wrong, by <em>walking through the multilevel page table</em>
            <ul>
              <li>e.g. need physical memory assignment</li>
            </ul>
          </li>
          <li>finally, when the <em>walk is done</em>, we do <code class="language-plaintext highlighter-rouge">handle_pte_fault()</code></li>
        </ol>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * By the time we get here, we already hold the mm semaphore
 *
 * The mmap_sem may have been released depending on flags and our
 * return value.  See filemap_fault() and __lock_page_or_retry().
 */</span>
<span class="k">static</span> <span class="n">vm_fault_t</span> <span class="nf">__handle_mm_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 1. has already done some checks, now want to check page table */</span>
	<span class="k">struct</span> <span class="n">vm_fault</span> <span class="n">vmf</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="p">,</span>
		<span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pgoff</span> <span class="o">=</span> <span class="n">linear_page_index</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">),</span>
		<span class="p">.</span><span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">__get_fault_gfp_mask</span><span class="p">(</span><span class="n">vma</span><span class="p">),</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirty</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
        
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">p4d_t</span> <span class="o">*</span><span class="n">p4d</span><span class="p">;</span>
	<span class="n">vm_fault_t</span> <span class="n">ret</span><span class="p">;</span>
    
    <span class="cm">/* 2. walk through the pgd and p4d */</span>
	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span> <span class="cm">/* indexes */</span>
    <span class="n">p4d</span> <span class="o">=</span> <span class="n">p4d_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
        
    <span class="cm">/* 3. finally, when the *walk is done*, we do `handle_pte_fault()` */</span>
    <span class="k">return</span> <span class="n">handle_pte_fault</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <p>where:</p>

        <ul>
          <li>the <code class="language-plaintext highlighter-rouge">pgd_offset</code> computes by:
            <ol>
              <li>taking the <em>base address of the page table</em> by <code class="language-plaintext highlighter-rouge">mm-&gt;pgd</code></li>
              <li>adding the <em>indexed address</em> <code class="language-plaintext highlighter-rouge">pgd_index(address)</code> + <em>base address</em>, which gives you the <strong>actual address for the next page table</strong>
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">pgd_index(address)</code> takes the top levels of the faulted address, and indexes into the page table</li>
                </ul>
              </li>
            </ol>
          </li>
        </ul>

        <blockquote>
          <p><strong>Note</strong></p>

          <ul>
            <li>note that we are assuming that a semaphore is already grabbed. which will be typically used for memory accesses.</li>
          </ul>
        </blockquote>

        <p>then, inside <code class="language-plaintext highlighter-rouge">handle_pte_fault()</code> we do</p>

        <ol>
          <li>
            <p>gets the <code class="language-plaintext highlighter-rouge">pte</code> entry</p>
          </li>
          <li>
            <p>if the <code class="language-plaintext highlighter-rouge">pte</code> entry is empty, namely <em>no physical address assigned in the end</em></p>

            <ul>
              <li>if the memory is <strong>anonymous</strong>, this means now <em>the memory is <code class="language-plaintext highlighter-rouge">malloc()</code>ed</em> but not assigned actual physical page/address. then we <strong>do</strong> <code class="language-plaintext highlighter-rouge">do_anonymous_page()</code></li>
              <li>a not-anonymous memory would be memories backed by a file</li>
            </ul>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">vm_fault_t</span> <span class="nf">handle_pte_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* See comment in pte_alloc_one_map() */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_devmap_trans_unstable</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*
		 * A regular pmd is established and it can't morph into a huge
		 * pmd from under us anymore at this point because we hold the
		 * mmap_sem read mode and khugepaged takes it in write mode.
		 * So now it's safe to run pte_offset_map().
		 */</span>
               
        <span class="cm">/* 1. gets the `pte` entry */</span>
		<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
		<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">orig_pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">;</span>
       
		<span class="cm">/*
		 * some architectures can have larger ptes than wordsize,
		 * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and
		 * CONFIG_32BIT=y, so READ_ONCE cannot guarantee atomic
		 * accesses.  The code below just needs a consistent view
		 * for the ifs and we later double check anyway with the
		 * ptl lock held. So here a barrier will do.
		 */</span>
		<span class="n">barrier</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">orig_pte</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pte_unmap</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">);</span>
			<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
           
    <span class="cm">/* 2. if the `pte` entry is empty */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma_is_anonymous</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">do_anonymous_page</span><span class="p">(</span><span class="n">vmf</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">do_fault</span><span class="p">(</span><span class="n">vmf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>            </div>

            <p>then, inside <code class="language-plaintext highlighter-rouge">do_anonymous_page()</code> we have</p>

            <ol>
              <li>
                <p><strong>allocate a <code class="language-plaintext highlighter-rouge">page</code></strong></p>

                <ul>
                  <li>Linux uses <code class="language-plaintext highlighter-rouge">struct page</code> to keep track of <strong>each frame of memory (smallest unit)</strong></li>
                </ul>
              </li>
              <li>
                <p><strong>make the <code class="language-plaintext highlighter-rouge">pte</code> entry</strong> of the above <em>created</em> <code class="language-plaintext highlighter-rouge">page</code></p>

                <ul>
                  <li>
                    <p>now, the idea is to store the <strong>physical address of the <code class="language-plaintext highlighter-rouge">page</code></strong> to a <code class="language-plaintext highlighter-rouge">pte</code>, such that the <strong>hardware next time can translate and get the data</strong>. So we need to basically create something like:</p>

                    <p><code class="language-plaintext highlighter-rouge">[frame_numer ..] | [physical address]</code></p>

                    <p>so in code, it does:</p>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define mk_pte(page, pgprot)   pfn_pte(page_to_pfn(page), (pgprot))
</span></code></pre></div>                    </div>
                  </li>
                </ul>
              </li>
              <li>
                <p>after that, you put the <code class="language-plaintext highlighter-rouge">pte</code> entry into the page table</p>

                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">vm_fault_t</span> <span class="nf">do_anonymous_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 1. allocate a `page` */</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">alloc_zeroed_user_highpage_movable</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
              
    <span class="cm">/* 2. **make the `pte` entry** of the above *created* `page` */</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">)</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkwrite</span><span class="p">(</span><span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">));</span>
              
<span class="nl">setpte:</span>
    <span class="cm">/* 3.  put the `pte` entry into the page table */</span>
	<span class="n">set_pte_at</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>                </div>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p>Now, this example shows how <code class="language-plaintext highlighter-rouge">Page_Fault</code> due to missing <code class="language-plaintext highlighter-rouge">pte</code> works, There could be other cases where <code class="language-plaintext highlighter-rouge">Page_Fault</code> occurs</p>

<h5 id="access-error">Access Error</h5>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>
      <p>another case is for <code class="language-plaintext highlighter-rouge">access_error()</code>, so that inside ` do_user_addr_fault` we <strong>checked</strong>:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">access_error</span><span class="p">(</span><span class="n">hw_error_code</span><span class="p">,</span> <span class="n">vma</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">bad_area_access_error</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">hw_error_code</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div>      </div>

      <p>then inside the <code class="language-plaintext highlighter-rouge">access_error()</code>, it does:</p>

      <ol>
        <li>
          <p>if <code class="language-plaintext highlighter-rouge">vm_area</code> is <em>writable</em>, but there is <strong><code class="language-plaintext highlighter-rouge">pte</code> entry is write protected</strong>, return <code class="language-plaintext highlighter-rouge">0= not access error</code></p>

          <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">X86_PF_WRITE</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* write, present and write, not present: */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">)))</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>          </div>
        </li>
      </ol>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><em>Reminder</em></p>

  <ul>
    <li>
      <p>in the section <a href="# copy_process()"><code class="language-plaintext highlighter-rouge">func</code> copy_process()</a>, we see that when we are <code class="language-plaintext highlighter-rouge">copy_process()</code> a <strong>new process</strong>, we essentially copied over the <code class="language-plaintext highlighter-rouge">pte</code>s but not the actual <code class="language-plaintext highlighter-rouge">page</code>, and then made <strong>both <code class="language-plaintext highlighter-rouge">pte</code> entries write protected</strong>.</p>

      <ul>
        <li>
          <p>this means that the <code class="language-plaintext highlighter-rouge">vm_area</code> is <strong>writable</strong>, but the <code class="language-plaintext highlighter-rouge">pte</code> and its underlying <code class="language-plaintext highlighter-rouge">page</code> is <strong>write protected</strong></p>
        </li>
        <li>
          <p>in fact, the protection bit will look like this:</p>

          <table>
            <thead>
              <tr>
                <th>young (access) bit</th>
                <th>dirty bit</th>
                <th>write bit</th>
                <th>user bit</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>0</td>
                <td>0/1</td>
                <td>0</td>
                <td>1</td>
              </tr>
            </tbody>
          </table>

          <p>so that it’s cleaned in the sense of <code class="language-plaintext highlighter-rouge">write_bit/access_bit</code> is set to 0</p>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Now, if we have the above case, our code <em>still goes to <code class="language-plaintext highlighter-rouge">handle_pte_fault()</code> eventually</em>:</p>

<ol>
  <li>
    <p>now it is the case of <code class="language-plaintext highlighter-rouge">vmf-&gt;flags &amp; FAULT_FLAG_WRITE</code>, we would like to <strong>actually copy over the underlying <code class="language-plaintext highlighter-rouge">pages</code></strong> by <code class="language-plaintext highlighter-rouge">do_wp_page(vmf);</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">vm_fault_t</span> <span class="nf">handle_pte_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">do_wp_page</span><span class="p">(</span><span class="n">vmf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_ERROR</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">&amp;=</span> <span class="n">VM_FAULT_ERROR</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>then inside <code class="language-plaintext highlighter-rouge">do_wp_page(vmf)</code>:</p>

    <ol>
      <li>finally, <strong>does the copy</strong> via <code class="language-plaintext highlighter-rouge">wp_page_copy(vmf);</code></li>
    </ol>
  </li>
</ol>

<h4 id="func-copy_process"><code class="language-plaintext highlighter-rouge">func</code> copy_process()</h4>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>this is used, for example, at the creation of a <strong>new process</strong> via <code class="language-plaintext highlighter-rouge">fork()</code> -&gt; <code class="language-plaintext highlighter-rouge">do_fork()</code>-&gt;<code class="language-plaintext highlighter-rouge">copy_process()</code></li>
  </ul>
</blockquote>

<blockquote>
  <p><em>Reminder</em></p>

  <ul>
    <li>recall that the kernel also is a virtual memory space. The difference with a user’s process’s virtual memory space is that <strong>everything is already mapped to physical address</strong> for the kernel</li>
  </ul>
</blockquote>

<p>Starting with <code class="language-plaintext highlighter-rouge">kernl/fork.c</code>, we have <code class="language-plaintext highlighter-rouge">copy_process</code>, which</p>

<ul>
  <li>
    <p>does a bunch of initialization, including <code class="language-plaintext highlighter-rouge">copy_mm()</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">__latent_entropy</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">copy_process</span><span class="p">(</span>
					<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">trace</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kernel_clone_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">copy_mm</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">bad_fork_cleanup_signal</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>then inside <code class="language-plaintext highlighter-rouge">copy_mm()</code></p>

    <ol>
      <li>
        <p>check if it is shared <code class="language-plaintext highlighter-rouge">mm</code> via <code class="language-plaintext highlighter-rouge">clone_flags</code></p>
      </li>
      <li>
        <p>if we want to create a new <code class="language-plaintext highlighter-rouge">mm</code>, then <code class="language-plaintext highlighter-rouge">dup_mm(tsk, current-&gt;mm)</code></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_mm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 1. check if it is shared `mm` via `clone_flags` */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_VM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mmget</span><span class="p">(</span><span class="n">oldmm</span><span class="p">);</span>
		<span class="n">mm</span> <span class="o">=</span> <span class="n">oldmm</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">good_mm</span><span class="p">;</span>
	<span class="p">}</span>
     
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="cm">/* 2. if we want to create a new `mm`, then `dup_mm(tsk, current-&gt;mm)` */</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">dup_mm</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_nomem</span><span class="p">;</span>
     
<span class="nl">good_mm:</span>
	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <p>then, inside <code class="language-plaintext highlighter-rouge">dup_mm()</code>, we do:</p>

        <ol>
          <li>
            <p><em>create</em> a <code class="language-plaintext highlighter-rouge">mm_struct</code> via <code class="language-plaintext highlighter-rouge">allocate_mm</code></p>
          </li>
          <li>
            <p><em>copies all the</em> <code class="language-plaintext highlighter-rouge">oldmm</code> into this new <code class="language-plaintext highlighter-rouge">mm</code> created</p>
          </li>
          <li>
            <p><em>initializes</em> the new memory struct</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="nf">dup_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
                                <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">oldmm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
        
    <span class="cm">/* 1. *create* a `mm_struct` via `allocate_mm` */</span>
    <span class="n">mm</span> <span class="o">=</span> <span class="n">allocate_mm</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">fail_nomem</span><span class="p">;</span>
        
    <span class="cm">/* 2. *copies all the* `oldmm` into this new `mm` created */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldmm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mm</span><span class="p">));</span>
        
    <span class="cm">/* 3. *initializes* the new memory struct */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_init</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">fail_nomem</span><span class="p">;</span>
        
    <span class="cm">/* 4. does a `dup_mmap()`, which is covered below */</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">dup_mmap</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldmm</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">free_pt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>            </div>

            <p>then inside the <code class="language-plaintext highlighter-rouge">mm_init()</code>, we do:</p>

            <ol>
              <li>
                <p>a bunch of initializations</p>
              </li>
              <li>
                <p><em>allocates</em> a <code class="language-plaintext highlighter-rouge">pgd</code> for this new <code class="language-plaintext highlighter-rouge">mm</code>, including configuring the <em>kernel</em> portion of this new address space</p>

                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="nf">mm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* some code omitted here */</span>
               
    <span class="cm">/* 2. *allocates* a `pgd` for this new `mm` */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_alloc_pgd</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail_nopgd</span><span class="p">;</span>
</code></pre></div>                </div>

                <p>then inside the <code class="language-plaintext highlighter-rouge">mm_alloc_pgd()</code>, we do <code class="language-plaintext highlighter-rouge">pgd_alloc()</code>,</p>

                <ol>
                  <li>
                    <p>which goes to <code class="language-plaintext highlighter-rouge">x86</code> specific version, and <strong>does</strong><code class="language-plaintext highlighter-rouge">_pgd_alloc()</code>, and finally <code class="language-plaintext highlighter-rouge">_pgd_malloc()</code> and gives <strong>one page of memory</strong></p>
                  </li>
                  <li>
                    <p>does a <code class="language-plaintext highlighter-rouge">pgd_ctor</code>, which for <strong>page level $\ge 4$</strong> (true), goes to <code class="language-plaintext highlighter-rouge">clone_pgd_range</code> which copies:</p>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">CONFIG_PGTABLE_LEVELS</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span>
    <span class="p">(</span><span class="n">CONFIG_PGTABLE_LEVELS</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">SHARED_KERNEL_PMD</span><span class="p">)</span> <span class="o">||</span>
    <span class="n">CONFIG_PGTABLE_LEVELS</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clone_pgd_range</span><span class="p">(</span><span class="n">pgd</span> <span class="o">+</span> <span class="n">KERNEL_PGD_BOUNDARY</span><span class="p">,</span>
                    <span class="n">swapper_pg_dir</span> <span class="o">+</span> <span class="n">KERNEL_PGD_BOUNDARY</span><span class="p">,</span>
                    <span class="n">KERNEL_PGD_PTRS</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>                    </div>

                    <p>the aim of this is to <strong>configure the kernel portion of the page table of the process</strong>, (<em>recall that the virtual address space has two parts, user’s stack/heap/etc, and kernel</em>), by <strong>copying over all the page table entries</strong> which points to the kernel’s space.</p>

                    <p>The effect is that now it <strong>points to the kernel’s address space</strong>, and that this <strong>address will be the same for all other processes, making the <code class="language-plaintext highlighter-rouge">kernel</code> portion being shared across processes.</strong></p>

                    <blockquote>
                      <p><strong>Note</strong></p>

                      <ul>
                        <li>this explains better what happens when a system call of a user program happens. Essentially, we are <em>still running in the user’s process’s address space</em>, but that we are now <strong>using the kernel portion of it</strong>, which will point to the <strong>kernel’s <code class="language-plaintext highlighter-rouge">pte</code> and code essentially</strong></li>
                      </ul>
                    </blockquote>

                    <ul>
                      <li>
                        <p>the new <code class="language-plaintext highlighter-rouge">mm</code> space from <code class="language-plaintext highlighter-rouge">pgd + KERNEL_PGD_BOUNDARY</code></p>

                        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define KERNEL_PGD_BOUNDARY	pgd_index(PAGE_OFFSET)
</span></code></pre></div>                        </div>

                        <p>basically <code class="language-plaintext highlighter-rouge">pgd_index(address)</code> takes the <em>top bits of the address, and indexes into the page table:</em></p>

                        <ul>
                          <li>the <code class="language-plaintext highlighter-rouge">PAGE_OFFSET</code> is the <strong>starting address of kernel space</strong> (e.g. it may start at <code class="language-plaintext highlighter-rouge">128G</code>)</li>
                          <li>indexes into the Page Table and find out the <strong>start of the kernel’s address space</strong></li>
                        </ul>
                      </li>
                      <li>
                        <p>the old <code class="language-plaintext highlighter-rouge">mm</code> space is from <code class="language-plaintext highlighter-rouge">swapper_pg_dir + KERNEL_PGD_BOUNDARY</code></p>

                        <ul>
                          <li>where <code class="language-plaintext highlighter-rouge">swapper_pg_dir</code> is the Page Tables of the <strong>initial page table of the <code class="language-plaintext highlighter-rouge">init_mm</code>, which is the <code class="language-plaintext highlighter-rouge">mm</code> of the first task</strong></li>
                          <li>hence <code class="language-plaintext highlighter-rouge">swapper_pg_dir + KERNEL_PGD_BOUNDARY</code> gives the <strong>kernel portion</strong> of the page table</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
            <p>does a <code class="language-plaintext highlighter-rouge">dup_mmap()</code>, which does:</p>

            <ol>
              <li>
                <p>a loop using the <code class="language-plaintext highlighter-rouge">old-&gt;mmap</code> (i.e. <strong>iterates</strong> over its <code class="language-plaintext highlighter-rouge">vm_area_struct</code>)</p>

                <ul>
                  <li>recall that <code class="language-plaintext highlighter-rouge">struct vm_area_struct *mmap;</code> is pointer to the <em>first</em> <code class="language-plaintext highlighter-rouge">vm_area_struct</code> of a <code class="language-plaintext highlighter-rouge">mm</code></li>
                </ul>
              </li>
              <li>
                <p>and does a <code class="language-plaintext highlighter-rouge">copy_page_range</code> of copy over the <em>page table entries</em> from the old one into the new one</p>

                <ul>
                  <li>so that its <em>state is the same</em></li>
                </ul>

                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">__latent_entropy</span> <span class="kt">int</span> <span class="nf">dup_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">oldmm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="cm">/* 1. a loop using the `old-&gt;mmap` */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">mpnt</span> <span class="o">=</span> <span class="n">oldmm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">mpnt</span><span class="p">;</span> <span class="n">mpnt</span> <span class="o">=</span> <span class="n">mpnt</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
           
		<span class="k">if</span> <span class="p">(</span><span class="n">mpnt</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_DONTCOPY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vm_stat_account</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">mpnt</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">,</span> <span class="o">-</span><span class="n">vma_pages</span><span class="p">(</span><span class="n">mpnt</span><span class="p">));</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">charge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="cm">/* some code omitted here */</span>
                   
        <span class="cm">/* 2.  does a `copy_page_range` of copy over the *page table entries* */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WIPEONFORK</span><span class="p">))</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">copy_page_range</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldmm</span><span class="p">,</span> <span class="n">mpnt</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>                </div>

                <p>the <code class="language-plaintext highlighter-rouge">copy_page_range()</code> does:</p>

                <ol>
                  <li>
                    <p>gets the pointer to the <em>process’s first using page table entry</em> in the<code class="language-plaintext highlighter-rouge">pgd</code> via <code class="language-plaintext highlighter-rouge">pgd_offset</code></p>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define pgd_offset_pgd(pgd, address) (pgd + pgd_index((address)))
</span></code></pre></div>                    </div>

                    <p>which basically start with the <em>address of first page table entry of the <code class="language-plaintext highlighter-rouge">pgd</code></em>, and then add the offset of <code class="language-plaintext highlighter-rouge">pgd_index((address)</code> to get the <strong>address of that <code class="language-plaintext highlighter-rouge">address</code>’s page table entry</strong> in the <code class="language-plaintext highlighter-rouge">pgd</code></p>
                  </li>
                  <li>
                    <p>do the same for getting the target <code class="language-plaintext highlighter-rouge">pdg</code> address to copy to (i.e. the newly created process)</p>
                  </li>
                  <li>
                    <p>loop over and <code class="language-plaintext highlighter-rouge">copy_p4d_range</code>, which is the <em>next level of the page table</em></p>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">copy_page_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dst_mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">src_mm</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 2. do the same for getting the target `pdg` address to copy to */</span>
    <span class="n">dst_pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
    <span class="cm">/* 1. gets the pointer to the *process's first using page table entry*  */</span>
	<span class="n">src_pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">src_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
    <span class="cm">/* 3. loop over and `copy_p4d_range` */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pgd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span> <span class="cm">/* computes the virtual addr correspond to the NEXT src_pgd */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none_or_clear_bad</span><span class="p">(</span><span class="n">src_pgd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copy_p4d_range</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">src_mm</span><span class="p">,</span> <span class="n">dst_pgd</span><span class="p">,</span> <span class="n">src_pgd</span><span class="p">,</span>
					    <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">dst_pgd</span><span class="o">++</span><span class="p">,</span> <span class="n">src_pgd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
              
	<span class="cm">/* some code omitted here */</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>                    </div>

                    <p>then the next thing is <code class="language-plaintext highlighter-rouge">copy_p4d_range()</code>, which basically continues the <em>same idea</em>:</p>

                    <ol>
                      <li>get the source <code class="language-plaintext highlighter-rouge">p4d</code> and find out the address of the <em>first using page table entry</em></li>
                      <li>for the destination <code class="language-plaintext highlighter-rouge">p4d</code> of the new process, we now <em>need to allocate new spaces</em></li>
                    </ol>

                    <blockquote>
                      <p><em>Reminder</em>:</p>

                      <ul>
                        <li>we did not need to allocate the <code class="language-plaintext highlighter-rouge">pgd</code> before. This is because the <code class="language-plaintext highlighter-rouge">pgd</code> is <strong>already allocated at creation of the process</strong>.</li>
                      </ul>
                    </blockquote>

                    <ol>
                      <li>
                        <p>loop over all the <code class="language-plaintext highlighter-rouge">p4d</code>s, and do the same for the <em>next level</em>, <code class="language-plaintext highlighter-rouge">pud</code></p>

                        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">copy_p4d_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dst_mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">src_mm</span><span class="p">,</span>
		<span class="n">pgd_t</span> <span class="o">*</span><span class="n">dst_pgd</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">src_pgd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">p4d_t</span> <span class="o">*</span><span class="n">src_p4d</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_p4d</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
                 
    <span class="cm">/* 2. for the destination `p4d` of the new process, we now *need to allocate new spaces* */</span>
	<span class="n">dst_p4d</span> <span class="o">=</span> <span class="n">p4d_alloc</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">dst_pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst_p4d</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">src_p4d</span> <span class="o">=</span> <span class="n">p4d_offset</span><span class="p">(</span><span class="n">src_pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
    <span class="cm">/* 3. loop over all the `p4d`s, and do the same for the *next level*, `pud` */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">p4d_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p4d_none_or_clear_bad</span><span class="p">(</span><span class="n">src_p4d</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_pud_range</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">src_mm</span><span class="p">,</span> <span class="n">dst_p4d</span><span class="p">,</span> <span class="n">src_p4d</span><span class="p">,</span>
						<span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">dst_p4d</span><span class="o">++</span><span class="p">,</span> <span class="n">src_p4d</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>                        </div>

                        <p>then this continues (essentially the same pattern) until <code class="language-plaintext highlighter-rouge">copy_pte_range()</code>, which is the <strong>bottom level of the page table</strong>, which finally <code class="language-plaintext highlighter-rouge">copy_one_pte()</code> for each:</p>

                        <ol>
                          <li>
                            <p>if it s a <code class="language-plaintext highlighter-rouge">cow_mapping</code>, then give a <strong>write protect</strong> to both <code class="language-plaintext highlighter-rouge">pte</code> entry we have <em>just created</em> and the one we are <em>copying from</em></p>

                            <ul>
                              <li><code class="language-plaintext highlighter-rouge">cow</code> stands for <strong>copy on write</strong></li>
                            </ul>
                          </li>
                          <li>
                            <p>get the <code class="language-plaintext highlighter-rouge">page</code> of the source’s underlying <code class="language-plaintext highlighter-rouge">pte</code></p>
                          </li>
                          <li>
                            <p>put the <em>address of that <code class="language-plaintext highlighter-rouge">page</code></em> into the <strong>target</strong> <code class="language-plaintext highlighter-rouge">pte</code> via <code class="language-plaintext highlighter-rouge">set_pte_at</code></p>

                            <ul>
                              <li>
                                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define set_pte_at(mm, addr, ptep, pte)	native_set_pte_at(mm, addr, ptep, pte)
</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_set_pte</span><span class="p">(</span><span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WRITE_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>                                </div>

                                <blockquote>
                                  <p><strong>Note</strong></p>

                                  <ul>
                                    <li>we see that we <strong><em>at the beginning</em></strong> are <strong>not copying the contents of the memory</strong>, but only <strong>copying the address of the <code class="language-plaintext highlighter-rouge">page</code></strong>, such that eventually the translation of an address of the <em>new process</em> will hit the same memory of the old process</li>
                                    <li>however, since the <code class="language-plaintext highlighter-rouge">fork()</code>ed process is independent of the parent, what happens is that only if <em>one of the two processes</em> are <strong>writing to the page table</strong>, we <strong>then copy the actual <code class="language-plaintext highlighter-rouge">page</code></strong> instead of just the addresses
                                      <ul>
                                        <li>this is also why we have set the <strong>write protect</strong> to <em>both pages</em> in step 1</li>
                                        <li>the actual <em>copying when a write error happened</em> is explained in <a href="#Access Error">Access Error</a></li>
                                      </ul>
                                    </li>
                                  </ul>
                                </blockquote>

                                <blockquote>
                                  <p><em>Reminder</em></p>

                                  <ul>
                                    <li>the <strong>smallest unit</strong> for kernel to allocate new memory is a <code class="language-plaintext highlighter-rouge">page</code>, i.e., when you do <code class="language-plaintext highlighter-rouge">malloc()</code>, you are basically creating <code class="language-plaintext highlighter-rouge">page</code>s</li>
                                  </ul>
                                </blockquote>
                              </li>
                            </ul>

                            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>
    <span class="nf">copy_one_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dst_mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">src_mm</span><span class="p">,</span>
                 <span class="n">pte_t</span> <span class="o">*</span><span class="n">dst_pte</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">src_pte</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
                 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rss</span><span class="p">)</span>
<span class="p">{</span>
                    
    <span class="cm">/* 1. if it s a `cow_mapping`, then give a **write protect** to both `pte` entry */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_cow_mapping</span><span class="p">(</span><span class="n">vm_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pte_write</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ptep_set_wrprotect</span><span class="p">(</span><span class="n">src_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">src_pte</span><span class="p">);</span>
        <span class="n">pte</span> <span class="o">=</span> <span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
    <span class="p">}</span>
                    
    <span class="cm">/*
	 * If it's a shared mapping, mark it clean in
	 * the child
	 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span>
        <span class="n">pte</span> <span class="o">=</span> <span class="n">pte_mkclean</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
    <span class="n">pte</span> <span class="o">=</span> <span class="n">pte_mkold</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
                    
    <span class="cm">/* 2. get the `page` of the source's underlying `pte` */</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
        <span class="n">page_dup_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="n">rss</span><span class="p">[</span><span class="n">mm_counter</span><span class="p">(</span><span class="n">page</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pte_devmap</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
    <span class="p">}</span>
                    
<span class="nl">out_set_pte:</span>
    <span class="cm">/*3. put the *address of that `page`* into the **target** `pte` via `set_pte_at`*/</span>
    <span class="n">set_pte_at</span><span class="p">(</span><span class="n">dst_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">dst_pte</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>                            </div>
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ul>

<h4 id="func-create_huge_pud"><code class="language-plaintext highlighter-rouge">func</code> create_huge_pud()</h4>

<blockquote>
  <p><strong>Huge Page</strong></p>

  <ul>
    <li>this is available on systems such as <code class="language-plaintext highlighter-rouge">x86</code>, where instead of a regular page <code class="language-plaintext highlighter-rouge">4K</code>, you can <strong>have a <code class="language-plaintext highlighter-rouge">2M</code> page.</strong>.</li>
    <li>therefore, instead of <code class="language-plaintext highlighter-rouge">pte</code> pointing to the <code class="language-plaintext highlighter-rouge">page</code>, we have the <strong><em>upper level</em> <code class="language-plaintext highlighter-rouge">pud</code> pointing to the page</strong></li>
  </ul>
</blockquote>

<p>This is used in <code class="language-plaintext highlighter-rouge">__handle_mm_fault</code></p>

<ol>
  <li>
    <p>if we wanted to create a huge page, go to <code class="language-plaintext highlighter-rouge">create_huge_pmd()</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">vm_fault_t</span> <span class="nf">__handle_mm_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
                                    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="o">*</span><span class="n">vmf</span><span class="p">.</span><span class="n">pmd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">__transparent_hugepage_enabled</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">create_huge_pmd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vmf</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_FALLBACK</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span> 
<span class="p">}</span>
</code></pre></div>    </div>

    <p>then <code class="language-plaintext highlighter-rouge">create_huge_pmd</code> does:</p>

    <ol>
      <li>in the end does <code class="language-plaintext highlighter-rouge">do_huge_pmd_anonymous_page()</code> and finally creates a new, huge page</li>
    </ol>
  </li>
</ol>

<h3 id="linux-page-replacement">Linux Page Replacement</h3>

<blockquote>
  <p><em>Reminder</em></p>

  <ul>
    <li>the execution of the below would be done by the <strong>process <code class="language-plaintext highlighter-rouge">kswapd</code></strong></li>
  </ul>
</blockquote>

<h4 id="buddy-algorithm-1">Buddy Algorithm</h4>

<p>In short, this is happening inside the call <code class="language-plaintext highlighter-rouge">alloc_pages()-&gt;alloc_pages_current(gfp_mask, order)</code></p>

<blockquote>
  <p><em>Reminder</em></p>

  <ul>
    <li>one use case of this would stem from <code class="language-plaintext highlighter-rouge">do_anonymous_page()</code>, which would be <strong>used</strong> when user needs some new physical memory allocated (after a page fault). Eventually, this function goes to <code class="language-plaintext highlighter-rouge">alloc_pages()</code>
      <ul>
        <li>in fact, the above would go to <code class="language-plaintext highlighter-rouge">alloc_pages_current(gfp_mask, 0)</code>with order of 0, meaning <strong>one page of allocation</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Some concepts to know beforehand:</p>

<blockquote>
  <p><strong>Memory Node and Zone</strong></p>

  <ul>
    <li>some terms you will see are <code class="language-plaintext highlighter-rouge">NUMA</code>, which means non-uniform memory access. This is the case for a <em>large computer architecture</em>, where there is some significant difference for a CPU to access a memory (close to it) and another memory (far away).
      <ul>
        <li>then a<code class="language-plaintext highlighter-rouge">node</code> which represent <strong>memory in a particular region</strong></li>
        <li>within a <code class="language-plaintext highlighter-rouge">node</code>, there are <code class="language-plaintext highlighter-rouge">zones</code> of memory
          <ul>
            <li>e.g. a zone could be the <code class="language-plaintext highlighter-rouge">DMA</code> (for <code class="language-plaintext highlighter-rouge">I/O</code>).</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Consider the function <code class="language-plaintext highlighter-rouge">alloc_pages_current()</code>, which eventually calls <code class="language-plaintext highlighter-rouge">__alloc_pages_nodemask()</code>, which does:</p>

<ol>
  <li>
    <p>gets the page <em>from the free list</em></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">__alloc_pages_nodemask</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">preferred_nid</span><span class="p">,</span>
							<span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_flags</span> <span class="o">=</span> <span class="n">ALLOC_WMARK_LOW</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">alloc_mask</span><span class="p">;</span> <span class="cm">/* The gfp_t that was actually used for allocation */</span>
	<span class="k">struct</span> <span class="n">alloc_context</span> <span class="n">ac</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>
   
	<span class="cm">/* some code omitted here */</span>
   
	<span class="cm">/* 1. gets the page *from the free list* */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">get_page_from_freelist</span><span class="p">(</span><span class="n">alloc_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ac</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>then inside the <code class="language-plaintext highlighter-rouge">get_page_from_freelist()</code>, we do:</p>

    <ol>
      <li>
        <p>actually getting the page via <code class="language-plaintext highlighter-rouge">rmqueue()</code></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * get_page_from_freelist goes through the zonelist trying to allocate
 * a page.
 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">get_page_from_freelist</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">struct</span> <span class="n">alloc_context</span> <span class="o">*</span><span class="n">ac</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 1. actually getting the page via `rmqueue()` */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">rmqueue_pcplist</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">,</span>
					<span class="n">migratetype</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
      
    <span class="cm">/* 2. if the order is not 0 */</span>
    <span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* some code omitted here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">__rmqueue</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">check_new_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <p>then in <code class="language-plaintext highlighter-rouge">rmqueue()</code>, we do:</p>

        <ol>
          <li>
            <p>if <code class="language-plaintext highlighter-rouge">order=0</code>, i.e. we need <strong>1 page</strong>, then <code class="language-plaintext highlighter-rouge">rmqueue_pcplist()</code></p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Allocate a page from the given zone. Use pcplists for order-0 allocations.
 */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">rmqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">preferred_zone</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
			<span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
         
    <span class="cm">/* some code omitted here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 1. if `order=0`, i.e. we need **1 page**, */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">rmqueue_pcplist</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">,</span>
					<span class="n">migratetype</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>            </div>

            <p>then in <code class="language-plaintext highlighter-rouge">rmqueue_pcplist()</code>, which does <code class="language-plaintext highlighter-rouge">__rmqueue_pcplist()</code>, which then does:</p>

            <ol>
              <li>
                <p>gets the page from a <code class="language-plaintext highlighter-rouge">list</code></p>
              </li>
              <li>
                <p>update the <code class="language-plaintext highlighter-rouge">pcp</code> count/number of available pages in that list</p>

                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">__rmqueue_pcplist</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">migratetype</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">per_cpu_pages</span> <span class="o">*</span><span class="n">pcp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* some code omitted here */</span>
		<span class="p">}</span>
            
        <span class="cm">/* 1. gets the page from a `list` */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
        <span class="cm">/* update the `pcp` count/number of available pages in that list */</span>
		<span class="n">pcp</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">check_new_pcp</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
            
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>                </div>
              </li>
            </ol>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * get_page_from_freelist goes through the zonelist trying to allocate
 * a page.
 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="nf">get_page_from_freelist</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">,</span>
						<span class="k">const</span> <span class="k">struct</span> <span class="n">alloc_context</span> <span class="o">*</span><span class="n">ac</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 1. actually getting the page via `rmqueue()` */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">rmqueue_pcplist</span><span class="p">(</span><span class="n">preferred_zone</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">,</span>
					<span class="n">migratetype</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
         
    <span class="cm">/* 2. if the order is not 0 */</span>
    <span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* some code omitted here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">__rmqueue</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">check_new_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>if <code class="language-plaintext highlighter-rouge">order</code> is not <code class="language-plaintext highlighter-rouge">0</code>, then in the <strong>more general</strong> case, it calls <code class="language-plaintext highlighter-rouge">__rm_queue()</code>, which does a <code class="language-plaintext highlighter-rouge">__rmqueue_smallest()</code>, which then does:</p>

            <ol>
              <li>
                <p>find the appropriate <code class="language-plaintext highlighter-rouge">zone</code> in the memory to have this data stored</p>
              </li>
              <li>
                <p>start from the size of <code class="language-plaintext highlighter-rouge">current_order</code>, and try to get a <code class="language-plaintext highlighter-rouge">page</code> there</p>

                <ul>
                  <li>if not, it goes to the <code class="language-plaintext highlighter-rouge">next_order</code> of body list</li>
                  <li>note that you are just obtaining the <strong>first page of the contiguous pages</strong>. e.g. If you needed $2^2$ pages, then this would return you the <strong>first page of the four pages</strong></li>
                </ul>
              </li>
              <li>
                <p>once obtained the page, delete it from the list</p>

                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Go through the free lists for the given migratetype and remove
 * the smallest available page from the freelists
 */</span>
<span class="k">static</span> <span class="n">__always_inline</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">__rmqueue_smallest</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_order</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">free_area</span> <span class="o">*</span><span class="n">area</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
            
	<span class="cm">/* 2. start from the size of `current_order`, and try to get a `page` there */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">current_order</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span> <span class="n">current_order</span> <span class="o">&lt;</span> <span class="n">MAX_ORDER</span><span class="p">;</span> <span class="o">++</span><span class="n">current_order</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 1. find the appropriate `zone` in the memory to have this data stored */</span>
		<span class="n">area</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">current_order</span><span class="p">]);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">get_page_from_free_area</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
        <span class="cm">/* 3. once obtained the page, delete it from the list */</span>
		<span class="n">del_page_from_free_area</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>
        <span class="cm">/* 4. afterwards, **expand/merge** the pages in the rest of the buddy list */</span>
		<span class="n">expand</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">current_order</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
		<span class="n">set_pcppage_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>
            
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>                </div>

                <p>then inside <code class="language-plaintext highlighter-rouge">get_page_from_free_area()</code>, we just have:</p>

                <ol>
                  <li>
                    <p>get the <code class="language-plaintext highlighter-rouge">struct page</code> from the list (<em>does not <code class="language-plaintext highlighter-rouge">list_del</code></em>)</p>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">get_page_from_free_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">free_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_first_entry_or_null</span><span class="p">(</span><span class="o">&amp;</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">[</span><span class="n">migratetype</span><span class="p">],</span>
					<span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>                    </div>
                  </li>
                </ol>
              </li>
              <li>
                <p>afterwards, <strong>expand/merge</strong> the pages in the rest of the buddy list</p>

                <p>inside <code class="language-plaintext highlighter-rouge">expand()</code>, we are doing:</p>

                <ol>
                  <li>
                    <p>if <code class="language-plaintext highlighter-rouge">low</code>=the #pages we needed $&lt;$ <code class="language-plaintext highlighter-rouge">high</code>=order of page in the region</p>
                  </li>
                  <li>
                    <p>we want to <strong>merge the unused parts</strong> in this region back to <em>other lists of smaller order</em></p>

                    <ul>
                      <li>e.g. if we needed <code class="language-plaintext highlighter-rouge">2^0</code>, but we are at <code class="language-plaintext highlighter-rouge">2^2</code>, then 1 page of size=order=1 will be placed back, and 1 page of order=size 2 will be placed back</li>
                    </ul>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">expand</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">,</span> <span class="k">struct</span> <span class="n">free_area</span> <span class="o">*</span><span class="n">area</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">high</span><span class="p">;</span>
               
    <span class="cm">/* 1. if `low`=the #pages we needed $&lt;$ `high`=order of page in the region */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">high</span> <span class="o">&gt;</span> <span class="n">low</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">area</span><span class="o">--</span><span class="p">;</span>
		<span class="n">high</span><span class="o">--</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
               		
        <span class="cm">/* some code omitted here */</span>
               
        <span class="cm">/* 2. we want to **merge the unused parts** in this region back to *other lists of smaller order* */</span>
		<span class="n">add_to_free_area</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="n">area</span><span class="p">,</span> <span class="n">migratetype</span><span class="p">);</span>
		<span class="n">set_page_order</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">[</span><span class="n">size</span><span class="p">],</span> <span class="n">high</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>                    </div>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h4 id="translations-between-different-structs">translations between different structs</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">page_to_pfn</code> This is useful if we want to **translate from a page to a physical frame number **(there is also the reverse)</li>
  <li><code class="language-plaintext highlighter-rouge">page_to_phys</code> this translates from a <strong>page to physical address</strong> (there is also the reverse)</li>
  <li><code class="language-plaintext highlighter-rouge">page_to_virt</code> this translates from a <strong>page to a virtual address</strong> (there is also the reverse)
    <ul>
      <li>for example, if you want to read the data in the actual page, you could <em>first translate the page to virtual address</em>, and then <em>read it from the pointer</em></li>
    </ul>
  </li>
</ul>

<h4 id="func-dup_task_struct"><code class="language-plaintext highlighter-rouge">func</code> dup_task_struct</h4>

<p>This is used for illustrating the use of a <strong>slab allocator and a page cache</strong> in kernel, so that every time a new process is coming out, we would have the <em>memory needed cached already</em></p>

<p>This example starts from <code class="language-plaintext highlighter-rouge">dup_task_struct()</code>, which goes <code class="language-plaintext highlighter-rouge">alloc_task_struct_node(node)</code></p>

<ul>
  <li>
    <p>which in turns goes to <code class="language-plaintext highlighter-rouge">kmem_cache_alloc_node();</code>, which is going to <strong>get the memory of size <code class="language-plaintext highlighter-rouge">struct task_struct</code> from cache</strong>,</p>

    <ul>
      <li>
        <p>which then goes to:<code class="language-plaintext highlighter-rouge">kmem_cache_alloc(s, flags);</code></p>

        <ul>
          <li>
            <p>which then goes to <code class="language-plaintext highlighter-rouge">slab_alloc()</code></p>

            <ul>
              <li>
                <p>which then essentially does <code class="language-plaintext highlighter-rouge">objp = __do_cache_alloc(cachep, flags);</code></p>

                <ul>
                  <li>
                    <p>which does <code class="language-plaintext highlighter-rouge">____cache_alloc(cache, flags);</code></p>

                    <ol>
                      <li>
                        <p>gets the <code class="language-plaintext highlighter-rouge">array_cache</code> which represents an <strong>array of caches</strong></p>

                        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">array_cache</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">avail</span><span class="p">;</span> <span class="cm">/* NUMBER of available units/entries */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">batchcount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">touched</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">entry</span><span class="p">[];</span>
<span class="p">};</span>
</code></pre></div>                        </div>
                      </li>
                      <li>
                        <p>check if there it is available = has at least one not used unit inside</p>
                      </li>
                      <li>
                        <p>if yes, gets that memory, decrease the <code class="language-plaintext highlighter-rouge">avail</code>, and done</p>
                      </li>
                      <li>
                        <p>if not, I need to <em>refill the cache with memory</em> by <code class="language-plaintext highlighter-rouge">cache_alloc_refill()</code></p>

                        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">____cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">;</span>
             
	<span class="n">check_irq_off</span><span class="p">();</span>
             
    <span class="cm">/* 1. gets the `array_cache` */</span>
	<span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
    <span class="cm">/* 2. check if there it is available = has at least one not used unit inside */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ac</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="cm">/* 3. if yes, gets that memory, decrease the `avail`, and done */</span>
		<span class="n">objp</span> <span class="o">=</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="o">--</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">];</span>
             
		<span class="n">STATS_INC_ALLOCHIT</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
             
	<span class="cm">/* 4. if not, I need to *refill the cache with memory* by `cache_alloc_refill()` */</span>
	<span class="n">objp</span> <span class="o">=</span> <span class="n">cache_alloc_refill</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* some code omitted here */</span>
	<span class="k">return</span> <span class="n">objp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>                        </div>

                        <p>then in <code class="language-plaintext highlighter-rouge">cache_alloc_refill()</code>, which goes to</p>

                        <ul>
                          <li><code class="language-plaintext highlighter-rouge">cahce_grow_begin()</code>, which then goes to:
                            <ul>
                              <li><code class="language-plaintext highlighter-rouge">kmem_getpages()</code>, which finally goes to
                                <ul>
                                  <li><code class="language-plaintext highlighter-rouge">__alloc_pages_node()</code> which does <code class="language-plaintext highlighter-rouge">__alloc_pages()</code>, back to the path of actually <strong>allocating pages in the buddy allocator</strong></li>
                                </ul>
                              </li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                    </ol>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>if you free, then it will just put the memory <em>back to the slab</em>, and then <em>increment the <code class="language-plaintext highlighter-rouge">avail</code></em></li>
  </ul>
</blockquote>

<h4 id="func-__do_kmalloc"><code class="language-plaintext highlighter-rouge">func</code> __do_kmalloc</h4>

<p>This is the path eventually from calling <code class="language-plaintext highlighter-rouge">kmalloc()</code>, which you will soon see that it <strong>also uses the page cache and the slab allocator</strong></p>

<p>Starting with <code class="language-plaintext highlighter-rouge">__do_kmalloc()</code>, it goes to:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">kmalloc_slab()</code>, which <em>gets the <code class="language-plaintext highlighter-rouge">kmalloc_caches</code></em></p>
  </li>
  <li>
    <p>then, we use the <code class="language-plaintext highlighter-rouge">cache</code> and call <code class="language-plaintext highlighter-rouge">slab_alloc()</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__do_kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
   
    <span class="cm">/* 1. `kmalloc_slab()`, which *gets the `kmalloc_caches`* */</span>
	<span class="n">cachep</span> <span class="o">=</span> <span class="n">kmalloc_slab</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">cachep</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">cachep</span><span class="p">;</span>
    <span class="cm">/* 2. use the `cache` and call `slab_alloc()` */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">slab_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">caller</span><span class="p">);</span>
   
	<span class="cm">/* some code omitted here */</span>
   
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>then, <code class="language-plaintext highlighter-rouge">slab_alloc()</code> calls:</p>

    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">__do_cache_alloc()</code>, which then calls</p>

        <ul>
          <li>
            <p><code class="language-plaintext highlighter-rouge">___cache_alloc()</code>, which is the same as above, where it:</p>

            <ol>
              <li>
                <p>checks if there is some <em>available</em> memory in the cache</p>
              </li>
              <li>
                <p>if yes, gives you that and decrease <code class="language-plaintext highlighter-rouge">avail</code></p>

                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">____cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">;</span>
              
	<span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
    <span class="cm">/* 1. checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ac</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="cm">/* 2. gets the cached memory */</span>
		<span class="n">objp</span> <span class="o">=</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="o">--</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">];</span>
          
		<span class="n">STATS_INC_ALLOCHIT</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
          
	<span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>                </div>
              </li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h1 id="week-8---10---file-system">Week 8 - 10 - File System</h1>

<p>Basically <strong>file</strong> is an abstraction of a persistent, <strong>non-volatile storage</strong> of information</p>

<ul>
  <li>the opposite would be <em>processes. which are gone when powered off</em></li>
</ul>

<p>Some file systems FS include:</p>

<ul>
  <li><strong>Disk</strong> Based FS
    <ul>
      <li>persists even when you reboot</li>
      <li>needs to deal with <em>both in-memory representation and disk representation</em>. Because when you use it, it <em>first gets loaded into memory</em>, and when you write to it, it first <em>write to memory</em> and <strong>then writes/syncs to the disk</strong></li>
    </ul>
  </li>
  <li><strong>In-Memory</strong> FS
    <ul>
      <li>when you power off, they are gone.</li>
      <li>e.g. for some system <code class="language-plaintext highlighter-rouge">/tmp</code></li>
    </ul>
  </li>
</ul>

<h2 id="virtual-file-system">Virtual File System</h2>

<blockquote>
  <p>==Some Useful References:==</p>

  <ul>
    <li>https://www.kernel.org/doc/html/latest/filesystems/index.html</li>
  </ul>
</blockquote>

<p>To support all the different file systems, there is a <strong>common abstraction</strong> called the <strong>virtual file system</strong></p>

<ul>
  <li>i.e. provides API for different implementations of FS</li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>in a sense, this will be similar to the Linux <strong>scheduler</strong>, in the sense that:
      <ul>
        <li>when you call a generic <code class="language-plaintext highlighter-rouge">read()</code>, it will go to <code class="language-plaintext highlighter-rouge">vsf_read()</code>, which then calls the <em>file system specific <code class="language-plaintext highlighter-rouge">read()</code></em></li>
        <li>just like scheduler calling the <em>scheduling class specific <code class="language-plaintext highlighter-rouge">pick_next_task()</code></em></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>This section therefore talks about:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">read()</code></li>
  <li><code class="language-plaintext highlighter-rouge">write()</code></li>
  <li><code class="language-plaintext highlighter-rouge">open()</code></li>
  <li><code class="language-plaintext highlighter-rouge">close()</code></li>
  <li><code class="language-plaintext highlighter-rouge">mount()</code> - mounting File System for a directory of files</li>
</ul>

<h3 id="objects-in-vfs">Objects in VFS</h3>

<p>Below are some main <strong>objects</strong> that Linux keeps track of.</p>

<ul>
  <li><strong>Super Block</strong> - metadata/info for a <em>mounted file system</em>
    <ul>
      <li>i.e. all file systems will have a super block</li>
      <li>both in memory and also has a Disk Version</li>
    </ul>
  </li>
  <li><strong>inode</strong> - index node, metadata for an actual <em>file</em>
    <ul>
      <li>both in-memory and also has a Disk Version</li>
    </ul>
  </li>
  <li><strong>file struct</strong> - interaction of a process with an opened file
    <ul>
      <li>i.e. the <code class="language-plaintext highlighter-rouge">FILE *</code> that you see in C, or basically file descriptors</li>
      <li>no Disk Version, <em>only represented in memory</em></li>
    </ul>
  </li>
  <li><strong>d-entry</strong> - <em>directory</em> entry linked between a <em>file name</em> and a <em><code class="language-plaintext highlighter-rouge">inode</code></em>
    <ul>
      <li>e.g. file name could be <code class="language-plaintext highlighter-rouge">hello/foo.txt</code>, and if you have made some <code class="language-plaintext highlighter-rouge">links</code> in your FS, then you will have <em>two different file name</em>, but <em>pointing to the same <code class="language-plaintext highlighter-rouge">inode</code></em></li>
      <li>this is typically <em>cached</em>, as directory navigation happens often</li>
      <li><code class="language-plaintext highlighter-rouge">dentry</code> is are all components in a path, including files.
        <ul>
          <li>e.g. <code class="language-plaintext highlighter-rouge">/bin/vi</code> has <code class="language-plaintext highlighter-rouge">dentry</code> object of <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">bin</code>, and <code class="language-plaintext highlighter-rouge">vi</code>, <em>even if <code class="language-plaintext highlighter-rouge">vi</code> is a regular file</em></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Similarly, a <em>process keeps track of</em>:</p>

<ul>
  <li><strong>file table</strong> - an array of file descriptors/<code class="language-plaintext highlighter-rouge">fd</code> array
    <ul>
      <li>from that <code class="language-plaintext highlighter-rouge">fd</code>, you will have the <strong>file object -&gt; d-entry -&gt; inode &amp; super block</strong> and actually <em>access your file data &amp; fie system related info</em></li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Relationship between <code class="language-plaintext highlighter-rouge">superblock</code>/<code class="language-plaintext highlighter-rouge">inode</code>/<code class="language-plaintext highlighter-rouge">dentry</code></strong></p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">superblock</code> contains information on which valid <code class="language-plaintext highlighter-rouge">inode</code>s we are using</li>
    <li>each <code class="language-plaintext highlighter-rouge">inode</code> contains data for a specific file/directory
      <ul>
        <li>for example, stored in the inode are the attributes of the file or directory: permissions, owner, group, size, access/modify times, etc.</li>
      </ul>
    </li>
    <li>VFS often needs to perform directory-specific operations, such as path name lookup. Path name lookup involves translating <strong>each component of a path, including the file</strong>
      <ul>
        <li>for example. <code class="language-plaintext highlighter-rouge">/bin/vi</code>, where <code class="language-plaintext highlighter-rouge">vi</code> is the file, then you need to <em>first perform a pathname look up</em></li>
        <li>therefore, this is the <strong>use of a <code class="language-plaintext highlighter-rouge">dentry</code> object</strong>, <code class="language-plaintext highlighter-rouge">dentry</code> is a specific component in a path. Using the previous example, <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">bin</code>, and <code class="language-plaintext highlighter-rouge">vi</code> are all <code class="language-plaintext highlighter-rouge">dentry</code> objects.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>the actual implementation of the above is in the directory <code class="language-plaintext highlighter-rouge">/fs</code> in kernel code</li>
  </ul>
</blockquote>

<h3 id="zero-page">Zero Page</h3>

<p>If you need the <strong>returned page filled with zeros</strong>, use the function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">get_zeroed_page</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gfp_mask</span><span class="p">)</span>
</code></pre></div></div>

<p>This function works the same as <code class="language-plaintext highlighter-rouge">__get_free_page()</code>, except that:</p>

<ul>
  <li>the allocated page is then zero-filled—every bit of every byte is unset.</li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>This is useful for pages given to userspace because the <strong>random garbage in an allocated page</strong> is not so random; it <strong>might contain sensitive data</strong>. All data must be zeroed or otherwise cleaned before it is returned to userspace to ensure system security is not compromised.</li>
  </ul>
</blockquote>

<h2 id="disk-and-disk-io">Disk and Disk I/O</h2>

<p>On a large picture, we are dealing with:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-06_15-07-03.png" style="zoom: 50%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p>CPU gets data from RAM, which is stored in terms of <strong>frames/pages</strong></p>
  </li>
  <li>if we want to do a <code class="language-plaintext highlighter-rouge">read()</code> from <strong>disk</strong>, it will <em>first look at the Page Cache</em> <strong>in RAM</strong> (because access from disk is slow)</li>
  <li>when we do a <code class="language-plaintext highlighter-rouge">write()</code> to <strong>disk</strong>, it will also write to <em>Page Cache</em> <strong>in RAM</strong>, and some time later, writes are sent to disk together</li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>
      <p>since we are writing to <em>Page Cache</em>  before actually to disk, this means that ==abnormally shutting your system down== could lead to some data missing because they are <strong>not yet flushed to disk from RAM</strong></p>
    </li>
    <li>
      <p>Therefore, there are usually <strong>system threads</strong> that periodically do those flushes. So if you do a <em>proper shutdown</em>, those threads would be waken up and flush things to disk.</p>

      <p>In fact:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirty_writeback_interval</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span> <span class="cm">/* centiseconds */</span>
</code></pre></div>      </div>

      <p>which mean basically <strong>every 5 seconds</strong>, and that:</p>

      <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">dirty_writeback_centisecs_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
                                      <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_interval</span> <span class="o">=</span> <span class="n">dirty_writeback_interval</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    
    <span class="n">ret</span> <span class="o">=</span> <span class="n">proc_dointvec</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
    
    <span class="cm">/*
	 * Writing 0 to dirty_writeback_interval will disable periodic writeback
	 * and a different non-zero value will wakeup the writeback threads.
	 * wb_wakeup_delayed() would be more appropriate, but it's a pain to
	 * iterate over all bdis and wbs.
	 * The reason we do this is to make the change take effect immediately.
	 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">dirty_writeback_interval</span> <span class="o">&amp;&amp;</span>
        <span class="n">dirty_writeback_interval</span> <span class="o">!=</span> <span class="n">old_interval</span><span class="p">)</span>
        <span class="n">wakeup_flusher_threads</span><span class="p">(</span><span class="n">WB_REASON_PERIODIC</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>      </div>
    </li>
  </ul>

</blockquote>

<h3 id="hard-disk-mechanics">Hard Disk Mechanics</h3>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-06_15-18-03.png" style="zoom: 67%;" /></p>

<p>where some components include:</p>

<ul>
  <li>a <strong>disk arm</strong> that slides back and forth to <strong>read data from disk</strong>
    <ul>
      <li>this is known as ==disk seek==</li>
      <li>since it is mechanical, this is slow</li>
    </ul>
  </li>
  <li>a <strong>track</strong> is the circular part, and it has many <strong>sectors</strong>
    <ul>
      <li>sector is the minimal unit of a hard disk. Each sector stores a fixed amount of user-accessible data, traditionally 512 bytes for hard disk drives.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>this is the normal hard disk drive, also called <strong>HDD</strong>.</li>
    <li>modern <strong>SSD</strong> would be having a different design, i.e. using <strong>flash</strong>, which turns out to be much <em>faster than the normal hard disk</em></li>
  </ul>
</blockquote>

<h3 id="io-request">I/O Request</h3>

<p>When you do a <code class="language-plaintext highlighter-rouge">read()</code> or <code class="language-plaintext highlighter-rouge">write()</code>, if you needed something from the <strong>disk</strong>, Linux will do it by ==submitting an I/O Request==</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-08_14-16-32.png" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>we do this because I/O from disks are usually slow, as the mechanism is purely <strong>mechanical</strong> (disk arm)
    <ul>
      <li>this also means that, as <code class="language-plaintext highlighter-rouge">write()</code> usually first goes to the Cache in RAM, <code class="language-plaintext highlighter-rouge">read()</code> might be <em>slower than <code class="language-plaintext highlighter-rouge">write()</code></em> because it might need to go to the Disk</li>
    </ul>
  </li>
  <li>we want to <strong>optimize</strong> it by possibly <em>merging requests</em> and <em>attempt to maximize data locality</em>
    <ul>
      <li>==merge the requests== if possible
        <ul>
          <li>if the contents to be read is contiguous for two requests</li>
        </ul>
      </li>
      <li>if not, ==sort the requests==
        <ul>
          <li>if the contents to be read is close to each other but not contiguous, <strong>put/sort  the two requests close to each other</strong> (so I can handle nearby requests)</li>
          <li>then, you also have to solve the problem of ==starvation==</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Therefore</strong>, again we need some sort of “scheduling” policies for those requests.</p>

  <ul>
    <li>the main reason is that hard disk <em>seeks</em> are expensive</li>
  </ul>
</blockquote>

<h4 id="deadline-elevator-io-scheduling">Deadline Elevator I/O Scheduling</h4>

<blockquote>
  <p><strong>Deadline Elevator</strong></p>

  <ul>
    <li>
      <p>An overall <strong>sorted queue</strong> in block order (data block to be read would be next to each other)</p>
    </li>
    <li>
      <p>Distinguishes between <em>read and write</em> requests, by having a separate <strong>read queue</strong> and a <strong>write queue</strong></p>

      <ul>
        <li>
          <p>the requests in those two queues are ==pulled from the sorted queue==</p>
        </li>
        <li>
          <p>requests on those two queue are <strong>ordered by their deadlines</strong></p>
        </li>
        <li>
          <p>deadline is computed from $\text{submission time}+\Delta$. Some example $\Delta$ values are:</p>

          <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-08_14-26-13.png" alt="" /></p>

          <p>where we are basically dealing with <code class="language-plaintext highlighter-rouge">read()</code> more often, because they are the <em>time consuming ones</em> that would <em>block the program</em></p>
        </li>
      </ul>
    </li>
    <li>
      <p>If the <em>deadline</em> of a request in either the read queue or the write queue has <em>expired</em></p>

      <ul>
        <li>then the read queue or write queue would <strong>pull those requests in</strong> instead of pulling from the sorted queue</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Therefore, the above mechanism makes sure that:</p>

<ul>
  <li>the problem of <strong>starvation</strong> is solved (by deadlines and pulling from expired deadlines)</li>
</ul>

<p>However, the satisfice is:</p>

<ul>
  <li>if there are expired requests, you would end up having <strong>disk arm jumping again</strong>, since they are not in block order. Once those requests are done, the <strong>disk arm needs to jump back</strong> to serve those ordered requests</li>
</ul>

<h4 id="anticipatory-io-scheduling">Anticipatory I/O Scheduling</h4>

<blockquote>
  <p><strong>Anticipatory I/O Scheduling</strong></p>

  <ul>
    <li>requests are sorted by <strong>deadline + anticipation</strong>
      <ul>
        <li>this is to solve the problem of <em>disk arm jumping back and forth</em></li>
        <li>after jumped and <strong>before going back to pull from sorted queue</strong>, check if there are some nearby block requests and <strong>service those</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="cfq-elevator-io-scheduling">CFQ Elevator I/O Scheduling</h4>

<blockquote>
  <p><strong>Completely Fair Queue</strong></p>

  <ul>
    <li>
      <p>maintains a <strong>request queue per process</strong></p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-08_14-44-02.png" alt="" /></p>
    </li>
    <li>
      <p>maintains an <strong>overall round-robin request queue</strong></p>

      <ul>
        <li>which pulls I/O request from process request queues in a round-robin way</li>
        <li>there could be some level of <em>sorting done here</em></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Eventually, this is dealing with:</p>

<ul>
  <li>some processes are generating too much I/Os, being unfair to other processes</li>
</ul>

<h3 id="solid-state-disk-mechanis">Solid State Disk Mechanis</h3>

<p>The difference with HDD is that:</p>

<ul>
  <li>there is <strong>no disk arm</strong></li>
  <li>all made from using solid state/using electrons</li>
  <li>much faster than HDD:
    <ul>
      <li>SSD in magnitude of $10\mu s$ and HDD in magnitude of $10ms$</li>
      <li>RAM is in magnitude of $10ns$</li>
    </ul>
  </li>
</ul>

<p>Therefore:</p>

<ul>
  <li>a <strong>random access</strong> (jumping to a block position) has speed $\approx$ a sequential access</li>
</ul>

<blockquote>
  <p><strong>Therefore</strong></p>

  <ul>
    <li>we don’t need to worry about <em>disk seeks</em>, i.e. attempting to order request by locality</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Problem</strong></p>

  <ul>
    <li>
      <p>the problem is now that, since I/O are <em>faster</em> with SSD, and we only had a <strong>single shared I/O queue</strong>, we need to face the problem of <strong>much time spending on lock contention</strong></p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-08_15-03-13.png" style="zoom: 33%;" /></p>

      <p>where:</p>

      <ul>
        <li>before with HDD, we can’t serve that much requests anyway, so this is a smaller problem</li>
        <li>now it becomes a <strong>similar problem as process scheduling</strong></li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Therefore, the natural solution (e.g. from process scheduling) is to have <strong>private I/O queues per CPU</strong></p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-08_14-59-46.png" style="zoom:50%;" /></p>

<p>which is now <strong>an OK approach because</strong></p>

<ul>
  <li>
    <p>lock contention is solved</p>
  </li>
  <li>
    <p>every time we pull from each CPU’s queue $\to$ no more <em>block ordering</em> for requests $\to$ doesn’t matter much since <strong>random access in SSD</strong> is about as fast as sequential access anyway</p>
  </li>
</ul>

<h2 id="data-organization-on-hdd">Data Organization on HDD</h2>

<blockquote>
  <p><strong>Logical Disk Block</strong></p>

  <ul>
    <li>The one-dimensional array of logical blocks is <strong>mapped</strong> onto the sectors of the <strong>disk</strong> <strong><em>sequentially</em></strong>. Sector 0 is the first sector of the first track on the outermost cylinder, etc,</li>
    <li>By using this mapping, we can—at least in theory—convert a logical block number into an old-style disk address that consists of a cylinder number, a track number within that cylinder, and a sector number within that track.</li>
  </ul>
</blockquote>

<p>Much of the illustration below will use a <strong>logical disk block</strong>.</p>

<blockquote>
  <p><strong>Physical Disk Block</strong></p>

  <ul>
    <li>Physical addressing gets into the nitty gritty of how the data is physically stored in the device, so it’s dependent on the physical attributes of the device. Spinning disk hard drives have to understand where on a <em>platter</em> to retrieve data, where as solid state hard drives deal with <em>chips</em>, tape drives have their own encoding for <em>distance</em> and <em>position</em>, etc.</li>
  </ul>
</blockquote>

<p>Consider a file:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-08_15-17-24.png" style="zoom: 67%;" /></p>

<p>Some ways to store data on disk that ==does not work== are</p>

<ul>
  <li>allocate a contiguous block for file data $\iff$ doesn’t work since size might change (e.g. append stuff)</li>
  <li>each block <em>stores a pointer linked to the next block <strong>of the file</strong></em> $\iff$ doesn’t work since losing one block would <em>lose the entire file</em></li>
</ul>

<h3 id="file-allocation-table">File Allocation Table</h3>

<blockquote>
  <p><strong>FAT</strong></p>

  <ul>
    <li>
      <p>Instead of having the <em>linked list</em> in each block, keep a <strong>global table that stores all links</strong></p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-08_15-24-13.png" style="zoom:50%;" /></p>

      <p>where:</p>

      <ul>
        <li>this <strong>was</strong> used by the Windows system</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Now, the problem becomes:</p>

<ul>
  <li><strong>losing FAT</strong> loses all information</li>
</ul>

<p>However, this turns out to be a good idea because:</p>

<ul>
  <li><strong>centralized important information</strong> $\to$ RAM can keep a copy of this in ==Cache== $\to$ RAM knows <em>block addresses in advance</em></li>
</ul>

<h3 id="index-node">Index Node</h3>

<blockquote>
  <p><strong>inode</strong></p>

  <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-08_15-47-41.png" style="zoom: 67%;" /></p>

  <ul>
    <li>For each file, we have an <strong>inode</strong>, which contains <strong>many entries</strong>
      <ul>
        <li>each entry points to a block of data <strong>on disk</strong></li>
        <li>all the “links” of a file is stored in the inode</li>
      </ul>
    </li>
    <li>then to keep a large amount of data, we use <strong>indirect blocks</strong> (on disk)
      <ul>
        <li>an entry could point to an indirect block on disk</li>
        <li>an indirect block contains “links” to the next level/actual <strong>disk blocks</strong></li>
      </ul>
    </li>
    <li>therefore you can have <strong>multilevel indirect blocks</strong>
      <ul>
        <li>single level indirect contains entries pointing to a <em>disk block</em></li>
        <li>second level indirect contains entries pointing to the next level <em>indirect</em></li>
        <li>etc.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>Everything in a Unix file system has a unique <code class="language-plaintext highlighter-rouge">inode</code> number per <strong>file system</strong> that manages the storage and attributes for that thing: every file, directory, special file, etc.
      <ul>
        <li>2 files can have the same inode, but only if they are part of different file system. On each file system, <strong>there is a <code class="language-plaintext highlighter-rouge">superblock</code> that tells the system which <code class="language-plaintext highlighter-rouge">inode</code>s are used, which are free</strong></li>
      </ul>
    </li>
    <li><strong>Files and directories</strong> are both managed with <code class="language-plaintext highlighter-rouge">inode</code>s.</li>
  </ul>
</blockquote>

<p>This implies that:</p>

<ul>
  <li>the multilevel indirection then basically looks like a page walk $\to$ access might be <strong>slower for large files</strong></li>
</ul>

<blockquote>
  <p><strong>Relationship between <code class="language-plaintext highlighter-rouge">superblock</code>/<code class="language-plaintext highlighter-rouge">inode</code>/<code class="language-plaintext highlighter-rouge">dentry</code></strong></p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">superblock</code> contains information on which valid <code class="language-plaintext highlighter-rouge">inode</code>s we are using</li>
    <li>each <code class="language-plaintext highlighter-rouge">inode</code> contains data for a specific file/directory</li>
    <li>VFS often needs to perform directory-specific operations, such as path name lookup. Path name lookup involves translating <strong>each component of a path, including the file</strong>
      <ul>
        <li>for example. <code class="language-plaintext highlighter-rouge">/bin/vi</code>, where <code class="language-plaintext highlighter-rouge">vi</code> is the file, then you need to <em>first perform a pathname look up</em></li>
        <li>therefore, this is the <strong>use of a <code class="language-plaintext highlighter-rouge">dentry</code> object</strong>, <code class="language-plaintext highlighter-rouge">dentry</code> is a specific component in a path. Using the previous example, <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">bin</code>, and <code class="language-plaintext highlighter-rouge">vi</code> are all <code class="language-plaintext highlighter-rouge">dentry</code> objects.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="examples-of-unix-file-systems">Examples of Unix File Systems</h3>

<p><u>*For Example: S5 File System*</u></p>

<p>This is the initial Linux File System, S5FS.</p>

<p>Usually, this is <strong>how it looks like on Disk</strong></p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-08_16-02-49.png" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>some space will be left for <code class="language-plaintext highlighter-rouge">superblock</code> and <code class="language-plaintext highlighter-rouge">inodes</code>
    <ul>
      <li>the <code class="language-plaintext highlighter-rouge">superblock</code> here would tell you information such as the start/end of the <code class="language-plaintext highlighter-rouge">inode</code>s, etc.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">boot</code> block tells us how we boot this <strong>disk</strong></li>
</ul>

<blockquote>
  <p><strong>Problem</strong></p>

  <ul>
    <li>now, the most important information is the <code class="language-plaintext highlighter-rouge">superblock</code>. So if you lose it, you lose everything.</li>
  </ul>
</blockquote>

<hr />

<p><em><u>For Example: Fast FS</u></em></p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-08_16-12-05.png" style="zoom:50%;" /></p>

<p>where:</p>

<ul>
  <li>each <strong>group</strong> contains:
    <ul>
      <li>a <strong>copy</strong> of the <code class="language-plaintext highlighter-rouge">superblock</code></li>
      <li>the <code class="language-plaintext highlighter-rouge">inode</code></li>
      <li>the <code class="language-plaintext highlighter-rouge">data blocks</code></li>
    </ul>
  </li>
</ul>

<p>This also has a <strong>performance boost</strong> since:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-08_16-11-05.png" style="zoom: 33%;" /></p>

<p>where:</p>

<ul>
  <li>
    <p>while the disk spins, it can read <strong>a cylinder of data</strong> without disk arm moving</p>
  </li>
  <li>
    <p>each <strong>group maps to a cylinder in disk</strong></p>
    <ul>
      <li>therefore, this is <em>locality</em> $\to$ fast</li>
    </ul>
  </li>
</ul>

<hr />

<p><em><u>For Example: EXT3/4</u></em></p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-09_00-25-00.png" style="zoom:33%;" /></p>

<p>where:</p>

<ul>
  <li>now the problem is we need <strong>three operations to update when a file is created</strong>, but only one write is <strong>atomic</strong></li>
  <li>this <em>was</em> “remedied” by a <strong>File System Checker FSCK</strong> for a while (in <code class="language-plaintext highlighter-rouge">EXT2</code>), but as Disks are larger, this is too <strong>slow</strong></li>
</ul>

<p>This problem of checking if ==updates are consistent in Disk== is solved by using a journal.</p>

<h3 id="journaling">Journaling</h3>

<p>This is to solve the file system <strong>consistency</strong> problem, which is necessary since, e.g. creating a file means (not in order):</p>

<ul>
  <li>update <code class="language-plaintext highlighter-rouge">inode</code> bitmap</li>
  <li>update <code class="language-plaintext highlighter-rouge">inode</code></li>
  <li>update <code class="language-plaintext highlighter-rouge">dentry</code> of parent</li>
</ul>

<p>So we need consistency of ==all== of them somehow updated, or ==none== of them happened.</p>

<blockquote>
  <p><strong>Journaling</strong></p>

  <ul>
    <li>
      <p>Journaling filesystems write <strong>metadata</strong> (i.e., data about files and directories) into the <strong>journal</strong>/log that is flushed to the HDD before each command returns. When the update is done, a <strong>commit</strong> will be made.</p>
    </li>
    <li>
      <p>if there is a corruption/pressed power off without syncing, then we would:</p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-09_00-42-37.png" style="zoom:67%;" /></p>

      <ol>
        <li>go to the last <em>commit</em></li>
        <li>check the data in journal before that last commit, if they are in sync with disk
          <ul>
            <li>all the stuff after the commit is considered garbage</li>
          </ul>
        </li>
        <li>if something is not correct, ==roll back== to previous commit (i.e. second last commit of data consistency)</li>
      </ol>
    </li>
    <li>
      <p>used for <code class="language-plaintext highlighter-rouge">EXT3/EXT4</code> file system updates in Linux</p>
    </li>
  </ul>
</blockquote>

<p>Therefore, when you do a write (e.g. creating a file) to disk, your OS will do:</p>

<ol>
  <li>write some update metadata/data in <em>chronological order</em></li>
  <li>write a <strong>commit</strong> for an entire operation to the journal</li>
  <li>actually <strong>flush to disk</strong></li>
</ol>

<blockquote>
  <p><strong>Disadvantage</strong></p>

  <ul>
    <li>since we need to record our writes in journal, this means we need to “update” both the journal and the disk when we are doing some writes. This is some <strong>extra work/space</strong>.</li>
  </ul>

  <p><strong>Solution</strong></p>

  <ul>
    <li>only record <strong>meta-data</strong> as a ==compromise==. So that we <em>might have data-inconsistency</em>, but at least <strong>file system is consistent</strong></li>
  </ul>
</blockquote>

<h3 id="log-structured-file-system">Log Structured File System</h3>

<p>This calls for a file system which focusses on <strong>write performance</strong>, makes use of the sequential bandwidth, and works efficiently on both disk writes as well as metadata updates.</p>

<p>Basically, the idea is:</p>

<ul>
  <li>the <strong>Journaling</strong> idea itself becomes the file system mechanism, where we are <strong>reading/writing to</strong></li>
</ul>

<blockquote>
  <p><strong>Log Structured FS - LFS</strong></p>

  <ul>
    <li>Sequential, chronological ordering of <em>all writes</em></li>
    <li>Avoid <strong>seek</strong> time for writes, since we are just <em>appending</em></li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Disadvantage</strong></p>

  <ul>
    <li><strong>updates</strong> are hard, since you then need to <em>find</em> the data to update. Therefore, the approach is to just <strong>write a new one</strong> and rewire the <code class="language-plaintext highlighter-rouge">inode</code>
      <ul>
        <li>producing <em>extra unneeded data</em></li>
      </ul>
    </li>
    <li>for <strong>reads</strong>, you will need to keep an <code class="language-plaintext highlighter-rouge">inode-map</code>, which tells you where the <code class="language-plaintext highlighter-rouge">inode</code>s are
      <ul>
        <li>stored on RAM</li>
        <li><code class="language-plaintext highlighter-rouge">inode-map</code> is periodically written to log</li>
        <li>also, recall that most <code class="language-plaintext highlighter-rouge">read</code>s are satisfied via Page Cache, so we don’t often go to Disk anyway</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>So the main problem is the update, which will chew up your memory very fast.</p>

<blockquote>
  <p><strong>Cleaning/Compaction</strong></p>

  <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-13_16-46-40.png" style="zoom:50%;" /></p>

  <ul>
    <li>periodically cleans up unneeded data of a region of the memory</li>
    <li>try to do this when <code class="language-plaintext highlighter-rouge">fs</code> is <strong>not busy</strong></li>
  </ul>
</blockquote>

<p>More advantages of this:</p>

<blockquote>
  <p><strong>Snapshots of File System</strong></p>

  <ul>
    <li>basically, you will just have a <strong>marker</strong> in your log-structured file system, so that every time you need to roll-back, roll-back to that marker
      <ul>
        <li>so this is <em>easy to do with this file system</em></li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="data-organization-on-ssd">Data Organization on SSD</h2>

<p>For HDD, we wanted to minimize seek time. However, for SSD, recall that <em>random seek time $\approx$ sequential seek time</em>!</p>

<blockquote>
  <p><strong>Problem of SSD</strong></p>

  <ul>
    <li>know that random seek time is fast, but <strong>erase time</strong> is slow
      <ul>
        <li>for <em>HDD</em>, we can just <em>overwrite it</em>. However for <em>SSD</em> using flash, we need to <em>erase first</em></li>
        <li>e.g. when we update something, need to erase it and rewrite it.</li>
      </ul>
    </li>
    <li>each disk block on SSD has a <strong>finite number of erases that you can do</strong>
      <ul>
        <li>that disk block will ==wear out physically== for large amount of erases</li>
        <li>this is also called ==wear leveling==</li>
      </ul>
    </li>
    <li>the lock contention for multi-CPU would be also a problem (mentioned before)
      <ul>
        <li>needed private I/O queues</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Now, what is a good file system that suits the SSD?</p>

<blockquote>
  <p><strong>Log-Structured File System - LFS !</strong></p>

  <ul>
    <li>write something <em>new</em> everytime for updates!
      <ul>
        <li><strong>wear leveling</strong> is solved</li>
      </ul>
    </li>
    <li>since erasing is slow, we can just <em>wipe a large block together IN ADVANCE</em></li>
  </ul>
</blockquote>

<h2 id="hdd-and-raid">HDD and RAID</h2>

<p>In reality, since HDD is cheaper, we still use HDD for storing <em>large amount of data</em></p>

<blockquote>
  <p><strong>HDD Reality</strong></p>

  <ul>
    <li>can have large platter, can store lots of data
      <ul>
        <li>large platter to move around, mechnically complicated and harder to make</li>
      </ul>
    </li>
    <li>what if instead of a large disk, have <strong>many</strong> <em>small platters</em> instead
      <ul>
        <li>mean time to failure MTTF is the <strong>same for disk regardless of the size (usually)</strong></li>
        <li><strong>lower reliability</strong></li>
        <li>the solution is ==RAID==</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>The aim is to:</p>

<ul>
  <li>makes use of a combination of multiple disks instead of using a single disk for <strong>increased performance, data redundancy or both</strong>.</li>
</ul>

<blockquote>
  <p><strong>RAID - Redundant Array of Inexpensive/Independent Disk</strong></p>

  <ol>
    <li>
      <p>RAID 0 - <strong>Striping but No Redundancy</strong> - bad idea</p>

      <ul>
        <li>
          <p>speads your data of the same file across disks, so that we can increase parallel reads</p>
        </li>
        <li>
          <p>no copies of disks. Failure is not prevented/remedied at all.</p>

          <p><img src="https://media.geeksforgeeks.org/wp-content/uploads/raid1-1.png" style="zoom:67%;" /></p>

          <p>where:</p>

          <ul>
            <li>
              <p>each block corresponds to a disk block</p>
            </li>
            <li>
              <p>a horizontal strip is from the “same file”</p>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <p>RAID 1 - ==Mirroring==: simply make a <em>copy</em> of the disk!</p>

      <ul>
        <li>
          <p>higher availability/<strong>reliability</strong></p>
        </li>
        <li>
          <p>higher I/O <strong>throughput</strong> since we can read same data from multiple disks</p>

          <ul>
            <li>sometimes, the same file might be saved on multiple disks so that we can have higher <em>parallel read performances</em></li>
          </ul>

          <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-14_13-55-13.png" style="zoom:50%;" /></p>
        </li>
        <li>
          <p>doubling the writes/space</p>
        </li>
        <li>
          <p>if you convert a SSD from RAID 1 to any other version, then your data is <em>all over the place</em>!</p>
        </li>
      </ul>
    </li>
    <li>
      <p>RAID 3 - ==Parity Disk==</p>

      <ul>
        <li>
          <p>recover from any <strong>one disk failure</strong> (good assumption since they are <em>independent</em>)</p>
        </li>
        <li>
          <p>if one disk failed, we can figure out what <strong>is missing</strong> deducting from looking at the parity disk + other disks</p>

          <p><img src="https://media.geeksforgeeks.org/wp-content/uploads/raid4-1.png" style="zoom:67%;" /></p>

          <p>an simple <strong>example</strong> would be:</p>

          <p><img src="https://media.geeksforgeeks.org/wp-content/uploads/raid5-1.png" alt="" /></p>
        </li>
        <li>
          <p>then, the problem becomes that you need to <strong>update the parity disk every time a disk is updated!</strong></p>

          <ul>
            <li>eventually writes to parity disk becomes the bottleneck</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <p>RAID 5</p>

      <ul>
        <li>
          <p>striping/spreading the <strong>parity across disks</strong></p>

          <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-14_13-59-13.png" style="zoom:67%;" /></p>
        </li>
      </ul>
    </li>
  </ol>
</blockquote>

<h2 id="file-system-review">File System Review</h2>

<blockquote>
  <p><strong>fork()</strong></p>

  <ul>
    <li>When we did <code class="language-plaintext highlighter-rouge">fork()</code> for a program, the following happens:
      <ol>
        <li>traps to kernel</li>
        <li>create <code class="language-plaintext highlighter-rouge">task struct</code></li>
        <li>create <code class="language-plaintext highlighter-rouge">struct mm</code>, i.e. address space
          <ul>
            <li>copies all the vma</li>
            <li>for each addresses inside the vma, do a page walk and do a <em>copy-on-write mapping</em> for all the pages</li>
          </ul>
        </li>
        <li>wakes up the task
          <ul>
            <li>set the task to <code class="language-plaintext highlighter-rouge">runnnable</code></li>
            <li>enqueue into the run queue</li>
            <li>if it gets picked by the scheduler, your <code class="language-plaintext highlighter-rouge">fork</code>ed program is now running</li>
          </ul>
        </li>
        <li><code class="language-plaintext highlighter-rouge">fork</code>ed program is running
          <ul>
            <li>if it is writing to the page, a <strong>page fault</strong> happens</li>
            <li>traps back to the kernel</li>
            <li>walk page table</li>
            <li>realize it is cow mapping, then actually copies the page table</li>
            <li>restart the instruction</li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</blockquote>

<p>When a program <strong>is running</strong></p>

<ul>
  <li>there will be a timer for a program <code class="language-plaintext highlighter-rouge">-&gt;</code> timer interrupts</li>
  <li>als other scheduling class dependent stuff</li>
</ul>

<blockquote>
  <p><strong>exec()</strong></p>

  <ul>
    <li>under the hood, it does:
      <ol>
        <li>gets the <code class="language-plaintext highlighter-rouge">executable</code> you specified by <strong>translating/waling the file path</strong></li>
        <li><strong>replace</strong> the content of this executable with the currently running process
          <ul>
            <li>by something similar to <a href="# fs/open.c"><code class="language-plaintext highlighter-rouge">c</code> fs/open.c</a></li>
            <li>followed by a <code class="language-plaintext highlighter-rouge">read</code> to load the program, see <a href="#`c` fs/read_write.c"><code class="language-plaintext highlighter-rouge">c</code> fs/read_write.c</a>
              <ul>
                <li>if not on RAM, submits a disk I/O request</li>
                <li>the <em>callback</em> will wake the process back up after I/O is done</li>
              </ul>
            </li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</blockquote>

<h2 id="actual-linux-implementation-2">Actual Linux Implementation</h2>

<h3 id="linux-file-system">Linux File System</h3>

<p>The below code is stored un der the <code class="language-plaintext highlighter-rouge">/fs</code> directory, which contains:</p>

<ul>
  <li>essentially <strong>each subdirectory represents a different file system</strong> (e.g. <code class="language-plaintext highlighter-rouge">ramfs</code> and <code class="language-plaintext highlighter-rouge">proc</code>)</li>
  <li>the files not in subdirectories <strong>represent file system generic code</strong></li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>there are actually some <em>sample codes</em> that shows you how a <em>basic file system can be written</em>. This is the <code class="language-plaintext highlighter-rouge">fs/ramfs/inode.c</code></li>
  </ul>
</blockquote>

<h4 id="struct-inode-in-memory"><code class="language-plaintext highlighter-rouge">struct</code> inode (in memory)</h4>

<p>This is <strong>in-memory</strong> <code class="language-plaintext highlighter-rouge">inode</code>, defined in <code class="language-plaintext highlighter-rouge">include/linux/fs.h</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Keep mostly read-only and often accessed (especially for
 * the RCU path lookup and 'stat' data) fields at the beginning
 * of the 'struct inode'
 */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
	<span class="n">umode_t</span>			<span class="n">i_mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>		<span class="n">i_opflags</span><span class="p">;</span>
	<span class="n">kuid_t</span>			<span class="n">i_uid</span><span class="p">;</span>
	<span class="n">kgid_t</span>			<span class="n">i_gid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">i_flags</span><span class="p">;</span>
    
    <span class="cm">/* some code omitted here */</span>
    <span class="cm">/* file related information */</span>
    <span class="k">union</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>	<span class="o">*</span><span class="n">i_fop</span><span class="p">;</span>	<span class="cm">/* former -&gt;i_op-&gt;default_file_ops */</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
	<span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="struct-file-in-memory"><code class="language-plaintext highlighter-rouge">struct</code> file (in memory)</h4>

<p>This is <strong>in-memory</strong> <code class="language-plaintext highlighter-rouge">file</code> defined in <code class="language-plaintext highlighter-rouge">include/linux/fs.h</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">llist_node</span>	<span class="n">fu_llist</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rcu_head</span> 	<span class="n">fu_rcuhead</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">f_u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span>		<span class="n">f_path</span><span class="p">;</span>
    <span class="cm">/* inode linked to the file */</span>
	<span class="k">struct</span> <span class="n">inode</span>		<span class="o">*</span><span class="n">f_inode</span><span class="p">;</span>	<span class="cm">/* cached value */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>	<span class="o">*</span><span class="n">f_op</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where we see:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inode</code> linked to the file</li>
</ul>

<h4 id="struct-superblock-in-memory"><code class="language-plaintext highlighter-rouge">struct</code> superblock (in memory)</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">super_block</span> <span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="k">struct</span> <span class="n">list_head</span>	<span class="n">s_mounts</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="struct-dentry-in-memory"><code class="language-plaintext highlighter-rouge">struct</code> dentry (in memory)</h4>

<p>This is essentially linked to a <code class="language-plaintext highlighter-rouge">inode</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">dentry</span> <span class="p">{</span>
	<span class="cm">/* some code omitted here */</span>
	<span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="n">d_hash</span><span class="p">;</span>	<span class="cm">/* lookup hash list */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_parent</span><span class="p">;</span>	<span class="cm">/* parent directory */</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">d_name</span><span class="p">;</span>
    <span class="cm">/* which links to an inode */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">d_inode</span><span class="p">;</span>	
<span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="struct-task_struct-in-memory"><code class="language-plaintext highlighter-rouge">struct</code> task_struct (in memory)</h4>

<p>This is obviously in memory, but it <strong>actually contains</strong></p>

<ul>
  <li>file system related data</li>
  <li><code class="language-plaintext highlighter-rouge">files_struct</code> open files</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">task_struct</span><span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="k">struct</span> <span class="n">fs_struct</span>		<span class="o">*</span><span class="n">fs</span><span class="p">;</span>

	<span class="cm">/* Open file information: */</span>
	<span class="k">struct</span> <span class="n">files_struct</span>		<span class="o">*</span><span class="n">files</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li>
    <p>the <code class="language-plaintext highlighter-rouge">fs_struct</code> contains:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">fs_struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">users</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">seqcount_t</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">umask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">in_exec</span><span class="p">;</span>
    <span class="cm">/* a root PATH */</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">root</span><span class="p">,</span> <span class="n">pwd</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>the <code class="language-plaintext highlighter-rouge">files_struct</code> essentially contains an <em>array of <code class="language-plaintext highlighter-rouge">fd</code>s</em>, and the <code class="language-plaintext highlighter-rouge">next_fd</code> means the next available <code class="language-plaintext highlighter-rouge">fd</code> that the next opened file is going to use</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">files_struct</span><span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_fd</span><span class="p">;</span>
	<span class="cm">/* some code omitted here */</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="n">__rcu</span> <span class="o">*</span> <span class="n">fd_array</span><span class="p">[</span><span class="n">NR_OPEN_DEFAULT</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="c-libfsc-generic"><code class="language-plaintext highlighter-rouge">c</code> libfs.c (generic)</h4>

<p>This is inside <code class="language-plaintext highlighter-rouge">fs/libfs.c</code>, which contains <strong>many file system generic operations</strong></p>

<blockquote>
  <p><strong>In fact</strong></p>

  <ul>
    <li>the comment at the top of the file says that <strong>this is a library for file system writers</strong></li>
  </ul>
</blockquote>

<p><em>For Example</em></p>

<p>Accessing something like <code class="language-plaintext highlighter-rouge">/usr/bin/vi</code> means:</p>

<ul>
  <li>OS creates <code class="language-plaintext highlighter-rouge">dentry</code> for <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">usr</code>, <code class="language-plaintext highlighter-rouge">bin</code>, <code class="language-plaintext highlighter-rouge">vi</code> to get the <em>actual <code class="language-plaintext highlighter-rouge">inode</code>/file</em></li>
  <li>then it will <strong>cache</strong> those <code class="language-plaintext highlighter-rouge">dentries</code></li>
  <li>so the next time we access <code class="language-plaintext highlighter-rouge">/</code>, it will <em>directly get the <code class="language-plaintext highlighter-rouge">inode</code></em> from the cache</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">simple_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">NAME_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_d_op</span><span class="p">)</span>
		<span class="n">d_set_d_op</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">simple_dentry_operations</span><span class="p">);</span>
	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">simple_lookup</span><span class="p">);</span>

<span class="cm">/* dcache is basically the directory cache */</span>
<span class="kt">int</span> <span class="nf">dcache_dir_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">d_alloc_cursor</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* some code omitted here */</span>
</code></pre></div></div>

<h5 id="func-simple_fill_super"><code class="language-plaintext highlighter-rouge">func</code> simple_fill_super()</h5>

<p>This is used for file systems such as <code class="language-plaintext highlighter-rouge">debug_fs</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * the inodes created here are not hashed. If you use iunique to generate
 * unique inode values later for this filesystem, then you must take care
 * to pass it an appropriate max_reserved value to avoid collisions.
 */</span>
<span class="kt">int</span> <span class="nf">simple_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">magic</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">tree_descr</span> <span class="o">*</span><span class="n">files</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="cm">/* 1. sets up some super block related field */</span>
    <span class="cm">/* equivalent to what ramfs_fill_super() did */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">=</span> <span class="n">magic</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">simple_super_operations</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_time_gran</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">||</span> <span class="n">files</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">files</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* some code omitted here */</span>
        
        <span class="cm">/* 2. sets up super block related operations */</span>
        <span class="cm">/* equivalent to what ramfs_get_inode() did */</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="n">files</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="n">files</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">d_genocide</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">shrink_dcache_parent</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="func-simple_lookup"><code class="language-plaintext highlighter-rouge">func</code> simple_lookup()</h5>

<p>This would be used, for example, by an <code class="language-plaintext highlighter-rouge">open()</code> system call, which would needed to find the <code class="language-plaintext highlighter-rouge">dentry</code> path from a string (by doing a <strong>path walk</strong>)</p>

<ul>
  <li>for example, <code class="language-plaintext highlighter-rouge">ramfs</code> has its directory operation having <code class="language-plaintext highlighter-rouge">simple_lookup()</code></li>
</ul>

<p>Inside <code class="language-plaintext highlighter-rouge">simple_lookup()</code>, we have:</p>

<ol>
  <li>
    <p>looks the entry up and return the <code class="language-plaintext highlighter-rouge">dentry</code></p>
  </li>
  <li>
    <p>add this translation to <strong><code class="language-plaintext highlighter-rouge">dcache</code></strong></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">simple_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">NAME_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_d_op</span><span class="p">)</span>
		<span class="n">d_set_d_op</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">simple_dentry_operations</span><span class="p">);</span>
    <span class="cm">/* 2. add this translation to **`dcache`** */</span>
	<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="c-initc"><code class="language-plaintext highlighter-rouge">c</code> init.c</h4>

<p>Basically, come relavant functions are are to deal with</p>

<ul>
  <li>file system <strong>initialization</strong>, including <em>registration of a file system</em></li>
</ul>

<h5 id="func-vfs_caches_init"><code class="language-plaintext highlighter-rouge">func</code> vfs_caches_init()</h5>

<p>This is the entry point/initialization of kernel files system, which takes place in <code class="language-plaintext highlighter-rouge">init.c</code>, and goes to <code class="language-plaintext highlighter-rouge">vfs_caches_init()</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">__init</span> <span class="nf">vfs_caches_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">names_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create_usercopy</span><span class="p">(</span><span class="s">"names_cache"</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">dcache_init</span><span class="p">();</span>
	<span class="n">inode_init</span><span class="p">();</span>
	<span class="n">files_init</span><span class="p">();</span>
	<span class="n">files_maxfiles_init</span><span class="p">();</span>
    <span class="cm">/* mnt_init */</span>
	<span class="n">mnt_init</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>which then goes to <code class="language-plaintext highlighter-rouge">mnt_init</code> for mount:</p>

<ol>
  <li>
    <p>initializes <code class="language-plaintext highlighter-rouge">sys_fs</code>, which will be <em>used by the kernel in the beginning</em></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">__init</span> <span class="nf">mnt_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
     <span class="n">kernfs_init</span><span class="p">();</span>
    <span class="cm">/* some code omitted here */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_init</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>which then calls <code class="language-plaintext highlighter-rouge">sysfs_init()</code>, and does:</p>

    <ol>
      <li>
        <p>registers file system, which <em>registers the FILE SYSTEM’s TYPE</em> with the system (i.e. this type <code class="language-plaintext highlighter-rouge">sysfs</code> is now usable for future)</p>

        <ul>
          <li>you will also see this in <code class="language-plaintext highlighter-rouge">init_ramfs_fs</code> for starter code</li>
        </ul>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">__init</span> <span class="nf">sysfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
      
	<span class="cm">/* some code omitted here */</span>
          
    <span class="cm">/* 1. registers file system */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kernfs_destroy_root</span><span class="p">(</span><span class="n">sysfs_root</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
      
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
</ol>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>for all cases, before using a file system, the <strong>first thing is to register it</strong></li>
    <li>then you would need to mount</li>
  </ul>
</blockquote>

<h5 id="func-arch_call_rest_init"><code class="language-plaintext highlighter-rouge">func</code> arch_call_rest_init()</h5>

<p>This then <em>initializes</em> things such as <strong>registering some other file systems</strong></p>

<ul>
  <li>this is also called in <code class="language-plaintext highlighter-rouge">init.c</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">arch_call_rest_init()</code> just calls <code class="language-plaintext highlighter-rouge">rest_init()</code>, which then:</p>

<ol>
  <li>creates a <code class="language-plaintext highlighter-rouge">kernel_thread</code> to run <code class="language-plaintext highlighter-rouge">kernel_init</code></li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">noinline</span> <span class="kt">void</span> <span class="n">__ref</span> <span class="nf">rest_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 1. creates a kernel_thread to run kernel_init */</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="n">kernel_init</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CLONE_FS</span><span class="p">);</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where that <code class="language-plaintext highlighter-rouge">kernel_init</code> does:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">kernel_init()</code> which goes to <code class="language-plaintext highlighter-rouge">do_basic_setup()</code>, then then <code class="language-plaintext highlighter-rouge">do_initcalls()</code> calls stuff such as:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">init_ramfs_fs()</code> and a bunch of <strong>other <code class="language-plaintext highlighter-rouge">init</code> calls</strong></li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="n">__ref</span> <span class="nf">kernel_init</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 1. this eventually goes to do_basic_setup */</span>
    <span class="n">kernel_init_freeable</span><span class="p">();</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="func-do_mount"><code class="language-plaintext highlighter-rouge">func</code> do_mount()</h4>

<p>This is eventually called by the <em>system call</em> <code class="language-plaintext highlighter-rouge">mount()</code>.</p>

<blockquote>
  <p><em>Reminder</em></p>

  <p>To <strong>use</strong> a file system in Linux, we would need to:</p>

  <ol>
    <li>register it</li>
    <li>mount it</li>
  </ol>
</blockquote>

<p>Inside <code class="language-plaintext highlighter-rouge">do_mount()</code>, we are doing:</p>

<ol>
  <li>
    <p>start a new mount with <code class="language-plaintext highlighter-rouge">do_new_mount</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">do_mount</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dir_name</span><span class="p">,</span>
              <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type_page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data_page</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span>
        <span class="cm">/* some code omitted here */</span>
    <span class="k">else</span> <span class="cm">/* 1. start a new mount with `do_new_mount` */</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">do_new_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">type_page</span><span class="p">,</span> <span class="n">sb_flags</span><span class="p">,</span> <span class="n">mnt_flags</span><span class="p">,</span>
                              <span class="n">dev_name</span><span class="p">,</span> <span class="n">data_page</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>then the <code class="language-plaintext highlighter-rouge">do_new_mount()</code> does:</p>

    <ol>
      <li>
        <p>gets the file system type</p>
      </li>
      <li>
        <p>gets the file system context</p>

        <ul>
          <li>
            <p>has a bunch of stuff/metadata associated with a <em>mounted file system</em></p>
          </li>
          <li>
            <p>in code, it will go to <code class="language-plaintext highlighter-rouge">alloc_fs_context</code>, and then attempts to <strong>get</strong> a <code class="language-plaintext highlighter-rouge">init_fs_context</code> <strong>OF THAT FILE SYSTEM</strong></p>

            <ul>
              <li>i.e. this is a field of a file system type</li>
              <li>for old/legacy file systems, this will be empty, so it will <em>give it a <code class="language-plaintext highlighter-rouge">legacy_fs_context</code></em></li>
            </ul>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="nf">alloc_fs_context</span><span class="p">()</span>
<span class="p">{</span>
    <span class="cm">/* attemps to get the file system's associated context */</span>
    <span class="n">init_fs_context</span> <span class="o">=</span> <span class="n">fc</span><span class="o">-&gt;</span><span class="n">fs_type</span><span class="o">-&gt;</span><span class="n">init_fs_context</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init_fs_context</span><span class="p">)</span><span class="cm">/* if none, assign a legacy one */</span>
        <span class="n">init_fs_context</span> <span class="o">=</span> <span class="n">legacy_init_fs_context</span><span class="p">;</span>
        
    <span class="n">ret</span> <span class="o">=</span> <span class="n">init_fs_context</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>            </div>

            <p>and eventually, the <code class="language-plaintext highlighter-rouge">legacy_init_fs_context</code> will contain <code class="language-plaintext highlighter-rouge">fc-&gt;ops = &amp;legacy_fs_context_ops;</code>, which <strong>looks like</strong>:</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="k">struct</span> <span class="n">fs_context_operations</span> <span class="n">legacy_fs_context_ops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">free</span>			<span class="o">=</span> <span class="n">legacy_fs_context_free</span><span class="p">,</span>
    <span class="p">.</span><span class="n">dup</span>			<span class="o">=</span> <span class="n">legacy_fs_context_dup</span><span class="p">,</span>
    <span class="p">.</span><span class="n">parse_param</span>		<span class="o">=</span> <span class="n">legacy_parse_param</span><span class="p">,</span>
    <span class="p">.</span><span class="n">parse_monolithic</span>	<span class="o">=</span> <span class="n">legacy_parse_monolithic</span><span class="p">,</span>
    <span class="p">.</span><span class="n">get_tree</span>		<span class="o">=</span> <span class="n">legacy_get_tree</span><span class="p">,</span>
    <span class="p">.</span><span class="n">reconfigure</span>		<span class="o">=</span> <span class="n">legacy_reconfigure</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>            </div>

            <blockquote>
              <p><strong>Note</strong></p>

              <ul>
                <li>
                  <p>An example that <em>has the context</em> would be the <code class="language-plaintext highlighter-rouge">ramfs</code>, which is in-memory:</p>

                  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">ramfs_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">"ramfs"</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_fs_context</span> <span class="o">=</span> <span class="n">ramfs_init_fs_context</span><span class="p">,</span> <span class="cm">/* has a context */</span>
	<span class="p">.</span><span class="n">parameters</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ramfs_fs_parameters</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span>	<span class="o">=</span> <span class="n">ramfs_kill_sb</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fs_flags</span>	<span class="o">=</span> <span class="n">FS_USERNS_MOUNT</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>                  </div>
                </li>
              </ul>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>
        <p><strong>sets up the superblock</strong> for the file system, which will call the <em>file system specific operation of <code class="language-plaintext highlighter-rouge">get_tree</code></em></p>
      </li>
      <li>
        <p>do the actual mount when everything setup (see very below)</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">do_new_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fstype</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sb_flags</span><span class="p">,</span>
                        <span class="kt">int</span> <span class="n">mnt_flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fstype</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
      
    <span class="cm">/* 1. gets the file system type */</span>
    <span class="n">type</span> <span class="o">=</span> <span class="n">get_fs_type</span><span class="p">(</span><span class="n">fstype</span><span class="p">);</span>	
    <span class="cm">/* 2. gets the file system context */</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">fs_context_for_mount</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">sb_flags</span><span class="p">);</span>
    <span class="n">put_filesystem</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fc</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>
      
          
    <span class="cm">/* some code omitted here */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mount_capable</span><span class="p">(</span><span class="n">fc</span><span class="p">))</span>
        <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="cm">/* 3. stes up the superblock */</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">vfs_get_tree</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="cm">/* 4. do the actual mount */</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">do_new_mount_fc</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mnt_flags</span><span class="p">);</span>
      
    <span class="n">put_fs_context</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <p>where the <code class="language-plaintext highlighter-rouge">vsf_get_tree()</code> will:</p>

        <ol>
          <li>
            <p>call the file system specific <code class="language-plaintext highlighter-rouge">get_tree()</code> operation which would be <strong>contained in the <code class="language-plaintext highlighter-rouge">context</code></strong></p>

            <blockquote>
              <p><em>Reminder</em>:</p>

              <ul>
                <li>
                  <p>the context looks like:</p>

                  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">fs_context</span> <span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fs_context_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>                  </div>

                  <p>and the operation looks like:</p>

                  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">fs_context_operations</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">src_fc</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">parse_param</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fs_parameter</span> <span class="o">*</span><span class="n">param</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">parse_monolithic</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_tree</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span> <span class="cm">/* the operation we are looking at now */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">reconfigure</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>                  </div>
                </li>
              </ul>
            </blockquote>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">vfs_get_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
         
	<span class="k">if</span> <span class="p">(</span><span class="n">fc</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
         
	<span class="cm">/* Get the mountable root in fc-&gt;root, with a ref on the root and a ref
	 * on the superblock.
	 */</span>
    <span class="cm">/* 1. call the file system specific `get_tree()` operation  */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">fc</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_tree</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>            </div>

            <p>here, I will use the <em>example of <code class="language-plaintext highlighter-rouge">ramfs</code> to proceed</em></p>

            <ol>
              <li>
                <p>this is actually a <strong>generic</strong> call for setting up the <strong>super block</strong> of a file system which has <strong>no underlying device</strong></p>

                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ramfs_get_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_tree_nodev</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="n">ramfs_fill_super</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>                </div>

                <p>which eventually goes to <code class="language-plaintext highlighter-rouge">vfs_get_super()</code></p>

                <ol>
                  <li>
                    <p>find or <em>create</em> the superblock for the file system!</p>

                    <ul>
                      <li>
                        <p>which then goes to <code class="language-plaintext highlighter-rouge">sget_fc()</code> and actually <em>allocates/create</em> the super block via <code class="language-plaintext highlighter-rouge">alloc_super()</code></p>

                        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="nf">sget_fc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">test</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="p">),</span>
			    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">alloc_super</span><span class="p">(</span><span class="n">fc</span><span class="o">-&gt;</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">fc</span><span class="o">-&gt;</span><span class="n">sb_flags</span><span class="p">,</span> <span class="n">user_ns</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>                        </div>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <p>then, if <code class="language-plaintext highlighter-rouge">root</code> is none, we want to <code class="language-plaintext highlighter-rouge">fill_super()</code> i.e. fill in <em>metadata for the super block</em></p>

                    <ul>
                      <li>which again calls the <em>file system specific <code class="language-plaintext highlighter-rouge">fill_super()</code></em></li>
                    </ul>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">vfs_get_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span>
                  <span class="k">enum</span> <span class="n">vfs_get_super_keying</span> <span class="n">keying</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fill_super</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">))</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
                   
    <span class="cm">/* 1. find or *create* the superblock for the file system! */</span>
    <span class="n">sb</span> <span class="o">=</span> <span class="n">sget_fc</span><span class="p">(</span><span class="n">fc</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">set_anon_super_fc</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
               
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 2. then, if `root` is none, we want to `fill_super()` */</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">fill_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fc</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>                    </div>

                    <p>where the <code class="language-plaintext highlighter-rouge">ramfs_fill_super()</code> looks like:</p>

                    <ol>
                      <li>
                        <p>sets up some fields</p>
                      </li>
                      <li>
                        <p>create the <strong>root <code class="language-plaintext highlighter-rouge">inode</code> of the file system</strong> (everything has a <em>file representation</em>)</p>
                      </li>
                      <li>
                        <p>makes the above <code class="language-plaintext highlighter-rouge">inode</code> the root</p>

                        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">ramfs_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ramfs_fs_info</span> <span class="o">*</span><span class="n">fsi</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
                  
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span>		<span class="o">=</span> <span class="n">MAX_LFS_FILESIZE</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span>		<span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span>	<span class="o">=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span>		<span class="o">=</span> <span class="n">RAMFS_MAGIC</span><span class="p">;</span> <span class="cm">/* a magnic number */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ramfs_ops</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                  
    <span class="cm">/* 2. create the **root `inode` of the file system** */</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">ramfs_get_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">fsi</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="cm">/* 3. makes the above `inode` the root */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
                  
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>                        </div>

                        <p>where <code class="language-plaintext highlighter-rouge">ramfs_get_inode</code> gets <em>passed the <code class="language-plaintext highlighter-rouge">S_IFDIR</code></em> and does:</p>

                        <ol>
                          <li>
                            <p>sets up <strong><code class="language-plaintext highlighter-rouge">inode</code> related operations</strong> (similar to the file system operations)</p>
                          </li>
                          <li>
                            <p>sets up the <code class="language-plaintext highlighter-rouge">inode</code> <strong>file related operations</strong></p>

                            <ul>
                              <li>if it is a regular <em>file</em>, it has <code class="language-plaintext highlighter-rouge">S_IFREG</code></li>
                              <li>if it is a <em>directory</em>, it goes to <code class="language-plaintext highlighter-rouge">S_IFDIR</code> (<strong>our case</strong>)</li>
                            </ul>

                            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ramfs_get_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
                              <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">S_IFREG</span><span class="p">:</span>
            <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ramfs_file_inode_operations</span><span class="p">;</span>
            <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ramfs_file_operations</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">S_IFDIR</span><span class="p">:</span>
            <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ramfs_dir_inode_operations</span><span class="p">;</span> <span class="cm">/* inode related */</span>
            <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">simple_dir_operations</span><span class="p">;</span> <span class="cm">/* file related */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>                            </div>
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        <p>do the <strong>mount</strong> in <code class="language-plaintext highlighter-rouge">do_new_mount()</code> when everything has been setup</p>
      </li>
    </ol>
  </li>
</ol>

<h4 id="func-legacy_get_tree"><code class="language-plaintext highlighter-rouge">func</code> legacy_get_tree()</h4>

<p>This is when, for example, in <code class="language-plaintext highlighter-rouge">do_mount()</code>, we needed to call the <em>file system specific <code class="language-plaintext highlighter-rouge">get_tree()</code></em>. However, some legacy file system <em>does not define those operations</em>, therefore, <code class="language-plaintext highlighter-rouge">legacy_get_tree()</code> will be used in the context.</p>

<blockquote>
  <p><em>Reminder</em>:</p>

  <ul>
    <li>for <code class="language-plaintext highlighter-rouge">ramfs</code>, the <code class="language-plaintext highlighter-rouge">get_tree()</code> basically does:
      <ol>
        <li>sets up the superblock for the file system</li>
        <li>fill in the super block with related operations</li>
      </ol>
    </li>
  </ul>
</blockquote>

<p>Inside <code class="language-plaintext highlighter-rouge">legacy_get_tree()</code>, we have:</p>

<ol>
  <li>
    <p>directly <code class="language-plaintext highlighter-rouge">mount</code> the file system</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">legacy_get_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">fs_context</span> <span class="o">*</span><span class="n">fc</span><span class="p">)</span>
<span class="p">{</span>
     <span class="cm">/* some code omitted here */</span>
   
     <span class="n">root</span> <span class="o">=</span> <span class="n">fc</span><span class="o">-&gt;</span><span class="n">fs_type</span><span class="o">-&gt;</span><span class="n">mount</span><span class="p">(</span><span class="n">fc</span><span class="o">-&gt;</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">fc</span><span class="o">-&gt;</span><span class="n">sb_flags</span><span class="p">,</span>
                              <span class="n">fc</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">legacy_data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
   
    <span class="cm">/* some code omitted here */</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>in this example, we use the <code class="language-plaintext highlighter-rouge">debug_fs</code> <em>specific <code class="language-plaintext highlighter-rouge">mount</code></em>, which then does</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">debug_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span>
         <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
 <span class="k">return</span> <span class="n">mount_single</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">debug_fill_super</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>then, in the <code class="language-plaintext highlighter-rouge">mount_single()</code>, we are <strong>passing in the <code class="language-plaintext highlighter-rouge">debug_fill_super()</code></strong> function, which does:</p>

<ol>
  <li>
    <p>fills in the superblock using <code class="language-plaintext highlighter-rouge">simple_fill_super()</code></p>

    <ul>
      <li>see section <a href="#`func` simple_fill_super()"><code class="language-plaintext highlighter-rouge">func</code> simple_fill_super()</a></li>
    </ul>
  </li>
  <li>
    <p><strong>overwrite</strong> some fields set up by the <code class="language-plaintext highlighter-rouge">simple_fill_super()</code> call (<em>library function</em>), for <strong>customization</strong> purposes</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">debug_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
 <span class="cm">/* some code omitted here */</span>
    <span class="n">err</span>  <span class="o">=</span>  <span class="n">simple_fill_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">DEBUGFS_MAGIC</span><span class="p">,</span> <span class="n">debug_files</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
      
    <span class="cm">/* 2. overwrites some fields for customization */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">debugfs_super_operations</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_d_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">debugfs_dops</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="c-fsopenc"><code class="language-plaintext highlighter-rouge">c</code> fs/open.c</h4>

<p>This basically demonstrate how an <code class="language-plaintext highlighter-rouge">open()</code> call is served.</p>

<p>First of all, the <code class="language-plaintext highlighter-rouge">syscall</code> definition of <code class="language-plaintext highlighter-rouge">open()</code> looks like:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">open</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">umode_t</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force_o_largefile</span><span class="p">())</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">O_LARGEFILE</span><span class="p">;</span>

    <span class="cm">/* AT_FDCWD means at current working directory location, used later */</span>
	<span class="k">return</span> <span class="n">do_sys_open</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="func-do_sys_open"><code class="language-plaintext highlighter-rouge">func</code> do_sys_open</h5>

<p>This is called for the <code class="language-plaintext highlighter-rouge">open()</code> system call</p>

<p>Basically it does:</p>

<ol>
  <li>
    <p>finds the file to be opened</p>
  </li>
  <li>
    <p>find an <em>unused</em> <code class="language-plaintext highlighter-rouge">fd</code> to be <strong>associated with that file</strong></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">do_sys_open</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 1. finds the file to be opened */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
   
    <span class="cm">/* 2. find an *unused* `fd` to be **associated with that file** */</span>
	<span class="n">fd</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 3. open the file */</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">do_filp_open</span><span class="p">(</span><span class="n">dfd</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
			<span class="n">fd</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fsnotify_open</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
             <span class="cm">/* 4. install the file * to the found fd of the process */</span>
			<span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>then, <code class="language-plaintext highlighter-rouge">get_unused_fd_flags()</code> will <strong>allocate a file descriptor</strong> using <code class="language-plaintext highlighter-rouge">__alloc_fd()</code>:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">get_unused_fd_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* current-&gt;files points to the ARRAY OF OPEN FILES of this process */</span>
	<span class="k">return</span> <span class="n">__alloc_fd</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_NOFILE</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>and it does:</p>

    <ol>
      <li>
        <p>get the <em>file descriptor table</em> of the process</p>
      </li>
      <li>
        <p>start with <code class="language-plaintext highlighter-rouge">0</code>, and <em>find the next available file descriptor</em></p>

        <ul>
          <li>recall that this is <strong>kept in a single field <code class="language-plaintext highlighter-rouge">next_fd</code></strong></li>
        </ul>
      </li>
      <li>
        <p>sets up the next file descriptor (for the next call)</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">__alloc_fd</span><span class="p">(</span><span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">end</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="n">files</span><span class="o">-&gt;</span><span class="n">next_fd</span><span class="p">)</span>
		<span class="n">fd</span> <span class="o">=</span> <span class="n">files</span><span class="o">-&gt;</span><span class="n">next_fd</span><span class="p">;</span>
      
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="n">fdt</span><span class="o">-&gt;</span><span class="n">max_fds</span><span class="p">)</span>
		<span class="n">fd</span> <span class="o">=</span> <span class="n">find_next_fd</span><span class="p">(</span><span class="n">fdt</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p>actually <strong>open the file</strong> with <code class="language-plaintext highlighter-rouge">do_filp_open</code>, which does:</p>

    <ol>
      <li>
        <p>sets up a metadata <code class="language-plaintext highlighter-rouge">nameidata</code> which stores the pathname and etc.</p>
      </li>
      <li>
        <p>open the <em>path</em></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">do_filp_open</span><span class="p">(</span><span class="kt">int</span> <span class="n">dfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">filename</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">open_flags</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
	<span class="n">set_nameidata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="n">dfd</span><span class="p">,</span> <span class="n">pathname</span><span class="p">);</span>
	<span class="n">filp</span> <span class="o">=</span> <span class="n">path_openat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nd</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">LOOKUP_RCU</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <p>which goes to <code class="language-plaintext highlighter-rouge">path_openat()</code> and does:</p>

        <ol>
          <li>
            <p><code class="language-plaintext highlighter-rouge">path_init</code> which does <strong>sets up the starting point of path walk</strong></p>

            <ol>
              <li>
                <p>if the pathname starts with <code class="language-plaintext highlighter-rouge">/</code>, then it is <strong>absolute path</strong></p>
              </li>
              <li>
                <p>otherwise, if it is <strong>relative to current working directory</strong></p>

                <ul>
                  <li>this is actually setup by the system call <code class="language-plaintext highlighter-rouge">do_sys_open(AT_FDCWD, filename, flags, mode);</code></li>
                </ul>

                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">set_root</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">nd_jump_root</span><span class="p">(</span><span class="n">nd</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ECHILD</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">dfd</span> <span class="o">==</span> <span class="n">AT_FDCWD</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>                </div>
              </li>
            </ol>
          </li>
          <li>
            <p><code class="language-plaintext highlighter-rouge">link_path_walk</code> does the <strong>actual path walk</strong></p>

            <ol>
              <li>
                <p>for the string path given, <em>convert it</em> into the <strong><code class="language-plaintext highlighter-rouge">dentry</code> representation</strong> via <code class="language-plaintext highlighter-rouge">walk_component</code>, and either does a <code class="language-plaintext highlighter-rouge">lookup_fast</code> or a <code class="language-plaintext highlighter-rouge">lookup_slow</code></p>

                <ul>
                  <li>
                    <p>look up fast looks like, and basically <strong>goes to the <code class="language-plaintext highlighter-rouge">dcache</code> to look up</strong></p>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">lookup_fast</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">**</span><span class="n">inode</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="o">*</span><span class="n">seqp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="n">dentry</span> <span class="o">=</span> <span class="n">__d_lookup_rcu</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">);</span>
<span class="p">}</span>
              
</code></pre></div>                    </div>
                  </li>
                  <li>
                    <p>look up slow does a <code class="language-plaintext highlighter-rouge">__lookup_slow()</code>, which does:</p>

                    <ol>
                      <li>allocate a <code class="language-plaintext highlighter-rouge">dentry</code></li>
                      <li>call the file system <strong>specific</strong> <code class="language-plaintext highlighter-rouge">inode</code> operation of <code class="language-plaintext highlighter-rouge">look_up()</code>
                        <ul>
                          <li>for <code class="language-plaintext highlighter-rouge">ramfs</code>, it actually becomes the <code class="language-plaintext highlighter-rouge">simple_lookup</code> of <code class="language-plaintext highlighter-rouge">libfs</code></li>
                        </ul>
                      </li>
                    </ol>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Fast lookup failed, do it the slow way */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__lookup_slow</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
                                    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">dentry</span> <span class="o">=</span> <span class="n">d_alloc_parallel</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>
    <span class="k">if</span><span class="p">{</span>
        <span class="cm">/* some code omitted here */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* 2. file system specific lookup */</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">lookup</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span> 
		<span class="n">d_lookup_done</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">old</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>                    </div>
                    <p>```</p>
                  </li>
                </ul>
              </li>
            </ol>

            <p>```</p>
          </li>
        </ol>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">do_last</code>, now all dentries are walked. So we look at the <code class="language-plaintext highlighter-rouge">inode</code> on the <em>last part of the path</em>, by doing a <code class="language-plaintext highlighter-rouge">vfs_open()</code>, which does a <code class="language-plaintext highlighter-rouge">do_dentry_open()</code> by passing in the <strong>actual file’s <code class="language-plaintext highlighter-rouge">inode</code></strong> and does:</p>

        <ol>
          <li>
            <p>if no <code class="language-plaintext highlighter-rouge">open</code> function is passed in, <strong>use the <em>file/<code class="language-plaintext highlighter-rouge">inode</code></em>’s <code class="language-plaintext highlighter-rouge">open</code> function</strong> in <code class="language-plaintext highlighter-rouge">file-&gt;f_op-&gt;open</code></p>

            <ul>
              <li>
                <p>for <code class="language-plaintext highlighter-rouge">ramfs</code>, if this is a directory, it does a <code class="language-plaintext highlighter-rouge">simple_dir_operations-&gt;open</code> which is a <code class="language-plaintext highlighter-rouge">dcache_dir_open()</code></p>

                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="nf">dcache_dir_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
 <span class="p">{</span>
 	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">d_alloc_cursor</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
            
 	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>                </div>
                <p>```</p>
              </li>
            </ul>

            <p>```</p>
          </li>
        </ol>

        <p>so now you have the file pointer setup</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">static</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="nf">path_openat</span><span class="p">(</span><span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">,</span>
   			<span class="k">const</span> <span class="k">struct</span> <span class="n">open_flags</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span>
   <span class="p">{</span>
       <span class="k">if</span><span class="p">{</span>
           <span class="cm">/* some code omitted here */</span>
       <span class="p">}</span>
       <span class="k">else</span> <span class="p">{</span>
   		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">path_init</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span> <span class="cm">/* 1. sets up the starting point of path walk  */</span>
   		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">link_path_walk</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nd</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="cm">/* 2. does the walk */</span>
   			<span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">do_last</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">op</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 3. open the file */</span>
   			<span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">LOOKUP_OPEN</span><span class="o">|</span><span class="n">LOOKUP_CREATE</span><span class="o">|</span><span class="n">LOOKUP_EXCL</span><span class="p">);</span>
   			<span class="n">s</span> <span class="o">=</span> <span class="n">trailing_symlink</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
   		<span class="p">}</span>
   		<span class="n">terminate_walk</span><span class="p">(</span><span class="n">nd</span><span class="p">);</span>
   	<span class="p">}</span>
   <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p>once we have obtained the file pointer, <em>install it to the <code class="language-plaintext highlighter-rouge">fd</code> we found</em>, and does <code class="language-plaintext highlighter-rouge">fd_install</code>, and basically does:</p>

    <ol>
      <li>
        <p>use the array of <code class="language-plaintext highlighter-rouge">fd</code>s of the process</p>
      </li>
      <li>
        <p>index into to the array <em>using out found <code class="language-plaintext highlighter-rouge">fs</code></em></p>
      </li>
      <li>
        <p>put the file pointer into that position</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">__fd_install</span><span class="p">(</span><span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>
      
	<span class="n">rcu_read_lock_sched</span><span class="p">();</span>
      
	<span class="cm">/* some code omitted here */</span>
	<span class="cm">/* coupled with smp_wmb() in expand_fdtable() */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="n">fdt</span> <span class="o">=</span> <span class="n">rcu_dereference_sched</span><span class="p">(</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">fdt</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">fdt</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="cm">/* 1.2.3. use the array of `fd`s of the process and puts the pointer in */</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">fdt</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">[</span><span class="n">fd</span><span class="p">],</span> <span class="n">file</span><span class="p">);</span>
	<span class="n">rcu_read_unlock_sched</span><span class="p">();</span>
<span class="p">}</span>
      
<span class="kt">void</span> <span class="nf">fd_install</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* passing in */</span>
	<span class="n">__fd_install</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
</ol>

<h4 id="func-dcache_dir_open"><code class="language-plaintext highlighter-rouge">func</code> dcache_dir_open</h4>

<blockquote>
  <p><strong>Linux <code class="language-plaintext highlighter-rouge">cd</code> into a Directory</strong></p>

  <ul>
    <li>What happens in terminal when you <code class="language-plaintext highlighter-rouge">cd</code> into a directory would be (for some generic <code class="language-plaintext highlighter-rouge">open/read_dir</code>):
      <ol>
        <li>the <code class="language-plaintext highlighter-rouge">dcache_dir_open</code> gets called</li>
        <li><code class="language-plaintext highlighter-rouge">dcache_readdir</code></li>
        <li><code class="language-plaintext highlighter-rouge">dcache_dir_close</code></li>
      </ol>
    </li>
  </ul>
</blockquote>

<p>Starting off form the top, <code class="language-plaintext highlighter-rouge">dcache_dir_open</code> does:</p>

<ol>
  <li>
    <p>allocate ==cursors==, creates a<code class="language-plaintext highlighter-rouge"> dentry</code> by ==”cloning itself”== that ‘s not linked to any inode and its  <code class="language-plaintext highlighter-rouge">d_subdir</code> are initialized with only itself in it</p>

    <ul>
      <li>
        <p>this in turn calls <code class="language-plaintext highlighter-rouge">d_alloc_cursor</code>, which goes to <code class="language-plaintext highlighter-rouge">d_alloc_anon</code>, then to <code class="language-plaintext highlighter-rouge">__d_alloc_anon(sb, NULL)</code></p>
      </li>
      <li>
        <p>set up the <code class="language-plaintext highlighter-rouge">dentry</code> to some “special state”</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__d_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
    <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
         
    <span class="cm">/* 1. set up the dentry to some "special state" */</span>
    <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
    <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
    <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span> <span class="cm">/* subdirs is empty */</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">dcache_dir_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 1. allocate cursors = a cloned dentry of itself @file-&gt;f_path.dentry */</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">d_alloc_cursor</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>The upshot is that we are <strong>hiding some data (<code class="language-plaintext highlighter-rouge">cursor</code>) in the <code class="language-plaintext highlighter-rouge">private</code> field of the file</strong></p>
</blockquote>

<h4 id="func-dcache_readdir"><code class="language-plaintext highlighter-rouge">func</code> dcache_readdir</h4>

<blockquote>
  <p><strong>Linux <code class="language-plaintext highlighter-rouge">cd</code> into a Directory</strong></p>

  <ul>
    <li>What happens in terminal when you <code class="language-plaintext highlighter-rouge">cd</code> into a directory would be (for some generic <code class="language-plaintext highlighter-rouge">open/read_dir</code>):
      <ol>
        <li>the <code class="language-plaintext highlighter-rouge">dcache_dir_open</code>
          <ul>
            <li>placed some <code class="language-plaintext highlighter-rouge">curosr</code> dentry into the <code class="language-plaintext highlighter-rouge">file-&gt;private_data</code> of the current directory</li>
          </ul>
        </li>
        <li><code class="language-plaintext highlighter-rouge">dcache_readdir</code></li>
        <li><code class="language-plaintext highlighter-rouge">dcache_dir_close</code></li>
      </ol>
    </li>
  </ul>
</blockquote>

<p>Starting from:</p>

<ol>
  <li>
    <p>gets the cursor from <code class="language-plaintext highlighter-rouge">private_data</code></p>
  </li>
  <li>
    <p>creates the <code class="language-plaintext highlighter-rouge">./</code> and <code class="language-plaintext highlighter-rouge">../</code> directory on the fly</p>
  </li>
</ol>

<ul>
  <li>
    <p>eventually they will call <code class="language-plaintext highlighter-rouge">dir_emit_dot</code> and <code class="language-plaintext highlighter-rouge">dir_emit_dot_dot</code>, the former does:</p>

    <ol>
      <li>
        <p>assigns something to the <code class="language-plaintext highlighter-rouge">ctx</code> field</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">dir_emit_dot</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dir_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 1. assigns something to the `ctx` field */</span>
	<span class="k">return</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">actor</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s">"."</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span>
			  <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
</ul>

<ol>
  <li>
    <p>iterates over the <strong>sub-directories</strong> using <code class="language-plaintext highlighter-rouge">scan_positives</code>, and <strong>show them up using <code class="language-plaintext highlighter-rouge">dir_emit</code></strong></p>

    <ul>
      <li>
        <p>which does:</p>

        <ol>
          <li>
            <p>looking for the <code class="language-plaintext highlighter-rouge">@count</code>-th positive <code class="language-plaintext highlighter-rouge">dentry</code> after the passed in <code class="language-plaintext highlighter-rouge">@p</code>, by iterating over all <code class="language-plaintext highlighter-rouge">sub_dirs</code></p>
          </li>
          <li>
            <p>skip cursors</p>
          </li>
          <li>
            <p>return the found <code class="language-plaintext highlighter-rouge">dentry</code> (i.e. sub-dir) if it is <code class="language-plaintext highlighter-rouge">positive</code></p>

            <ul>
              <li>
                <p>the positive test essentially just does <code class="language-plaintext highlighter-rouge">d_really_is_positive</code>:</p>

                <ol>
                  <li>
                    <p>checks if this <code class="language-plaintext highlighter-rouge">dentry</code> has an <code class="language-plaintext highlighter-rouge">inode</code> or not.</p>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">d_really_is_positive</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>                    </div>
                  </li>
                </ol>
              </li>
            </ul>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">scan_positives</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">cursor</span><span class="p">,</span>
                                     <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
                                     <span class="n">loff_t</span> <span class="n">count</span><span class="p">,</span>
                                     <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span>  <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span> 
            
    <span class="cm">/* 1. iterate over reall subdirs
     * 	   - first (fake) sub_dir is @dentry-&gt;d_subdirs
     *     - next dir to emit is @p-&gt;next, @p starts with ../
     */</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* @d_child = child of parent list */</span>
        <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_child</span><span class="p">);</span>
                
        <span class="c1">// 2. we must at least skip cursors, to avoid livelocks</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_DENTRY_CURSOR</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
                
        <span class="cm">/* 3. spits out REAL directories */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">simple_positive</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!--</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* some code omitted here */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">simple_positive</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                <span class="n">found</span> <span class="o">=</span> <span class="n">dget_dlock</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">found</span><span class="p">))</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
    <span class="n">dput</span><span class="p">(</span><span class="n">last</span><span class="p">);</span> <span class="cm">/* possibly kill previous directory */</span>
    <span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ol>
      </li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">dcache_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dir_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span> <span class="cm">/* current dir */</span>
    <span class="cm">/* 1. gets the cursor */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">cursor</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span> <span class="cm">/* fake sub_dirs */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">anchor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">;</span> <span class="cm">/* real sub_dirs */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
   
    <span class="cm">/* 2. creates the ./ and ../ directory on the fly */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir_emit_dots</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
   
	<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">anchor</span><span class="p">;</span> <span class="cm">/* real sub_dirs */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">d_child</span><span class="p">))</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">d_child</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
   
    <span class="cm">/* 3. dir_emit real @p=anchor directories */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">next</span> <span class="o">=</span> <span class="n">scan_positives</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir_emit</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
			      <span class="n">d_inode</span><span class="p">(</span><span class="n">next</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">dt_type</span><span class="p">(</span><span class="n">d_inode</span><span class="p">(</span><span class="n">next</span><span class="p">))))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">++</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">d_child</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
    <span class="n">dput</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
   
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <h4 id="func-d_alloc_name"><code class="language-plaintext highlighter-rouge">func</code> d_alloc_name()</h4>
  </li>
</ol>

<p>adds a dentry to to the parent, i.e. adds a subdirectory</p>

<p>eventually calls:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">__d_alloc</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="cm">/*
	 * don't need child lock because it is not subject
	 * to concurrency here
	 */</span>
	<span class="n">__dget_dlock</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span> <span class="cm">/* how things are added */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="snippet-sub-dir-iteration"><code class="language-plaintext highlighter-rouge">snippet</code> sub-dir iteration</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span> <span class="cm">/* parent dentry */</span>

<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
<span class="n">cursor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">;</span> <span class="cm">/* start to sub_dir */</span>
<span class="k">while</span> <span class="p">((</span><span class="n">cursor</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* gets the sub_dir dentry and inode */</span>
    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_child</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">d_inode</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li>basically it is stored in the <code class="language-plaintext highlighter-rouge">&amp;dentry-&gt;d_subdirs-&gt;next</code> as a circular linked list</li>
</ul>

<h4 id="snippet-iget_locked"><code class="language-plaintext highlighter-rouge">snippet</code> iget_locked</h4>

<p>basically, this is used to get or create an inode with a specified <code class="language-plaintext highlighter-rouge">ino</code>.</p>

<p>However, if it is a new <code class="language-plaintext highlighter-rouge">inode</code>, there will be a ==lock that you need to release==</p>

<ul>
  <li>see <code class="language-plaintext highlighter-rouge">unlock_new_inode(inode);</code></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">some_function</span><span class="p">()</span>
<span class="p">{</span>
<span class="nl">retry:</span>
	<span class="cm">/* obtains the inode with ino=pid */</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">iget_locked</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
	<span class="cm">/*
	 * if old inode, ...
	 * if new inode, ...
	 * 		and set relevant field
	 */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* old inode */</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
    
    <span class="cm">/* new inode, sets relevant field */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ppagefs_piddir_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ppagefs_piddir_inode_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span>	<span class="o">=</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="mo">0755</span><span class="p">;</span>

	<span class="cm">/* set private data */</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">p_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">retain</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    
	<span class="cm">/* some code omitted here */</span>

	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="snippet-create-filefolder"><code class="language-plaintext highlighter-rouge">snippet</code> create file/folder</h4>

<p>In short, both a file/folder will need a <code class="language-plaintext highlighter-rouge">dentry + inode</code></p>

<p>Therefore, the code is almost the same:</p>

<ol>
  <li>create a <code class="language-plaintext highlighter-rouge">dentry</code> to be associated for the file/folder</li>
  <li>get a new inode
    <ul>
      <li>if we want a file, the <code class="language-plaintext highlighter-rouge">inode</code> should be attached with file related operations</li>
      <li>otherwise, directory related operations</li>
    </ul>
  </li>
  <li>attach the <code class="language-plaintext highlighter-rouge">inode</code> with the <code class="language-plaintext highlighter-rouge">dentry</code></li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dentry</span> <span class="o">=</span> <span class="n">d_alloc_name</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* only difference here is the operations assigned */</span>
<span class="n">inode</span> <span class="o">=</span> <span class="n">ppage_get_inode</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="n">S_IFREG</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">d_add</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
</code></pre></div></div>

<p>and the <strong>creation of <code class="language-plaintext highlighter-rouge">inode</code> is slightly customized to be</strong>:</p>

<ol>
  <li>create a new inode <code class="language-plaintext highlighter-rouge">new_inode()</code></li>
  <li>assign some generic properties</li>
  <li>==only difference== between a file and a folder in <code class="language-plaintext highlighter-rouge">inode</code></li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* generic operations */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">ppage_get_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 2. assign some generic properties */</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">get_next_ino</span><span class="p">();</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">current_time</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

        <span class="cm">/* 3. only difference between a file and a folder in `inode` */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">S_IFDIR</span><span class="p">:</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span>	<span class="o">=</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="mo">0755</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ppagefs_piddir_inode_operations</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ppagefs_piddir_operations</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">S_IFREG</span><span class="p">:</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span>	<span class="o">=</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="mo">0644</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ppagefs_file_inode_operations</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ppagefs_file_operations</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ppagefs_file_inode_operations</span><span class="p">;</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ppagefs_file_operations</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="linux-disk-io">Linux Disk I/O</h3>

<h4 id="func-wakeup_flusher_threads"><code class="language-plaintext highlighter-rouge">func</code> wakeup_flusher_threads()</h4>

<p>This is the mechanism mentioned above where we <strong>periodically flush written data from RAM to Disk</strong>.</p>

<p>One <strong>example</strong> of this is:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ksys_sync</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nowait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wait</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">wakeup_flusher_threads</span><span class="p">(</span><span class="n">WB_REASON_SYNC</span><span class="p">);</span>
	<span class="cm">/* some code omitted here */</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ksys_sync</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li>
    <p>the <code class="language-plaintext highlighter-rouge">sync</code> system call has the description of:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DESCRIPTION
    Synchronize cached writes to persistent storage
    If one or more files are specified, <span class="nb">sync </span>only them, or their containing file systems.
</code></pre></div>    </div>
  </li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>this also means that the <code class="language-plaintext highlighter-rouge">write()</code> system calls actually ==first write to Page Cache of RAM==. Only when it is flushed, it gets to the disk.
      <ul>
        <li>this also means that sometimes, <code class="language-plaintext highlighter-rouge">write()</code> might even be faster than <code class="language-plaintext highlighter-rouge">read()</code></li>
      </ul>
    </li>
    <li>However, it is possible to <strong>implement a file system that writes directly to disk</strong>. An application-side example is the <strong>DBMS</strong>, some of which has its own cache management and disk management mechanism.</li>
  </ul>
</blockquote>

<h4 id="c-fsread_writec"><code class="language-plaintext highlighter-rouge">c</code> fs/read_write.c</h4>

<p>Used for <code class="language-plaintext highlighter-rouge">read/write()</code> system calls</p>

<h5 id="func-ksys_read"><code class="language-plaintext highlighter-rouge">func</code> ksys_read()</h5>

<p>Eventually this gets to <code class="language-plaintext highlighter-rouge">__vfs_read</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ssize_t</span> <span class="nf">__vfs_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
		   <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span> <span class="cm">/* if file system specific has open() */</span>
		<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read_iter</span><span class="p">)</span> <span class="cm">/* if only has read_iter */</span>
		<span class="k">return</span> <span class="n">new_sync_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>and now, in the example of <code class="language-plaintext highlighter-rouge">ramfs</code> (as well as for <code class="language-plaintext highlighter-rouge">ext4</code>, which is the <strong>main file system for regular files</strong>), there is no <code class="language-plaintext highlighter-rouge">read()</code> for a file operation. So we go to <code class="language-plaintext highlighter-rouge">new_sync_read()</code> and does:</p>

<ol>
  <li>
    <p>sets up the starting point of the buffer and the end, where:</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">iov_base</code> is the <strong>starting point/destination to put data to</strong></li>
      <li><code class="language-plaintext highlighter-rouge">iov_len</code> is the <strong>total length to read</strong></li>
    </ul>
  </li>
  <li>
    <p>conglomerate all relevant info from above to a <strong>single</strong> <code class="language-plaintext highlighter-rouge">struct iov_iter iter</code></p>

    <ul>
      <li>e.g. user’s buffer would be there</li>
    </ul>
  </li>
  <li>
    <p>eventually calls the file specific <code class="language-plaintext highlighter-rouge">read_iter</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">new_sync_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">iov_iter</span> <span class="n">iter</span><span class="p">;</span>
    <span class="cm">/* 1. ets up the starting point of the buffer and the end */</span>
    <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">buf</span><span class="p">,</span> <span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span> <span class="p">};</span>
	<span class="cm">/* some code omitted here */</span>
       
    <span class="cm">/* 2. conglomerate all relevant info from above to @iter */</span>
    <span class="n">iov_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="n">READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
   
    <span class="cm">/* 3. calls file specific read_iter */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_read_iter</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kiocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppos</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">kiocb</span><span class="p">.</span><span class="n">ki_pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>for <code class="language-plaintext highlighter-rouge">ramfs</code> as well as <code class="language-plaintext highlighter-rouge">ext4</code>, the <code class="language-plaintext highlighter-rouge">read_iter</code> is a <code class="language-plaintext highlighter-rouge">generic_file_read_iter</code> for <code class="language-plaintext highlighter-rouge">libc</code>, which reads data <strong>from the page cache</strong> (<code class="language-plaintext highlighter-rouge">ramfs</code> ==stores data in page cache==)</p>

    <p>So <code class="language-plaintext highlighter-rouge">genetic_file_read_iter</code> does:</p>

    <ol>
      <li>
        <p>real work occurs in <code class="language-plaintext highlighter-rouge">generic_file_buffered_read</code></p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * This is the "read_iter()" routine for all filesystems
 * that can use the PAGE CACHE directly.
 * Return:
 * * number of bytes copied, even for partial reads
 * * negative error code if nothing was read
 */</span>
<span class="kt">ssize_t</span>
<span class="nf">generic_file_read_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">generic_file_buffered_read</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <p>now, inside <code class="language-plaintext highlighter-rouge">generic_file_buffered_read()</code>, we have:</p>

        <ol>
          <li>
            <p>get an “address space” for a file</p>
          </li>
          <li>
            <p>computes the <strong>address of the <code class="language-plaintext highlighter-rouge">PAGE</code> that we are reading from</strong></p>
          </li>
          <li>
            <p>gets the page from Page Cache using <code class="language-plaintext highlighter-rouge">find_get_page</code></p>

            <ul>
              <li>if we got the <code class="language-plaintext highlighter-rouge">PAGE</code>, then we can read from there</li>
              <li>otherwise, we need to ==read from Disk==, we would go to <code class="language-plaintext highlighter-rouge">page_cache_sync_readahead</code></li>
            </ul>

            <ol>
              <li>
                <p>sets the the Pages we need</p>
              </li>
              <li>
                <p>==submit a Disk I/O request== for reading from Disk, and return</p>

                <ul>
                  <li>some other functions will checks if the allocated Pages are updated (and does some other work/checking). If not updated when checked, it will <strong>then block the process</strong></li>
                </ul>

                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">__do_page_cache_readahead</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
                                       <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">,</span> 
                                       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_read</span><span class="p">,</span>
                                       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lookahead_size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="cm">/* 1. sets the the Pages we need */</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">__page_cache_alloc</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
    <span class="cm">/* 2. submit request to read data from DISK */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span><span class="p">)</span>
        <span class="n">read_pages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_pool</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>                </div>

                <p>where eventually, the <code class="language-plaintext highlighter-rouge">read_pages</code> calls <strong>file system specific <code class="language-plaintext highlighter-rouge">readpages()</code></strong>, in the case of  <code class="language-plaintext highlighter-rouge">ext4</code>, we have the following definition:</p>

                <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">ext4_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">ext4_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">ext4_readpages</span><span class="p">,</span>
    <span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div>                </div>

                <p>so that the <code class="language-plaintext highlighter-rouge">ext4_readpages()</code> gets called and eventually goes to:</p>

                <ol>
                  <li>
                    <p>configures the request.</p>

                    <ul>
                      <li>for example, <code class="language-plaintext highlighter-rouge">bio-&gt;bi_end_io = mpage_end_io;</code> is the <strong>call back</strong> when the I/O completed</li>
                    </ul>
                  </li>
                  <li>
                    <p>submit the request</p>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">ext4_mpage_readpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
                         <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_readahead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">bio_post_read_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
               
        <span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span>
                        <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">BIO_MAX_PAGES</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">set_error_page</span><span class="p">;</span>
        <span class="cm">/* some code omitted here */</span>
               
        <span class="cm">/* 1. configures the request. */</span>
        <span class="n">bio_set_dev</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bdev</span><span class="p">);</span>
        <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_iter</span><span class="p">.</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">blkbits</span> <span class="o">-</span> <span class="mi">9</span><span class="p">);</span>
        <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">mpage_end_io</span><span class="p">;</span> <span class="cm">/* call back */</span>
        <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
        <span class="n">bio_set_op_attrs</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">REQ_OP_READ</span><span class="p">,</span>
                         <span class="n">is_readahead</span> <span class="o">?</span> <span class="n">REQ_RAHEAD</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* 2. submit the request */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">submit_bio</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
        <span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>                    </div>

                    <blockquote>
                      <p><strong>Note</strong></p>

                      <ul>
                        <li>
                          <p>What happens to the request then? There will be a queue for the I/O request, and some <strong>scheduling done on the submitted requests</strong>, to do:</p>

                          <ol>
                            <li>==merge the requests== if possible
                              <ul>
                                <li>if the contents to be read is contiguous for two requests</li>
                              </ul>
                            </li>
                            <li>if not, ==sort the requests==
                              <ul>
                                <li>if the contents to be read is close to each other but not contiguous, <strong>put/sort  the two requests close to each other</strong> (so I can handle nearby requests)</li>
                                <li>then, you also have to solve the problem of ==starvation==</li>
                              </ul>
                            </li>
                          </ol>

                          <p>the aim is to make <strong>disk arm to be more efficient</strong>, because seek takes time on the Disk!</p>
                        </li>
                      </ul>
                    </blockquote>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>
            <p>Now we would <em>most likely</em> have the pages ready.</p>
          </li>
          <li>
            <p>However, since the I/O request is async, we need to know if the <strong>Page is up-to-date</strong>.</p>

            <ul>
              <li>
                <p>if not, <code class="language-plaintext highlighter-rouge">wait_on_page_locked_killable</code>, which eventually goes to <code class="language-plaintext highlighter-rouge">wait_on_page_bit_common</code>:</p>

                <ol>
                  <li>
                    <p>configures the wait queue for this <strong>process</strong> (until the Disk I/O we needed is done)</p>
                  </li>
                  <li>
                    <p>sleep it by setting its state and call <code class="language-plaintext highlighter-rouge">io_schedule()</code></p>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">wait_on_page_bit_common</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit_nr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="k">enum</span> <span class="n">behavior</span> <span class="n">behavior</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">init_wait</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">wait</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">behavior</span> <span class="o">==</span> <span class="n">EXCLUSIVE</span> <span class="o">?</span> <span class="n">WQ_FLAG_EXCLUSIVE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wait</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">wake_page_function</span><span class="p">;</span>
	<span class="n">wait_page</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">wait_page</span><span class="p">.</span><span class="n">bit_nr</span> <span class="o">=</span> <span class="n">bit_nr</span><span class="p">;</span>
              
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/* some code omitted here */</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
              
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
              
		<span class="n">bit_is_set</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">bit_nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">behavior</span> <span class="o">==</span> <span class="n">DROP</span><span class="p">)</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
                      
		<span class="cm">/* 2. sleep it by setting its state and call `io_schedule()` */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">bit_is_set</span><span class="p">))</span>
			<span class="n">io_schedule</span><span class="p">();</span> 
    <span class="p">}</span>
              
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>                    </div>

                    <blockquote>
                      <p><strong>Note</strong></p>

                      <ul>
                        <li>
                          <p>eventually, someone has to wake this process up. This is done by the <strong>call back function</strong> configured while we submitted the <code class="language-plaintext highlighter-rouge">bio</code> request:</p>

                          <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">mpage_end_io</span><span class="p">;</span> <span class="cm">/* call back */</span>
</code></pre></div>                          </div>

                          <p>which would happen when ==disk i/O request is completed==. Then it would go to <code class="language-plaintext highlighter-rouge">__read_end_io</code>, which would:</p>

                          <ol>
                            <li>
                              <p>sets the Page to be <strong>up-to-date</strong></p>
                            </li>
                            <li>
                              <p>unlocks the page via <code class="language-plaintext highlighter-rouge">unlock_page</code> and wakes the process up</p>

                              <ul>
                                <li>
                                  <p>this will go to <code class="language-plaintext highlighter-rouge">wake_up_page_bit()</code>, then to <code class="language-plaintext highlighter-rouge">__wake_up_locked_key_bookmark</code>, and finally ==wakes the process up==</p>

                                  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">__wake_up_locked_key_bookmark</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> 
    <span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">bookmark</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__wake_up_common</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">bookmark</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>                                  </div>
                                </li>
                              </ul>

                              <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">__read_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bvec_iter_all</span> <span class="n">iter_all</span><span class="p">;</span>
          
	<span class="n">bio_for_each_segment_all</span><span class="p">(</span><span class="n">bv</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">iter_all</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_status</span> <span class="o">||</span> <span class="n">PageError</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* some code omitted here */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* 1. sets the Page to be **up-to-date** */</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
        <span class="cm">/* 2. unlocks the page via `unlock_page` 
         * and wakes the process up
         */</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">,</span> <span class="n">bio_post_read_ctx_pool</span><span class="p">);</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>                              </div>
                            </li>
                          </ol>
                        </li>
                      </ul>
                    </blockquote>
                  </li>
                </ol>
              </li>
            </ul>
          </li>
          <li>
            <p>At this point, the Page will be <strong>up-to-date</strong>, and we ==finally can read/copy data to user’s buffer==</p>

            <ul>
              <li>
                <p>eventually, if we are not dealing with pipes, this will go to ` copy_page_to_iter_iovec<code class="language-plaintext highlighter-rouge"> and then </code>copyout`</p>

                <ol>
                  <li>
                    <p>this basically <strong>copies data back</strong> to user</p>

                    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">copyout</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">access_ok</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kasan_check_read</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">raw_copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>                    </div>
                  </li>
                </ol>
              </li>
            </ul>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">generic_file_buffered_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
                                          <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">written</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 1. get an "address space" for a file */</span>
    <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
         
    <span class="cm">/* 2. gets the page number, i.e. which PAGE I am reading */</span>
    <span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
         
<span class="nl">find_page:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
         
    <span class="cm">/* 3. gets the page from Page Cache using `find_get_page` */</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_NOWAIT</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">would_block</span><span class="p">;</span>
        <span class="n">page_cache_sync_readahead</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
                                  <span class="n">ra</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span>
                                  <span class="n">index</span><span class="p">,</span> <span class="n">last_index</span> <span class="o">-</span> <span class="n">index</span><span class="p">);</span>
        <span class="cm">/* 4. Now we would *most likely* have the pages ready */</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
            <span class="k">goto</span> <span class="n">no_cached_page</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* some code omitted here */</span>
         
			<span class="cm">/* 5. if not up-to-date */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">wait_on_page_locked_killable</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="p">}</span>
<span class="nl">page_ok:</span>
    <span class="cm">/* some code omitted here */</span>
    <span class="cm">/* 6. now we can copy it to user space... recall @iter contains user's buffer */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">copy_page_to_iter</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
    <span class="n">offset</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
    <span class="n">offset</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
    <span class="n">prev_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
         
    <span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h1 id="week-11---io-system">Week 11 - I/O System</h1>

<p>The <strong>basic hardware elements</strong> involved in I/O are:</p>

<ul>
  <li>buses</li>
  <li>device controllers</li>
  <li>devices themselves</li>
  <li>CPU/DMA to move data around</li>
</ul>

<p>The work of <strong>moving data between devices and main memory</strong> is performed by</p>

<ul>
  <li>the CPU as programmed I/O</li>
  <li>or is offloaded to a DMA controller.</li>
</ul>

<blockquote>
  <p><strong>Device Drivers</strong></p>

  <ul>
    <li>To encapsulate the <strong>details and oddities of different devices</strong> for their ports, controllers, and etc, the kernel of an operating system is structured to use ==device-driver modules==.</li>
    <li>The device drivers present:
      <ul>
        <li>a <strong>uniform device access interface</strong> to the I/O subsystem, e.g. a keyboard (similar to system calls).</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h2 id="io-hardware">I/O Hardware</h2>

<p>Some important hardware elements are:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-14_17-05-15.png" style="zoom:67%;" /></p>

<ul>
  <li>==Port== - device communicates with the machine via a <strong>connection point</strong>, or port
    <ul>
      <li>for example, a serial port</li>
    </ul>
  </li>
  <li>==Bus==: set of <strong>wires</strong> and a rigidly defined <strong>protocol</strong> that specifies a set of <strong>messages that can be sent on the wires</strong>.</li>
  <li>==Controller==: A controller is a collection of electronics that can <strong>operate</strong> a port, a bus, or a device
    <ul>
      <li>i.e. CPU gives data and commands to controller, then <em>controller actually operates</em> on that device</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p><strong>Communication to Controller</strong></p>

  <ul>
    <li>CPU can send data and commands to the controller in two ways:
      <ol>
        <li><strong>Controller</strong> has <strong>one or more registers</strong> for data and control signals, so CPU transfer of a byte or word to an <strong>I/O port</strong>
address.</li>
        <li>Alternatively, the device <strong>controller</strong> can support <strong>memory-mapped I/O</strong>. In this case, the device-control registers are <strong>mapped into</strong> the <em>address space of the processor.</em>
          <ul>
            <li>communications occur by reading and writing directly to/from those memory areas.</li>
          </ul>
        </li>
      </ol>
    </li>
  </ul>
</blockquote>

<h3 id="io-port-communication">I/O Port Communication</h3>

<p>If we are writing data/communicating via the I/O port, then the following happens</p>

<blockquote>
  <p>**Registers in I/O Port **</p>

  <ul>
    <li>An I/O port typically consists of four registers, called the <strong>status</strong>, <strong>control</strong>, <strong>data-in</strong>, and <strong>data-out</strong> registers
      <ul>
        <li>The ==data-in register== is <strong>read by the host</strong> to get input.</li>
        <li>The ==data-out register== is <strong>written by the host</strong> to send output.</li>
        <li>The ==status register== contains bits that can be read by the host. These bits indicate states, such as whether the <strong>current command has completed</strong>, whether a byte is available to be read from the data-in register, and whether a device error has occurred.</li>
        <li>The ==control register== can be written by the host to <strong>start a command</strong> or to change the mode of a device.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h4 id="polling-io">Polling I/O</h4>

<blockquote>
  <p><strong>Communication Between CPU and Device using I/O Port</strong></p>

  <ol>
    <li>The <strong>host</strong> repeatedly reads the <code class="language-plaintext highlighter-rouge">busy</code> bit in ==status register== until that bit becomes <strong>clear</strong>.
      <ul>
        <li>CPU busy waiting/polling</li>
      </ul>
    </li>
    <li>The <strong>host sets</strong> the <code class="language-plaintext highlighter-rouge">write</code> bit in the ==command register== and <strong>writes</strong> a byte into the ==data-out register==.</li>
    <li>The <strong>host sets</strong> the command-ready bit.</li>
    <li>When the <strong>controller</strong> notices that the command-ready bit is set, it sets the <code class="language-plaintext highlighter-rouge">busy</code> bit.</li>
    <li>The <strong>controller</strong> reads the ==command register== and sees the write command. It reads the ==data-out register== to get the byte and does the I/O to the device.</li>
    <li>The <strong>controller clears</strong> the command-ready bit, clears the error bit in the ==status register== to indicate that the device I/O succeeded, and clears the <code class="language-plaintext highlighter-rouge">busy</code> bit to indicate that it is finished.</li>
  </ol>
</blockquote>

<p><strong>Disadvantage</strong>:</p>

<ul>
  <li>in step 1, the host is ==busy-waiting or polling==: it is in a loop, reading the status register over and over until the busy bit becomes clear. Suitable for <strong>data that needs to be serviced quickly</strong>, but not suitable for <strong>long waits</strong>.</li>
</ul>

<h4 id="interrupt-driven-io">Interrupt Driven I/O</h4>

<p>The mechanism is as follows:</p>

<p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-14_17-23-57.png" style="zoom:67%;" /></p>

<p>where:</p>

<ul>
  <li>device driver (kernel) has nothing to do with device controller (hardware)</li>
  <li>this is the ==interrupt== mechanism we discussed in the very beginning of course</li>
</ul>

<p>In summary, interrupts are used throughout modern operating systems to handle <strong>asynchronous</strong> events and to trap to supervisor-mode routines in the kernel.</p>

<h3 id="direct-memory-access">Direct Memory Access</h3>

<p>This is the case when we have <strong>large amount of data transfer</strong>. We don’t want ==CPU transferring data in and out of registers one byte at a time.==</p>

<ul>
  <li>uses a DMA Controller (a <strong>special processor</strong>)
    <ul>
      <li>and a DMA block</li>
    </ul>
  </li>
  <li>uses Interrupt-driven I/O</li>
</ul>

<blockquote>
  <p><strong>Note</strong></p>

  <ul>
    <li>This has ==nothing== to do with Memory Mapped I/O.</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Components for DMA</strong></p>

  <ul>
    <li>a special-purpose ==processor== called a ==direct-memory-access (DMA) controller==</li>
    <li>a ==DMA command block== which contains
      <ul>
        <li>a pointer to the source of a transfer,</li>
        <li>a pointer to the destination of the transfer,</li>
        <li>a count of the number of bytes to be transferred.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>Mechanism of DMA</strong></p>

  <ol>
    <li>
      <p>To initiate a DMA transfer, the host writes a DMA command block into <strong>memory</strong></p>

      <ul>
        <li>contains the pointer to source of transfer, etc.</li>
      </ul>
    </li>
    <li>
      <p>CPU writes the <strong>address</strong> of this command block <strong>to the DMA controller</strong></p>
    </li>
    <li>
      <p>The <strong>DMA controller</strong> proceeds to <strong>operate</strong> the memory bus directly</p>
    </li>
    <li>
      <p>While the <strong>DMA transfer</strong> is going on the ==CPU does not have access to the PCI bus== ( including main memory ), but it does have access to its internal registers and primary and secondary caches</p>
    </li>
    <li>
      <p>When the entire transfer is finished, the DMA controller <strong>interrupts</strong> the CPU</p>

      <p><img src="D:\Dropbox\SEAS2020\Spring Semester\OS I\notes\images\Snipaste_2021-04-14_17-30-20.png" style="zoom:67%;" /></p>
    </li>
  </ol>
</blockquote>

<h2 id="kernel-io-subsystem">Kernel I/O Subsystem</h2>

<h3 id="buffering">Buffering</h3>

<p>A buffer, of course, is a memory area that <strong>stores data being transferred</strong> between two devices or between a device and an application</p>

<blockquote>
  <p><strong>When Buffering is Used</strong></p>

  <ol>
    <li>One reason is to cope with a ==speed mismatch== between the producer and consumer of a data stream.
      <ul>
        <li><em>for example</em>, that a file is being received via modem for storage on the hard disk. The modem is about a thousand
times slower than the hard disk. So a buffer is created in main memory to <strong>accumulate the bytes received from the modem</strong>. When an entire buffer of data has arrived, the buffer can be written to disk in a single operation.</li>
      </ul>
    </li>
    <li>A second use of buffering is to provide adaptations for devices that have ==different data-transfer sizes==.
      <ul>
        <li>in computer networking, where buffers are used widely for <strong>fragmentation</strong> and <strong>reassembly of messages.</strong></li>
      </ul>
    </li>
    <li>A third use of buffering is to support ==copy semantics for application I/O.==
      <ul>
        <li>for example, at <code class="language-plaintext highlighter-rouge">t=0</code> you issued <code class="language-plaintext highlighter-rouge">write()</code> with some data in your buffer to send to disk. But before the data is actually written to disk, you <strong>changed your data</strong>. Copy semantics ensured data written is at the time of submission (<code class="language-plaintext highlighter-rouge">t=0</code>).</li>
      </ul>
    </li>
  </ol>
</blockquote>

<h3 id="caching">Caching</h3>

<p>The difference between cache and buffer is that:</p>

<ul>
  <li>buffer may hold the only existing copy of a data item,</li>
  <li>a cache, by definition, holds a <strong>copy</strong> on faster storage of an item that resides elsewhere.</li>
</ul>

<blockquote>
  <p><strong>Caching</strong></p>

  <ul>
    <li>we basically encountered this already, where we have a ==page cache== for <code class="language-plaintext highlighter-rouge">read()</code>, and also for buffering<code class="language-plaintext highlighter-rouge">write</code> to be flushed to disk as one unit</li>
  </ul>
</blockquote>

<h3 id="spooling">Spooling</h3>

<p>Spooling works like a typical <strong>request queue</strong> where data, instructions and processes from multiple sources are accumulated for execution later on.</p>

<ul>
  <li>SPOOL is an acronym for <strong>simultaneous peripheral operations on-line</strong>. It is a kind of buffering mechanism or a process in which data is temporarily held to be used and executed by a device, program or the system.</li>
</ul>

<blockquote>
  <p><strong>Characteristics of Spooling</strong></p>

  <ul>
    <li>buffers data for ( peripheral ) devices such as printers that cannot support interleaved data streams.
      <ul>
        <li>i.e. cannot print half of the file, and then skip to another file</li>
      </ul>
    </li>
    <li>If multiple processes want to <strong>print at the same time</strong>
      <ol>
        <li>they each send their print data to files <strong>stored in the spool directory.</strong></li>
        <li>When each file is closed, then the application sees that print job as complete, and the <strong>print scheduler sends</strong> each file to the appropriate printer one at a time for <strong>execution</strong></li>
      </ol>
    </li>
  </ul>
</blockquote>

<p>Implementation of Spooling</p>

<ol>
  <li>The spooling system copies the queued spool files to the printer one at a time. In some operating systems, spooling is managed by a system <strong>daemon process</strong>. In others, it is handled by an <strong>in-kernel thread</strong>.</li>
  <li>Provide explicit facilities for coordination. Some operating systems (including VMS) provide support for exclusive device access
by enabling a process to <strong>allocate an idle device</strong> and to <strong>deallocate that device when it is no longer needed</strong></li>
</ol>

<h1 id="useful-kernel-data-structures">Useful Kernel Data Structures</h1>

<h2 id="tips-of-c-programming-in-kernel">Tips of C Programming in Kernel</h2>

<p>Since there are no standard C library provided in kernel, you should know the <strong>kernel alternatives/implemented</strong></p>

<p><strong><em>Functions</em></strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">printk</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">printk(KERN_INFO "Message: %s\n", arg);</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">kmalloc</code>
    <ul>
      <li>the flag you should often use is <code class="language-plaintext highlighter-rouge">GFP_KERNEL</code></li>
      <li>from the library <code class="language-plaintext highlighter-rouge">linux/slab.h</code></li>
    </ul>
  </li>
</ul>

<p><strong><em>Structures</em></strong></p>

<ul>
  <li>Linked List <code class="language-plaintext highlighter-rouge">include/linux/list.h</code></li>
</ul>

<h2 id="defining-system-calls">Defining System Calls</h2>

<p>Essentially, to build a system call, you would need to:</p>

<ol>
  <li>Configure it in Kernel Files</li>
  <li>Program your System Call in the right Format</li>
  <li>After compiling your file, <em>use</em> the system call with <code class="language-plaintext highlighter-rouge">syscall()</code></li>
</ol>

<p>So, first, to <strong>configure it in the right places</strong>:</p>

<ol>
  <li>
    <p>Configuration in system table <code class="language-plaintext highlighter-rouge">arch/x86/entry/syscalls/sysycall_64.tbl</code></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">436</span>     <span class="n">common</span>	<span class="n">pstrace_enable</span>		<span class="n">__x64_sys_pstrace_enable</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Add header files if needed inside <code class="language-plaintext highlighter-rouge">include/linux/xxx.h</code></p>
  </li>
  <li>
    <p>Put your code in <code class="language-plaintext highlighter-rouge">kernel/xxx.c</code> and wrap your code like this:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/syscalls.h&gt;</span><span class="cp">
</span>   
<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">pstrace_get</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pstrace</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Add your <code class="language-plaintext highlighter-rouge">.c</code> file to the <code class="language-plaintext highlighter-rouge">Makefile</code> of kernel</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">obj</span><span class="o">-</span><span class="n">y</span>     <span class="o">=</span> <span class="n">fork</span><span class="p">.</span><span class="n">o</span> <span class="n">exec_domain</span><span class="p">.</span><span class="n">o</span> <span class="n">panic</span><span class="p">.</span><span class="n">o</span> \
	    <span class="n">cpu</span><span class="p">.</span><span class="n">o</span> <span class="n">exit</span><span class="p">.</span><span class="n">o</span> <span class="n">softirq</span><span class="p">.</span><span class="n">o</span> <span class="n">resource</span><span class="p">.</span><span class="n">o</span> \
	    <span class="cm">/* some code omitted here */</span>
	    <span class="n">pstrace</span><span class="p">.</span><span class="n">o</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>then, to <strong>program your code with right style</strong>:</p>
  </li>
</ol>

<ul>
  <li>
    <p>careful of copying <em>to and from</em> users</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">pstrace_get</span><span class="p">,</span> <span class="n">pid_t</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pstrace</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">kcounter</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pstrace</span> <span class="o">*</span><span class="n">kbuf</span><span class="p">;</span>
  
    <span class="n">kbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pstrace</span><span class="p">)</span> <span class="o">*</span> <span class="n">PSTRACE_BUF_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kbuf</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
  
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kcounter</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
  
    <span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
    <span class="cm">/* do some tasklist related stuff */</span>
  
    <span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
  
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">kbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pstrace</span><span class="p">)</span> <span class="o">*</span> <span class="n">cp_count</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">kbuf</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">kfree</span><span class="p">(</span><span class="n">kbuf</span><span class="p">);</span>
  
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>use available kernel functions if there is</p>

    <ul>
      <li>the trick here is to think:
        <ol>
          <li>is there a <em>user function/C library</em> function that does this? e.g. <code class="language-plaintext highlighter-rouge">getpid()</code></li>
          <li>look for the kernel files, see what is <em>beneath</em> <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINE0(getpid)</code></li>
        </ol>
      </li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* instead of tsk-&gt;pid */</span>
<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">getpid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_tgid_vnr</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<ol>
  <li>
    <p>Finally, to use the system calls:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>   
<span class="n">ret</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">__NR_SYSCALL_PSTRACE_ENABLE</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"err: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>More details on <code class="language-plaintext highlighter-rouge">copy_to_user</code> and the other ones:</p>

<blockquote>
  <p><strong>Copy Data to/from Kernel</strong></p>

  <table>
    <thead>
      <tr>
        <th><strong>Function</strong></th>
        <th><strong>Description</strong></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code class="language-plaintext highlighter-rouge">copy_from_user(to, from, n)</code> _copy_from_user</td>
        <td>Copies a string of n bytes from <code class="language-plaintext highlighter-rouge">from</code> (user space) to <code class="language-plaintext highlighter-rouge">to</code> (kernel space).</td>
      </tr>
      <tr>
        <td><code class="language-plaintext highlighter-rouge">get_user(type *to, type* ptr)</code> _get_user</td>
        <td>Reads a simple variable (char, long, … ) from <code class="language-plaintext highlighter-rouge">ptr to</code>; depending on pointer type, the kernel decides automatically to transfer 1, 2, 4, or 8 bytes.</td>
      </tr>
      <tr>
        <td><code class="language-plaintext highlighter-rouge">put_user(type *from, type *to)</code> _put_user</td>
        <td>Copies a simple value from <code class="language-plaintext highlighter-rouge">from</code> (kernel space) to <code class="language-plaintext highlighter-rouge">to</code> (user space); the relevant value is determined automatically from the pointer type passed.</td>
      </tr>
      <tr>
        <td><code class="language-plaintext highlighter-rouge">copy_to_user(to, from, n)</code> _copy_to_user</td>
        <td>Copies n bytes from <code class="language-plaintext highlighter-rouge">from</code> (kernel space) to <code class="language-plaintext highlighter-rouge">to</code> (user space).</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h2 id="defining-compilation-modules">Defining Compilation Modules</h2>

<p>This example talks about the homework of building and compiling your own file system</p>

<p>inside <code class="language-plaintext highlighter-rouge">fs/ppagefs</code></p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># SPDX-License-Identifier: GPL-2.0-only
</span><span class="nv">ppagefs-objs</span>	<span class="o">:=</span> inode.o file.o pagewalk.o

<span class="nv">obj-y</span>		<span class="o">+=</span> ppagefs.o
</code></pre></div></div>

<p>then in <code class="language-plaintext highlighter-rouge">fs/Makefile</code></p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># SPDX-License-Identifier: GPL-2.0
#
# Makefile for the Linux filesystems.
#
# 14 Sep 2000, Christoph Hellwig &lt;hch@infradead.org&gt;
# Rewritten to use lists instead of if-statements.
</span>
<span class="c"># some code omitted here
</span><span class="nv">obj-$(CONFIG_SQUASHFS)</span>		<span class="o">+=</span> squashfs/
<span class="nv">obj-y</span>				<span class="o">+=</span> ramfs/
<span class="nv">obj-y</span>				<span class="o">+=</span> ppagefs/ <span class="c"># added</span>
</code></pre></div></div>

<h2 id="linked-list-in-kernel">Linked List in Kernel</h2>

<p>Kernel uses this approach:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">list_head</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* this part is made up */</span>
<span class="k">struct</span> <span class="n">my_list_node</span><span class="p">{</span>
    <span class="n">sturct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>this means that, to traverse between members:</p>

<ul>
  <li>traverse <code class="language-plaintext highlighter-rouge">list_head</code></li>
</ul>

<p>To <strong>get the <code class="language-plaintext highlighter-rouge">my_list_node</code> structure back</strong> for <code class="language-plaintext highlighter-rouge">int data</code> from <code class="language-plaintext highlighter-rouge">list_head</code>:</p>

<ul>
  <li><em>subtract the offset from the address of <code class="language-plaintext highlighter-rouge">list_head</code></em> to get the address of <code class="language-plaintext highlighter-rouge">my_list_node</code>
    <ul>
      <li>in the above example, the <em>address of <code class="language-plaintext highlighter-rouge">my_list_node</code></em> containing the <code class="language-plaintext highlighter-rouge">list_head</code> will be the <em>same address</em> than <code class="language-plaintext highlighter-rouge">list_head</code></li>
    </ul>
  </li>
  <li>in kernel, this function is the <code class="language-plaintext highlighter-rouge">list_entry()</code> or<code class="language-plaintext highlighter-rouge">container_of()</code> function</li>
</ul>

<blockquote>
  <p><strong>Advantage of this</strong></p>

  <ul>
    <li>This essentially abstracted the fact that, for any kind of list that needs a <code class="language-plaintext highlighter-rouge">link_head</code>, it can <em>reuse</em> this <code class="language-plaintext highlighter-rouge">struct</code></li>
  </ul>
</blockquote>

<hr />

<p><strong>Defining a Linked List</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">fox</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tail_length</span><span class="p">;</span> 
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">weight</span><span class="p">;</span> 
    <span class="n">bool</span> <span class="n">is_fantastic</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span> <span class="cm">/* list of all fox structures */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fox</span> <span class="o">*</span><span class="n">red_fox</span><span class="p">;</span>
<span class="n">red_fox</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">red_fox</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="n">red_fox</span><span class="o">-&gt;</span><span class="n">tail_length</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>
<span class="n">red_fox</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="n">red_fox</span><span class="o">-&gt;</span><span class="n">is_fantastic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="cm">/* initializes the wiring */</span>
<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">red_fox</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
</code></pre></div></div>

<hr />

<p><strong>Head Node</strong></p>

<p>Optionally, you can also define a <em>sentinel head node</em></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">fox_list</span><span class="p">);</span> <span class="cm">/*  defines and initializes a named list. */</span>
</code></pre></div></div>

<p>which basically does:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">struct list_head name = LIST_HEAD_INIT(name)</code></li>
</ul>

<hr />

<p><strong>Adding to a Linked List</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="n">list_add_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
</code></pre></div></div>

<p><em>for example</em></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fox_list</span><span class="p">);</span>
</code></pre></div></div>

<hr />

<p><strong>Deleting from a Linked List</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="cm">/* This function removes the element entry from the list. */</span>
</code></pre></div></div>

<ul>
  <li>This only de-wires, but <em>does not free the memory</em></li>
  <li>after calling this, you would typically destroy your data structure and the list_head inside it.</li>
</ul>

<p><em>For Example</em>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span> <span class="cm">/* removes f from the list */</span>
</code></pre></div></div>

<hr />

<p><strong>Iterating through a Linked List</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* recall
struct fox {
    unsigned long tail_length; 
    unsigned long weight; 
    bool is_fantastic; 
    struct list_head list;
};

and that
LIST_HEAD(fox_list);
*/</span>

<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">fox</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
<span class="n">list_for_each</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fox_list</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* f points to the structure in which the list is embedded */</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fox</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<p><strong>Simplified Iteration/Traversing</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">member</span><span class="p">)</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">pos</code> is a pointer to the <strong>object</strong> containing the <code class="language-plaintext highlighter-rouge">list_head</code> nodes. Think of it as the return value from <code class="language-plaintext highlighter-rouge">list_entry()</code></li>
  <li><code class="language-plaintext highlighter-rouge">head</code> is a pointer to the <code class="language-plaintext highlighter-rouge">list_head</code> head node</li>
</ul>

<p><em>For Example</em></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">inotify_watch</span> <span class="o">*</span><span class="nf">inode_find_handle</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
                                               <span class="k">struct</span> <span class="n">inotify_handle</span> <span class="o">*</span><span class="n">ih</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* not list_head any more */</span>
    <span class="k">struct</span> <span class="n">inotify_watch</span> <span class="o">*</span><span class="n">watch</span><span class="p">;</span>
    <span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">watch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">inotify_watches</span><span class="p">,</span> <span class="n">i_list</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">watch</span><span class="o">-&gt;</span><span class="n">ih</span> <span class="o">==</span> <span class="n">ih</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">watch</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<p><strong>Iterating and removing from a Linked List</strong></p>

<p>Now, you need to use:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">member</span><span class="p">);</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li>use this version in the same manner as <code class="language-plaintext highlighter-rouge">list_for_each_entry()</code>, except that you <em>provide the <code class="language-plaintext highlighter-rouge">next</code> pointer</em>, which is of the <em>same type</em> as <code class="language-plaintext highlighter-rouge">pos</code></li>
  <li>again, <code class="language-plaintext highlighter-rouge">pos</code> is a pointer to the <strong>object</strong> containing the <code class="language-plaintext highlighter-rouge">list_head</code> nodes. Think of it as the return value from <code class="language-plaintext highlighter-rouge">list_entry()</code></li>
</ul>

<p><em>For Example</em></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">inotify_inode_is_dead</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">inotify_watch</span> <span class="o">*</span><span class="n">watch</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">inotify_mutex</span><span class="p">);</span>
    <span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">watch</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">inotify_watches</span><span class="p">,</span> <span class="n">i_list</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">inotify_handle</span> <span class="o">*</span><span class="n">ih</span> <span class="o">=</span> <span class="n">watch</span><span class="o">-&gt;</span><span class="n">ih</span><span class="p">;</span>
        <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">inotify_remove_watch_locked</span><span class="p">(</span><span class="n">ih</span><span class="p">,</span> <span class="n">watch</span><span class="p">);</span> <span class="cm">/* deletes watch */</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ih</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">inotify_mutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h2 id="red-black-tree-in-kernel">Red Black Tree in Kernel</h2>

<p>All we need to start with it having a root:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/rbtree.h&gt;</span><span class="cp">
</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="n">the_root</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
</code></pre></div></div>

<p>where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RB_ROOT</code> basically expands to initializing to <code class="language-plaintext highlighter-rouge">{ NULL, }</code></li>
</ul>

<p>Then, to get the <strong>container</strong> from the <code class="language-plaintext highlighter-rouge">pointer</code> to <code class="language-plaintext highlighter-rouge">rb_node</code>, use:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rb_entry</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">member</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="insert">Insert</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">pfn_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">node</span><span class="p">;</span> <span class="cm">/* for rb tree */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pfn_rb_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">expose_count_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="k">struct</span> <span class="n">va_info</span> <span class="o">*</span><span class="n">lst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lst</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
    <span class="cm">/* new data */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_pfn</span> <span class="o">=</span> <span class="n">lst</span><span class="o">-&gt;</span><span class="n">new_pfn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pfn_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="cm">/* Go to the bottom of the tree */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pfn_node</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">==</span> <span class="n">new_pfn</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span> <span class="cm">/* duplicate */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">&gt;</span> <span class="n">new_pfn</span><span class="p">)</span>
			<span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pfn_node</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">new_pfn</span><span class="p">;</span>
    <span class="cm">/* Put the new node there */</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">lst</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>

	<span class="cm">/* some code omitted here */</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="traverse-and-free-the-tree">Traverse and Free the Tree</h3>

<p>Idea of DFS traversal with <em>iterative version</em>:</p>

<ol>
  <li>Create an empty stack <code class="language-plaintext highlighter-rouge">S</code>.</li>
  <li>Initialize current node as root</li>
  <li>Push the current node to S and set current = current-&gt;left until current is NULL</li>
  <li>If current is NULL and stack is not empty then
    <ol>
      <li>Pop the top item from stack.</li>
      <li>Print the popped item, set current = popped_item-&gt;right</li>
      <li>Go to step 3.</li>
    </ol>
  </li>
  <li>If current is NULL and stack is empty then we are done</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">free_pfn_rb_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">stack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_rb_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">)</span> <span class="cm">/* by default, an empty rb-tree has root-&gt;rb_note = NULL */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* clone a root for freeing */</span>
	<span class="n">curr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_node</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>

    <span class="cm">/* iterative DFS */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 1. walk left continuously */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_rb_node</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
			<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">rb</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stack</span><span class="p">);</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* 2. on leaf node, go to the right */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">list_last_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stack</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_rb_node</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
                <span class="cm">/* 2. moves to the right */</span>
				<span class="n">curr</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span> <span class="c1">//pop</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span> <span class="c1">// removes left most</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* 5. stack empty, done */</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="hashmap-in-kernel">HashMap in Kernel</h2>

<h1 id="useful-things-to-know">Useful Things to Know</h1>

<h2 id="setting-up-serial-log-for-vm">Setting up Serial Log for VM</h2>

<p>In general:</p>

<p>Also here are some general debugging tips:</p>

<ol>
  <li>
    <p>Enable kernel debugging:</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">make</span> <span class="n">menuconfig</span>
   
<span class="n">Go</span> <span class="n">to</span> <span class="n">Kernel</span> <span class="n">hacking</span> <span class="o">-&gt;</span> <span class="n">Compile</span><span class="o">-</span><span class="n">time</span> <span class="n">checks</span> <span class="n">and</span> <span class="n">compiler</span> <span class="n">options</span> <span class="o">-&gt;</span> <span class="n">Compile</span> <span class="n">the</span> <span class="n">kernel</span> <span class="n">with</span> <span class="n">debug</span> <span class="n">info</span>
   
<span class="n">Press</span> <span class="s">"/"</span> <span class="n">to</span> <span class="n">enter</span> <span class="n">search</span> <span class="n">mode</span>
<span class="n">Type</span> <span class="s">"RANDOMIZE"</span>
<span class="n">Press</span> <span class="s">"1"</span> <span class="n">to</span> <span class="n">choose</span> <span class="s">"RANDOMIZE_BASE"</span>
<span class="n">Press</span> <span class="s">"n"</span> <span class="n">to</span> <span class="n">diable</span> <span class="n">it</span>
<span class="n">Choose</span> <span class="s">"Exit"</span> <span class="n">once</span>
   
<span class="n">Press</span> <span class="s">"/"</span> <span class="n">to</span> <span class="n">enter</span> <span class="n">search</span> <span class="n">mode</span>
<span class="n">Type</span> <span class="s">"RANDOMIZE"</span>
<span class="n">Press</span> <span class="s">"2"</span> <span class="n">to</span> <span class="n">choose</span> <span class="s">"RANDOMIZE_MEMORY"</span>
<span class="n">Press</span> <span class="s">"n"</span> <span class="n">to</span> <span class="n">diable</span> <span class="n">it</span>
   
<span class="n">Choose</span> <span class="s">"Exit"</span> <span class="n">until</span> <span class="n">save</span> <span class="n">and</span> <span class="n">exit</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Enable debugging for spinlock(see <a href="https://elixir.bootlin.com/linux/v5.4/source/kernel/locking/spinlock_debug.c#L112">here</a>):</p>
  </li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">make</span> <span class="n">menuconfig</span>
   
   <span class="n">Press</span> <span class="s">"/"</span> <span class="n">to</span> <span class="n">enter</span> <span class="n">search</span> <span class="n">mode</span>
   <span class="n">Type</span> <span class="s">"DEBUG_SPIN"</span>
   <span class="n">Press</span> <span class="s">"1"</span>
   <span class="n">Press</span> <span class="s">"y"</span> <span class="n">to</span> <span class="n">enable</span> <span class="n">spinlock</span> <span class="n">debugging</span>
</code></pre></div></div>

<ol>
  <li>
    <p>Attach a serial console to your VM</p>

    <p>Go to setting for the VM -&gt; Add Device -&gt; Serial Port -&gt; Choose a place to put the log(if you are using macOS, you can save it with .log extended name and use application “Console” to monitor it in realtime)</p>
  </li>
  <li>
    <p>When you suspect you are in a deadlock, check the serial port log to see if there’s something printed out.</p>
  </li>
</ol>

<blockquote>
  <p><strong>Note</strong></p>

  <ol>
    <li><code class="language-plaintext highlighter-rouge">make w4118_defconfig</code> then follow Xuheng’s instruction. Most importantly, don’t forget to do this first during menuconfig <code class="language-plaintext highlighter-rouge">Go to Kernel hacking -&gt; Compile-time checks and compiler options -&gt; Compile the kernel with debug info</code></li>
    <li>Randomize Memory: after <code class="language-plaintext highlighter-rouge">RANDOM_BASE</code> is disabled, <code class="language-plaintext highlighter-rouge">RANDOMIZE_MEMORY</code> should be disabled automatically. If not, disable “<code class="language-plaintext highlighter-rouge">Randomize the address of the kernel image(KASLR)</code>” in Processor type and features.</li>
    <li>name the file attached to the serial port with <code class="language-plaintext highlighter-rouge">.log</code> suffix</li>
    <li>==update grub config==:
      <ul>
        <li>per the comment in piazza, we need to add <code class="language-plaintext highlighter-rouge">console=ttyS0 ignore_loglevel</code> (ttyS0 worked for me, from ttyS0 to ttyS10, there should be one that works) to the option <code class="language-plaintext highlighter-rouge">GRUB_CMD_LINE_LINUX</code> in <code class="language-plaintext highlighter-rouge">/etc/default/grub</code>. (see picture below)</li>
        <li><code class="language-plaintext highlighter-rouge">sudo update-grub</code> to enable the changes you just made</li>
      </ul>
    </li>
  </ol>
</blockquote>

<h2 id="expanding-vm-disk">Expanding VM Disk</h2>

<ol>
  <li>Shutdown your VM.</li>
  <li>In VM settings, choose the virtual hard disk you are using for the VM and expand the size(40-50GB would be enough).</li>
  <li>Boot your VM.</li>
  <li>Open a terminal and</li>
  <li><code class="language-plaintext highlighter-rouge">sudo fdisk /dev/sda</code></li>
  <li>Enter <code class="language-plaintext highlighter-rouge">p</code>, you should see something like <code class="language-plaintext highlighter-rouge">/dev/sda1</code></li>
  <li>Enter <code class="language-plaintext highlighter-rouge">d</code>, you should see <code class="language-plaintext highlighter-rouge">Partition 1 has been deleted</code></li>
  <li>Enter <code class="language-plaintext highlighter-rouge">n</code> to create a new partion and enter <code class="language-plaintext highlighter-rouge">p</code> to select primary partition, the rest are default</li>
  <li>You should see warnings like <code class="language-plaintext highlighter-rouge">Partition #1 contains a ext4 signature.</code></li>
  <li>Enter <code class="language-plaintext highlighter-rouge">Y</code> do delete the signature</li>
  <li>Enter <code class="language-plaintext highlighter-rouge">a</code> to set bootable flag on partition 1</li>
  <li>Enter <code class="language-plaintext highlighter-rouge">w</code> to write all the changes</li>
  <li>Reboot your VM</li>
  <li>Login to your VM and use <code class="language-plaintext highlighter-rouge">sudo resize2fs /dev/sda1</code></li>
  <li>Use <code class="language-plaintext highlighter-rouge">df -h /dev/sda1</code>, you should see your disk is now expanded.</li>
</ol>

<h2 id="checkpatchpl">Checkpatch.pl</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git diff 7dc5355b6 <span class="nt">--</span> linux/ | perl linux/scripts/checkpatch.pl <span class="nt">--ignore</span> FILE_PATH_CHANGES,SPDX_LICENSE_TAG
</code></pre></div></div>

<p>where:</p>

<ul>
  <li>
    <p>contents/code we are checking are <code class="language-plaintext highlighter-rouge">git diff 7dc5355b6</code></p>
  </li>
  <li>we are checking the <code class="language-plaintext highlighter-rouge">linux/</code> directory for errors</li>
  <li>script id located at <code class="language-plaintext highlighter-rouge">linux/scripts/checkpatch.pl</code></li>
</ul>

  </div><a class="u-url" href="/lectures/2021@columbia/COMS4118_Operating_Systems.html/" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/lectures/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Lecture Notes</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Lecture Notes</li><li><a class="u-email" href="mailto:jasonyux17@gmail.com">jasonyux17@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jasonyux"><svg class="svg-icon"><use xlink:href="/lectures/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jasonyux</span></a></li><li><a href="https://www.linkedin.com/in/xiao-yu2437"><svg class="svg-icon"><use xlink:href="/lectures/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">xiao-yu2437</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>An inexhaustive collection of markdown/latex(PDF) notes that I took since college. </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
