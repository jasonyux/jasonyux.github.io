<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Spring Framework Guide | From a Beginner to a Disaster</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IMPORTANT:Much of the content here is a personal summary&#x2F;abbrieviation of contents on the Offical Spring Framework Documentation. For more complete information, please refer to the offical site.  Thi">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Framework Guide">
<meta property="og:url" content="http://yoursite.com/2020/06/09/Spring-Framework-Guide/index.html">
<meta property="og:site_name" content="From a Beginner to a Disaster">
<meta property="og:description" content="IMPORTANT:Much of the content here is a personal summary&#x2F;abbrieviation of contents on the Offical Spring Framework Documentation. For more complete information, please refer to the offical site.  Thi">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/.com//06/09/Spring-Framework-Guide/SpringIoC.png">
<meta property="article:published_time" content="2020-06-09T07:25:30.000Z">
<meta property="article:modified_time" content="2020-06-11T09:46:19.581Z">
<meta property="article:author" content="Xiao Yu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/.com//06/09/Spring-Framework-Guide/SpringIoC.png">
  
    <link rel="alternate" href="/atom.xml" title="From a Beginner to a Disaster" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">From a Beginner to a Disaster</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Xiao.Y</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Spring-Framework-Guide" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/09/Spring-Framework-Guide/" class="article-date">
  <time datetime="2020-06-09T07:25:30.000Z" itemprop="datePublished">2020-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring Framework Guide
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p><strong>IMPORTANT</strong>:<br>Much of the content here is a personal summary/abbrieviation of contents on the <a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/index.html" target="_blank" rel="noopener">Offical Spring Framework Documentation</a>. For more complete information, please refer to the offical site.</p>
<hr>
<p>This is a <strong>Guide</strong>, since it is mostly <strong>conceptual</strong> and does not include much actual coding (except for examples illustrating those concepts). For more practical uses/examples, please refer to the <a href="https://jasonyux.github.io/2020/06/09/SpringBoot-Manual/" target="_blank" rel="noopener">Spring Boot Manual</a> or the <a href>Spring Cloud Manual</a>.</p>
<h2 id="Spring-Intro"><a href="#Spring-Intro" class="headerlink" title="Spring Intro"></a>Spring Intro</h2><p>The term “Spring” means different things in different contexts. It can be used to refer to the Spring Framework project itself, which is where it all started. Over time, other Spring projects have been built on top of the Spring Framework. Most often, when people say “Spring”, they mean the entire family of projects. This reference documentation focuses on the foundation: the Spring Framework itself.</p>
<p>When you learn about a framework, it’s important to know not only what it does but <strong>what principles it follows</strong>. Here are the guiding principles of the Spring Framework:</p>
<ul>
<li>Provide choice at every level. Spring lets you <strong>defer design decisions as late as possible</strong>. For example, you can switch persistence providers through configuration without changing your code. </li>
<li>Accommodate diverse perspectives. Spring embraces flexibility and is not opinionated about how things should be done. It <strong>supports a wide range of application needs with different perspectives</strong>.</li>
<li>Maintain strong backward compatibility. Spring’s evolution has been carefully managed to force <strong>few breaking changes between versions.</strong> Spring supports a carefully chosen range of JDK versions and third-party libraries to facilitate maintenance of applications and libraries that depend on Spring.</li>
<li>Care about API design. The Spring team puts a lot of thought and time into <strong>making APIs that are intuitive and that hold up across many versions and many years.</strong></li>
<li>Set high standards for code quality. The Spring Framework puts a strong emphasis on meaningful, current, and accurate javadoc. It is one of very few projects that can claim <strong>clean code structure with no circular dependencies between packages.</strong></li>
</ul>
<h2 id="IoC-Inversion-of-Control"><a href="#IoC-Inversion-of-Control" class="headerlink" title="IoC - Inversion of Control"></a>IoC - Inversion of Control</h2><p>IoC is also known as <strong>dependency injection (DI)</strong>. It is a process whereby <strong>objects define their dependencies</strong> (that is, the other objects they work with) <strong><em>only</em></strong> <strong>through constructor arguments</strong>, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The <strong>container then injects those dependencies when it creates the bean.</strong> This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern.</p>
<p>In Spring, the <strong>objects that form the backbone of your application and that are managed by the Spring IoC container</strong> are called <strong>beans</strong>. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are <strong>reflected in the configuration metadata used by a container.</strong></p>
<p>The <strong>main tasks performed by IoC container</strong> are:</p>
<ul>
<li>to instantiate the application class</li>
<li>to configure the object</li>
<li>to assemble the dependencies between the objects</li>
</ul>
<p>And there are <strong>two types of IoC containers</strong>. They are:</p>
<ul>
<li>BeanFactory (<code>org.springframework.beans</code>)</li>
<li>ApplicationContext (<code>org.springframework.context</code>)</li>
</ul>
<p>In short, the <code>BeanFactory</code> provides the <strong>configuration framework and basic functionality</strong>, and the <code>ApplicationContext</code> <strong>adds more enterprise-specific functionality</strong>. The <code>ApplicationContext</code> is a complete superset of the <code>BeanFactory</code> and is used exclusively in this chapter in descriptions of Spring’s IoC container. For more information on using the <code>BeanFactory</code> instead of the <code>ApplicationContext</code>, see <a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans-beanfactory" target="_blank" rel="noopener">The BeanFactory</a>.</p>
<h3 id="Java-Beans-vs-Spring-Beans-vs-POJOs"><a href="#Java-Beans-vs-Spring-Beans-vs-POJOs" class="headerlink" title="Java Beans vs Spring Beans vs POJOs"></a>Java Beans vs Spring Beans vs POJOs</h3><p>(additional reference: <a href="http://www.shaunabram.com/beans-vs-pojos/" target="_blank" rel="noopener">http://www.shaunabram.com/beans-vs-pojos/</a>)</p>
<ul>
<li><p>JavaBeans are classes that <strong>encapsulate many objects into a single object (the bean)</strong>. It is a java class that should <strong>follow following conventions</strong>:</p>
<ul>
<li><p>Must implement <code>Serializable.</code></p>
</li>
<li><p>It should have a public <code>no-arg</code> constructor.</p>
</li>
<li><p>All properties in java bean must be <code>private</code> with <code>public getters()</code> and <code>public setter()</code> methods.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123; </span><br><span class="line">	<span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123; </span><br><span class="line">	        <span class="keyword">this</span>.name = name; </span><br><span class="line">    &#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123; </span><br><span class="line">	        <span class="keyword">return</span> name; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  <strong>setter methods</strong>:</p>
<ul>
<li>It should be <code>public</code> in nature.</li>
<li>The return-type should be <code>void</code>.</li>
<li>The setter method should be prefixed with <code>set</code>.</li>
<li>It should take some argument i.e. it should not be no-arg method.</li>
</ul>
<p>  <strong>getter methods</strong></p>
<ul>
<li>It should be <code>public</code> in nature.</li>
<li>The return-type should <strong>not be <code>void</code></strong> i.e. according to our requirement we have to give return-type.</li>
<li>The getter method should be prefixed with <code>get</code>.</li>
<li>It should not take any argument.</li>
</ul>
<p>  <strong>Boolean properties getter method</strong></p>
<ul>
<li>name can be prefixed with either “<code>get</code>” or “<code>is</code>”. But recommended to use “<code>is</code>”.</li>
<li>returns a <code>boolean</code></li>
</ul>
</li>
<li><p><strong>POJO is an acronym for Plain Old Java Object</strong>. The term was coined by <a href="http://www.martinfowler.com/bliki/POJO.html" target="_blank" rel="noopener">Martin Fowler et. al.</a>, as a ‘fancy’ way to describe ordinary Java Objects that do not require a framework to use, nor need to be run in a application server environment.</p>
</li>
<li><p><strong>A Spring bean is basically an object managed by Spring</strong>. More specifically, it is an object that is instantiated, configured and otherwise managed by a Spring Framework container. Spring beans are defined in a Spring configuration file (or, more recently, by using annotations), instantiated by the Spring container, and then injected into your application.</p>
<p>  Spring can manage just about any object, even if it doesn’t have JavaBean type characteristics such as default constructors or mutator methods (getters and setters).</p>
</li>
</ul>
<h3 id="IoC-Container-Overview"><a href="#IoC-Container-Overview" class="headerlink" title="IoC Container Overview"></a>IoC Container Overview</h3><p>The <code>org.springframework.context.ApplicationContext</code> interface represents the Spring IoC container and is responsible for <strong>instantiating, configuring, and assembling the beans</strong>. The container gets its instructions on <strong>what objects to instantiate, configure, and assemble by reading configuration metadata.</strong> </p>
<p>The <strong>configuration metadata</strong> is represented in XML, <strong>Java annotations</strong>, or Java code.</p>
<p>The following diagram shows a high-level view of how Spring works. Your application classes are combined with configuration metadata so that, after the ApplicationContext is created and initialized, you have a fully configured and executable system or application.</p>
<p><img src="/.com//06/09/Spring-Framework-Guide/SpringIoC.png" alt="Picture from https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans" title="Picture from https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans"></p>
<p>A Spring IoC container manages one or more beans. These beans are created with the configuration metadata that you supply to the container (e.g. via an XML file).</p>
<p>Within the container itself, <strong>these bean definitions are represented as <code>BeanDefinition</code> objects, which contain (among other information) the following metadata:</strong></p>
<ul>
<li>A package-qualified class name: typically, the <strong>actual implementation class of the bean</strong> being defined.</li>
<li>Bean behavioral configuration elements, which state how the bean should behave in the container (<code>scope</code>, <code>lifecycle callbacks</code>, and so forth).</li>
<li>References to other beans that are needed for the bean to do its work. These references are also called collaborators or <strong>dependencies</strong>.</li>
<li>Other configuration settings to set in the newly created object — for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool.</li>
</ul>
<p>This metadata <strong>translates to a set of properties that make up each bean definition</strong>. The following table describes these properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Explained in</th>
</tr>
</thead>
<tbody><tr>
<td>Class</td>
<td><a href="#Instantiating-Beans">Instantiating Beans</a></td>
</tr>
<tr>
<td>Name</td>
<td><a href="#Naming-Beans">Naming Beans</a></td>
</tr>
<tr>
<td>Scope</td>
<td><a href="#Bean-Scopes">Bean Scopes</a></td>
</tr>
<tr>
<td>Constructor arguments</td>
<td><a href="#Dependency-Injection">Dependency Injection</a></td>
</tr>
<tr>
<td>Properties</td>
<td><a href="#Dependency-Injection">Dependency Injection</a></td>
</tr>
<tr>
<td>Autowiring mode</td>
<td><a href="#Autowiring-Collaborators">Autowiring Collaborators</a></td>
</tr>
<tr>
<td>Lazy initialization mode</td>
<td><a href="#Lazy-initialized-Beans">Lazy-initialized Beans</a></td>
</tr>
<tr>
<td>Initialization method</td>
<td><a href="#Initialization-Callbacks">Initialization Callbacks</a></td>
</tr>
<tr>
<td>Destruction method</td>
<td><a href="#Destruction-Callbacks">Destruction Callbacks</a></td>
</tr>
</tbody></table>
<h3 id="Configuration-Metadata"><a href="#Configuration-Metadata" class="headerlink" title="Configuration Metadata"></a>Configuration Metadata</h3><p>As the preceding diagram shows, the <strong>Spring IoC container consumes a form of configuration metadata</strong>. This configuration metadata represents how you, as an application developer, <strong>tell the Spring container to instantiate, configure, and assemble the objects in your application</strong>.</p>
<p>Configuration metadata is can be supplied using one of the three forms:</p>
<ul>
<li>XML file</li>
<li>Java-based configuration</li>
<li>Annotation-based configuration</li>
</ul>
<p>(the following chapters only cover <strong>Java-based Configuration</strong>. If you prefer other means of configuration, please refer to the <a href="https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans" target="_blank" rel="noopener">Offical Documentation</a> for more information.)</p>
<h3 id="Java-Based-Configuration"><a href="#Java-Based-Configuration" class="headerlink" title="Java Based Configuration"></a>Java Based Configuration</h3><p>The central artifacts in Spring’s new Java-configuration support are <strong><code>@Configuration</code>-annotated classes</strong> and <strong><code>@Bean</code>-annotated methods</strong>.</p>
<p>The <code>@Bean</code> annotation is used to indicate that <strong>a method instantiates, configures, and initializes a new object (type signature of the method) to be managed by the Spring IoC container</strong>. For those familiar with Spring’s <code>&lt;beans/&gt;</code> XML configuration, the <code>@Bean</code> annotation plays the same role as the <code>&lt;bean/&gt;</code> element. You can use <code>@Bean</code>-annotated methods with any Spring <code>@Component</code>. However, they are most often used with <code>@Configuration</code> beans.</p>
<p>Annotating a class with <code>@Configuration</code> indicates that <strong>its primary purpose is as a source of bean definitions</strong>. Furthermore, <code>@Configuration</code> classes let <strong>inter-bean dependencies be defined by calling other <code>@Bean</code> methods in the same class</strong>. The simplest possible <code>@Configuration</code> class reads as follows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<ul>
<li><input disabled type="checkbox"> Unlike full <code>@Configuration</code>, lite <code>@Bean</code> methods (declared within classes that are not annotated with @Configuration) <strong>cannot declare inter-bean dependencies</strong>. Instead, they operate on their containing component’s internal state and, optionally, on arguments that they may declare. Such a <code>@Bean</code> method should therefore not invoke other <code>@Bean</code> methods. <strong>Each such method is literally only a factory method for a particular bean reference, without any special runtime semantics</strong>.</li>
</ul>
</blockquote>
<p>The <code>@Bean</code> and <code>@Configuration</code> annotations are discussed in depth in the following sections. <strong>First, however, we need to cover the various ways of creating a spring container</strong> using by Java-based configuration.</p>
<h3 id="Instantiating-the-Spring-Container-Using-AnnotationConfigApplicationContext"><a href="#Instantiating-the-Spring-Container-Using-AnnotationConfigApplicationContext" class="headerlink" title="Instantiating the Spring Container Using AnnotationConfigApplicationContext"></a>Instantiating the Spring Container Using <code>AnnotationConfigApplicationContext</code></h3><p>When <code>@Configuration</code> classes are provided as input, <strong>the <code>@Configuration</code> class itself is registered as a bean definition and all declared <code>@Bean</code> methods within the class are also registered as bean definitions</strong>.</p>
<p>This means that instead of using XML files, you can use <code>@Configuration</code> classes as input when instantiating an <code>AnnotationConfigApplicationContext</code>. This allows for completely XML-free usage of the Spring container, as the following example shows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    MyService myService = ctx.getBean(MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AnnotationConfigApplicationContext</code> is not limited to working only with <code>@Configuration</code> classes. <strong>Any <code>@Component</code> or JSR-330 annotated class may be supplied as input to the constructor</strong>, as the following example shows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class="line">    MyService myService &#x3D; ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The preceding example assumes that <code>MyServiceImpl</code>, <code>Dependency1</code>, and <code>Dependency2</code> <strong>use Spring dependency injection annotations such as <code>@Autowired</code></strong>.</p>
<h3 id="Building-the-Container-Programmatically-by-Using-register-Class-lt-gt-…​"><a href="#Building-the-Container-Programmatically-by-Using-register-Class-lt-gt-…​" class="headerlink" title="Building the Container Programmatically by Using register(Class&lt;?&gt;…​)"></a>Building the Container Programmatically by Using <code>register(Class&lt;?&gt;…​)</code></h3><p>One thing we see before for using <code>AnnotationConfigApplicationContext</code> is that the configurations need to be specified when you instantiate the <code>ApplicationContext</code>. However, sometimes you might need to programmatically add configurations later. This can be done by <strong>instantiate an <code>AnnotationConfigApplicationContext</code> by using a no-arg constructor and then configure it by using the <code>register()</code> method</strong>. This approach is particularly useful when programmatically building an <code>AnnotationConfigApplicationContext</code>. The following example shows how to do so:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.register(AppConfig<span class="class">.<span class="keyword">class</span>, <span class="title">OtherConfig</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    ctx.register(AdditionalConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    MyService myService = ctx.getBean(MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Enabling-Component-Scanning-with-scan-String…​"><a href="#Enabling-Component-Scanning-with-scan-String…​" class="headerlink" title="Enabling Component Scanning with scan(String…​)"></a>Enabling Component Scanning with <code>scan(String…​)</code></h3><p>To enable component scanning, you can <strong>annotate your <code>@Configuration</code> class</strong> as follows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.acme"</span>)  <span class="comment">// this enables component scanning</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the preceding example, the <strong><code>com.acme</code> package is scanned to look for any <code>@Component</code>-annotated classes</strong>, and those classes are registered as Spring bean definitions within the container. </p>
<p>Additionally, <strong>you can use the <code>AnnotationConfigApplicationContext</code> object with the <code>scan(String…​)</code> method</strong> to allow for the same component-scanning functionality, as the following example shows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.scan(<span class="string">"com.acme"</span>);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    MyService myService = ctx.getBean(MyService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the preceding example, <strong>assuming that <code>AppConfig</code> is declared within the <code>com.acme</code> package (or any package underneath)</strong>. The above works <strong>since <code>@Configuration</code> classes are meta-annotated</strong> with <code>@Component</code>, so they are <strong>candidates for component-scanning as well</strong>. Then the <strong><code>AppConfig</code> along with its components is picked up during the call to <code>scan()</code></strong>. Upon <code>refresh()</code>, all its <code>@Bean</code> methods are processed and registered as bean definitions within the container.</p>
<h3 id="Using-the-Bean-Annotation"><a href="#Using-the-Bean-Annotation" class="headerlink" title="Using the @Bean Annotation"></a>Using the <code>@Bean</code> Annotation</h3><p>You can use the <code>@Bean</code> annotation in a <code>@Configuration</code>-annotated or in a <code>@Component</code>-annotated class.</p>
<p>To declare a bean, you can annotate <strong>a method with the <code>@Bean</code> annotation</strong>. You use this method to register a bean definition within an <code>ApplicationContext</code> of the type specified as the method’s return value. <strong>By default, the bean name is the same as the method name.</strong> The following example shows a <code>@Bean</code> method declaration:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferServiceImpl <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The preceding configuration is exactly equivalent to the following Spring XML:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;transferService&quot; class&#x3D;&quot;com.acme.TransferServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>Both would make a <strong>bean (method for getting an Object) named <code>transferService</code> available in the <code>ApplicationContext</code></strong>, bound to an <strong>object instance of type <code>TransferServiceImpl</code></strong>, as the following text image shows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transferService -&gt; com.acme.TransferServiceImpl</span><br></pre></td></tr></table></figure>

<p>You can also <strong>declare your <code>@Bean</code> method with an interface</strong> (or base class) return type, as the following example shows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, this <strong>limits the visibility for advance type prediction</strong> to the specified interface type (<code>TransferService</code>), such that the full type (<code>TransferServiceImpl</code>) is known to the container only once.</p>
<h3 id="Determining-a-Bean’s-Runtime-Type"><a href="#Determining-a-Bean’s-Runtime-Type" class="headerlink" title="Determining a Bean’s Runtime Type"></a>Determining a Bean’s Runtime Type</h3><p>The runtime type of a specific bean is non-trivial to determine. A specified class in the bean metadata definition is just an initial class reference, potentially combined with a declared factory method or being a FactoryBean class which <strong>may lead to a different runtime type of the bean</strong>, or not being set at all in case of an instance-level factory method (which is resolved via the specified factory-bean name instead).</p>
<p>The recommended way to find out about the actual runtime type of a particular bean is <strong>a <code>BeanFactory.getType</code> call for the specified bean name</strong>. This takes all of the above cases into account and returns the type of object that a BeanFactory.getBean call is going to return for the same bean name.</p>
<h3 id="Bean-Dependencies"><a href="#Bean-Dependencies" class="headerlink" title="Bean Dependencies"></a>Bean Dependencies</h3><p><strong>A <code>@Bean</code>-annotated method can have an arbitrary number of parameters that describe the dependencies</strong> required to build that bean. For instance, if our <code>TransferService</code> requires an <code>AccountRepository</code>, we can <strong>materialize that dependency with a method parameter</strong>, as the following example shows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">(AccountRepository accountRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl(accountRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The resolution mechanism is pretty much identical to <code>constructor-based dependency injection</code>. See below sections for more details.</p>
<h3 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h3><p><strong>Dependency injection (DI) is a process whereby objects define their dependencies</strong> (that is, the other objects with which they work) <strong><em>only</em> through</strong> constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method.</p>
<p>The <strong>container then injects those dependencies when it creates the bean</strong>.</p>
<p>Code is cleaner with the DI principle, and decoupling is more effective when objects are provided with their dependencies. The object does not look up its dependencies and does not know the location or class of the dependencies. As a result, your classes become easier to test, particularly when the dependencies are on interfaces or abstract base classes, which allow for stub or mock implementations to be used in unit tests.</p>
<p>DI exists in two major variants: </p>
<ul>
<li><strong>Constructor-based dependency injection</strong></li>
<li><strong>Setter-based dependency injection</strong></li>
</ul>
<h3 id="Constructor-based-dependency-injection"><a href="#Constructor-based-dependency-injection" class="headerlink" title="Constructor-based dependency injection"></a>Constructor-based dependency injection</h3><p>(additional reference: <a href="https://www.tutorialspoint.com/spring/constructor_based_dependency_injection.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/spring/constructor_based_dependency_injection.htm</a>)</p>
<p>Constructor-based DI is accomplished when the container invokes a <strong>class constructor with a number of arguments, each representing a dependency on the other class</strong>.</p>
<p>Consider you have an application which has a text editor component and you want to provide a spell check. Your standard code would look something like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      spellChecker = <span class="keyword">new</span> SpellChecker();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What we’ve done here is, create a dependency between the TextEditor and the SpellChecker.** In an inversion of control scenario, we would instead do something like this:**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">(SpellChecker spellChecker)</span> </span>&#123;  <span class="comment">// Constructor based DI</span></span><br><span class="line">      <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, the <code>TextEditor</code> should not worry about <code>SpellChecker</code> implementation. <strong>The <code>SpellChecker</code> will be implemented independently and will be provided to the <code>TextEditor</code> at the time of <code>TextEditor</code> instantiation</strong>. This entire procedure is controlled by the Spring Framework.</p>
<h3 id="Constructor-Arguments-Resolution"><a href="#Constructor-Arguments-Resolution" class="headerlink" title="Constructor Arguments Resolution"></a>Constructor Arguments Resolution</h3><p>There may be an ambiguity while passing arguments to the constructor,** in case there are more than one parameters**. To resolve this ambiguity, the order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor. Consider the following class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(Bar bar, Baz baz)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The following configuration works fine:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">(Bar bar, Baz baz)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Foo(bar, baz)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let us check one more case where we pass different types to the constructor, and we want to specify a specific value for them. Consider the following class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> year, String name)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The container can also use type matching with simple types, if you explicitly specify the type of the constructor argument using the type attribute. For example −</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">(<span class="keyword">int</span> year, String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Foo(<span class="number">2001</span>,<span class="string">"Zara"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>If you are using XML</strong>, then the best way to pass constructor arguments is to <strong>use the index attribute to specify explicitly the index of constructor arguments. Here, the index is 0 based.</strong> For example:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"foo"</span> <span class="attr">class</span> = <span class="string">"x.y.Foo"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span> = <span class="string">"0"</span> <span class="attr">value</span> = <span class="string">"2001"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span> = <span class="string">"1"</span> <span class="attr">value</span> = <span class="string">"Zara"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>A final note, in case you are passing a reference to an object as an argument, you need to use ref attribute of <code>&lt;constructor-arg&gt;</code> tag in the XML, and if you are passing a <code>value</code> directly then you should use value attribute as shown above.</p>
<h3 id="Setter-based-Dependency-Injection"><a href="#Setter-based-Dependency-Injection" class="headerlink" title="Setter-based Dependency Injection"></a>Setter-based Dependency Injection</h3><p>Setter-based DI is accomplished by the <strong>container calling <code>setter</code> methods on your beans after invoking a no-argument constructor or a no-argument static factory method</strong> to instantiate your bean.</p>
<p>For example:</p>
<p>(referece: <a href="https://www.tutorialspoint.com/spring/setter_based_dependency_injection.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/spring/setter_based_dependency_injection.htm</a>)</p>
<p>the content of <code>TextEditor.java</code> file:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> SpellChecker spellChecker;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TextEditor</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// a setter method to inject the dependency.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpellChecker</span><span class="params">(SpellChecker spellChecker)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.spellChecker = spellChecker;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// a getter method to return spellChecker</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SpellChecker <span class="title">getSpellChecker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> spellChecker;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spellCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      spellChecker.checkSpelling();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here you need to check the <strong>naming convention of the setter methods</strong>. To set an object <code>SpellChecker</code> we are using <code>setSpellChecker()</code> method which is very similar to Java POJO classes. Then the content of another dependent class file <code>SpellChecker.java</code> could be:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside SpellChecker constructor."</span> );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkSpelling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside checkSpelling."</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, the configuration would look like:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TextEditor <span class="title">textEditor</span><span class="params">(SpellChecker spellChecker)</span></span>&#123;</span><br><span class="line">		TextEditor textEditor = <span class="keyword">new</span> TextEditor();</span><br><span class="line">		textEditor.setSpellChecker(spellChecker);</span><br><span class="line">		<span class="keyword">return</span> textEditor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SpellChecker <span class="title">spellChecker</span><span class="params">()</span></span>&#123;  <span class="comment">// this is necessary as the above Bean uses the Bean SpellChecker</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpellChecker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, just to finish the example, you would have your main class (called <code>Example</code> here):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mySpringProject.app.testIoC.AppConfig;</span><br><span class="line"><span class="keyword">import</span> com.mySpringProject.app.testIoC.TextEditor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        TextEditor txtedr = ctx.getBean(TextEditor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        txtedr.spellCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You will see that the container <strong>managed the construction of objects/dependencies for us</strong>, so that <code>SpellChecker</code> is first created, and then passed into the <code>TextEditor</code> object. Lastly, you would be able to call the method <code>spellCheck()</code>.</p>
<h3 id="Constructor-based-or-Setter-based-DI"><a href="#Constructor-based-or-Setter-based-DI" class="headerlink" title="Constructor-based or Setter-based DI"></a>Constructor-based or Setter-based DI</h3><p>Since <strong>you can mix constructor-based and setter-based DI</strong>, it is a good rule of thumb to use <strong>constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies</strong>. Note that use of the <code>@Required</code> annotation on a setter method can be used to make the property be a required dependency; however, constructor injection with programmatic validation of arguments is preferable.</p>
<p>Using only constructor injection, lets you implement application components as <strong>immutable objects and ensures that required dependencies are not null</strong>. Furthermore, constructor-injected components are always returned to the client (calling) code in a fully initialized state.</p>
<p><strong>Setter injection should primarily only be used for optional dependencies</strong> that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency.</p>
<h3 id="Lazy-initialized-Beans"><a href="#Lazy-initialized-Beans" class="headerlink" title="Lazy-initialized Beans"></a>Lazy-initialized Beans</h3><p>By default, <strong><code>ApplicationContext</code> implementations eagerly create and configure all singleton beans as part of the initialization process.</strong> Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can <strong>prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized</strong>.** A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup**.</p>
<p>To achieve this in a Java-annotation based configuration, you add the <code>@Lazy</code> to the configuration class. This will make all <code>@Bean</code> bean methods to become lazily initialized:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Lazy</span>  <span class="comment">// all beans inside this class will be lazily initialized</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextEditor <span class="title">textEditor</span><span class="params">(SpellChecker spellChecker)</span></span>&#123;</span><br><span class="line">        TextEditor textEditor = <span class="keyword">new</span> TextEditor();</span><br><span class="line">        textEditor.setSpellChecker(spellChecker);</span><br><span class="line">        <span class="keyword">return</span> textEditor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpellChecker <span class="title">spellChecker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpellChecker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you only want to lazily initialize a speicific bean, then add <code>@Lazy(true)</code> or <code>@Lazy()</code> above that bean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Lazy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Lazy</span>()  <span class="comment">// this will be lazily initialized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TextEditor <span class="title">textEditor</span><span class="params">(SpellChecker spellChecker)</span></span>&#123;</span><br><span class="line">        TextEditor textEditor = <span class="keyword">new</span> TextEditor();</span><br><span class="line">        textEditor.setSpellChecker(spellChecker);</span><br><span class="line">        <span class="keyword">return</span> textEditor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpellChecker <span class="title">spellChecker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpellChecker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Component-Scanning"><a href="#Component-Scanning" class="headerlink" title="Component Scanning"></a>Component Scanning</h3><p>(additional reference: <a href="https://www.baeldung.com/spring-bean-annotations" target="_blank" rel="noopener">https://www.baeldung.com/spring-bean-annotations</a>)</p>
<p>Spring can automatically <strong>scan a package for beans if component scanning is enabled.</strong></p>
<p><code>@ComponentScan</code> <strong>configures which packages to scan for classes with annotation configuration</strong>. We can specify the base package names directly with one of the <code>basePackages</code> or <code>value</code> arguments (<code>value</code> is an alias for <code>basePackages</code>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.baeldung.annotations"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehicleFactoryConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Also, we can <strong>point to classes directly</strong> in the base packages with the <code>basePackageClasses</code> argument:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackageClasses = VehicleFactoryConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">VehicleFactoryConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Alternatively, we can use** <code>@ComponentScans</code> to specify multiple <code>@ComponentScan</code> configurations**:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScans</span>(&#123;  <span class="comment">// notice this is ComponentScans, not ComponentScan</span></span><br><span class="line">  <span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.baeldung.annotations"</span>), </span><br><span class="line">  <span class="meta">@ComponentScan</span>(basePackageClasses = VehicleFactoryConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">&#125;)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">VehicleFactoryConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Using-Component-Annotation"><a href="#Using-Component-Annotation" class="headerlink" title="Using @Component Annotation"></a>Using <code>@Component</code> Annotation</h3><p><code>@Component</code> is a class level annotation. <strong>During the component scan, Spring Framework automatically detects classes annotated with <code>@Component</code></strong>.</p>
<p>For example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarUtility</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>By default, the bean instances of this class have the same name as the class name with a lowercase initial. On top of that, we can specify a different name using the optional value argument of this annotation.</p>
<p>Since <code>@Repository</code>,<code>@Service</code>, <code>@Configuration</code>, and <code>@Controller</code> are all meta-annotations of <code>@Component</code>, they share the same bean naming behavior. Also, <strong>Spring automatically picks them up during the component scanning process</strong>.</p>
<p>For example, you can have an <code>@Component</code> with:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// or @Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordDictionary <span class="title">wordDictionary</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WordDictionary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then in your main <code>@Configuration</code>, you have:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.*;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScans(</span><br><span class="line">        &#123;@ComponentScan(basePackageClasses&#x3D;Config2.class)&#125;  &#x2F;&#x2F; Scans that class for beans</span><br><span class="line">)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TextEditor textEditor(SpellChecker spellChecker)&#123;</span><br><span class="line">        TextEditor textEditor &#x3D; new TextEditor();</span><br><span class="line">        textEditor.setSpellChecker(spellChecker);</span><br><span class="line">        return textEditor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SpellChecker spellChecker()&#123;</span><br><span class="line">        return new SpellChecker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, in your main class, you would be able to use <code>WordDictionary</code> class even if it was not specified in the <code>ApplicationContext</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mySpringProject.app.testIoC.AppConfig;</span><br><span class="line"><span class="keyword">import</span> com.mySpringProject.app.testIoC.TextEditor;</span><br><span class="line"><span class="keyword">import</span> com.mySpringProject.app.testIoC.WordDictionary;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        TextEditor txtedr = ctx.getBean(TextEditor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        WordDictionary dict = ctx.getBean(WordDictionary<span class="class">.<span class="keyword">class</span>)</span>;  <span class="comment">// not directly in AppConfig, but scanned</span></span><br><span class="line">        txtedr.spellCheck();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Using-Autowired-to-configure-your-beans-and-dependencies"><a href="#Using-Autowired-to-configure-your-beans-and-dependencies" class="headerlink" title="Using @Autowired to configure your beans and dependencies"></a>Using @Autowired to configure your beans and dependencies</h3><p>(additional reference: <a href="https://www.baeldung.com/spring-autowire" target="_blank" rel="noopener">https://www.baeldung.com/spring-autowire</a>)</p>
<p>Starting with Spring 2.5, the framework introduced a new style of Dependency Injection driven by <code>@Autowired</code> Annotations. This annotation allows Spring to <strong>automatically resolve and inject collaborating beans into your bean</strong>. It has the following adavantages:</p>
<ul>
<li><p>Autowiring can significantly <strong>reduce the need to specify properties or constructor arguments</strong>. (Other mechanisms such as a bean template discussed elsewhere in this chapter are also valuable in this regard.)</p>
</li>
<li><p>Autowiring can <strong>update a configuration as your objects evolve</strong>. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.</p>
</li>
</ul>
<p>Once annotation injection is enabled, autowiring can be used on properties, setters, and constructors.</p>
<h3 id="Autowired-on-properties"><a href="#Autowired-on-properties" class="headerlink" title="@Autowired on properties"></a><code>@Autowired</code> on properties</h3><p>First, to enable annotation-driven injection, you need to be using <code>AnnotationConfigApplicationContext</code> to load your spring configuration as below:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();  <span class="comment">// actually what we've been doing so far</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then, you can have the following <code>Component</code>s/classes:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mySpringProject.app.testIoC.AutowiredSamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooforMatter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And importantly, this class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mySpringProject.app.testIoC.AutowiredSamples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FooforMatter fooforMatter;  <span class="comment">// notice that this field is Autowired. </span></span><br><span class="line">									    <span class="comment">// It means that it will be automatically created and attached</span></span><br><span class="line">										<span class="comment">// to the FooService object</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FooforMatter <span class="title">getFooforMatter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fooforMatter;  <span class="comment">// so that we can use the message() method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, all you need to do in your <code>@Configuration</code> clas is to <strong>point it to the correctly component using the component scan</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.mySpringProject.app.testIoC.AutowiredSamples"</span>)  <span class="comment">// the package where we had the @Components</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredConfig</span> </span>&#123;	<span class="comment">// no bean needs to be declared inside this configuration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then, in the main application class, we can see the message by:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mySpringProject.app.testIoC.AutowiredConfig;</span><br><span class="line"><span class="keyword">import</span> com.mySpringProject.app.testIoC.AutowiredSamples.FooService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AutowiredConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        FooService fsrv = ctx.getBean(FooService<span class="class">.<span class="keyword">class</span>)</span>;  <span class="comment">// Autowired figured this out for us</span></span><br><span class="line">        System.out.println(fsrv.getFooforMatter().message());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Autowired-on-constructors"><a href="#Autowired-on-constructors" class="headerlink" title="@Autowired on constructors"></a><code>@Autowired</code> on constructors</h3><p>The @Autowired annotation can also be used on constructors. In the below example, when the annotation is used on a constructor, an instance of FooFormatter is injected as an argument to the constructor when FooService is created:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> FooFormatter fooFormatter;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooService</span><span class="params">(FooFormatter fooFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fooFormatter = fooFormatter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, an instance of <code>FooFormatter</code> is injected as an argument to the constructor when <code>FooService</code> is created.</p>
<p>This technically has the same effect as using <code>@Autowired</code> on a specific field, but it turns out that** using <code>@Autowired</code> on a constructor is always the better approach**. This is because:</p>
<ul>
<li>you can only <strong><code>@Autowired</code> one field at a time</strong>, but above <strong>a constructor, all arguments will be instantiated/autowired</strong>.</li>
<li>using <code>@Autowired</code> on a field is <strong>vulnerable for the problem of having a <code>NullPointerException</code></strong>. This is because if the autowired field is not correctly instantiated, the** main object that depends on it might still be created, but invoking methods of that private field will cause <code>NullPointerException</code><strong>. However, by **having the <code>@Autowired</code> for a constructor, it forces the main object to be created WITH an instantiation of that dependent object</strong>.</li>
</ul>
<h3 id="Optional-Dependencies-for-Autowired"><a href="#Optional-Dependencies-for-Autowired" class="headerlink" title="Optional Dependencies for @Autowired"></a>Optional Dependencies for <code>@Autowired</code></h3><p>(additional reference: <a href="https://www.baeldung.com/spring-autowire" target="_blank" rel="noopener">https://www.baeldung.com/spring-autowire</a>)</p>
<p>Spring expects <code>@Autowired</code> dependencies to be available when the dependent bean is being constructed. <strong>If the framework cannot resolve a bean for wiring</strong>, it will throw the below-quoted exception and prevent the Spring container from launching successfully:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: </span><br><span class="line">No qualifying bean of type [com.autowire.sample.FooDAO] found for dependency: </span><br><span class="line">expected at least 1 bean which qualifies as autowire candidate for this dependency. </span><br><span class="line">Dependency annotations: </span><br><span class="line">&#123;@org.springframework.beans.factory.annotation.Autowired(required&#x3D;true)&#125;</span><br></pre></td></tr></table></figure>

<p>To avoid this from happening, <strong>a bean can optional be specified as below</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FooService &#123;</span><br><span class="line"> </span><br><span class="line">    @Autowired(required &#x3D; false)</span><br><span class="line">    private FooDAO dataAccessor; </span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Bean-Scopes"></a></p>
<h3 id="Bean-Scopes"><a href="#Bean-Scopes" class="headerlink" title="Bean Scopes"></a>Bean Scopes</h3><p>(additional reference: <a href="https://www.baeldung.com/spring-bean-scopes" target="_blank" rel="noopener">https://www.baeldung.com/spring-bean-scopes</a>)</p>
<p>When you create a bean definition, you create a recipe for creating actual instances of the class defined by that bean definition. The idea that a bean definition is a recipe is important, because it means that, as with a class, you can create many object instances from a single recipe.</p>
<p>In addition to all those configurations that you can specify to a bean, you can also specify its scope:** the scope of a bean defines the life cycle and visibility of that bean in the contexts in which it is used**.</p>
<p>The latest version of Spring framework defines 6 types of scopes:</p>
<ul>
<li><a href="#Singleton-Scope">singleton</a></li>
<li><a href="#Prototype-Scope">prototype</a></li>
<li><a href="#Request-Scope">request</a></li>
<li><a href="#Session-Scope">session</a></li>
<li><a href="#Application-Scope">application</a></li>
<li><a href="#Websocket-Scope">websocket</a></li>
</ul>
<p>The <strong>last four scopes listed above</strong> - <code>request</code>, <code>session</code>, <code>application</code> and <code>websocket</code> - are <strong>only available in a web-aware application</strong>.</p>
<p><a name="Singleton-Scope"></a></p>
<h4 id="Singleton-Scope"><a href="#Singleton-Scope" class="headerlink" title="Singleton Scope"></a>Singleton Scope</h4><p>Defining a bean with singleton scope <strong>means the container creates a single instance of that bean, and all requests for that bean name will return the same object, which is cached</strong>. Any modifications to the object will be reflected in all references to the bean. This scope is the default value if no other scope is specified.</p>
<p>For example, if you have a Person object that stores a name:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard constructor, getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Afterwards, we define the bean with singleton scope by using the <code>@Scope</code> annotation:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">personSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, if you use the <code>getBean(Person.class)</code> to create that object, you will <strong>only get one and the same instance of it no matter how many times you this method call</strong>. This also means that if you change the <code>name</code> field of one of the <code>Person</code> object you get, it will be changed for all <code>Person</code> objects that you got.</p>
<p><a name="Prototype-Scope"></a></p>
<h4 id="Prototype-Scope"><a href="#Prototype-Scope" class="headerlink" title="Prototype Scope"></a>Prototype Scope</h4><p>A bean with <code>prototype</code> scope will <strong>return a different instance every time it is requested from the container</strong>. It is defined by setting the value <code>prototype</code> to the <code>@Scope</code> annotation in the bean definition:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)  <span class="comment">// everytime this bean is used, a new Person object will be created</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">personPrototype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, if you make multiple calls of <code>getBean(Person.class)</code>, you will get multiple <code>Person</code> objects instantiated (as many as the number of times you called the method). This will not cause the problem that, if you change the name of one <code>Person</code> object, all <code>name</code>s of other <code>Person</code> objects will be changed.</p>
<p>As mentioned, there are four additional scopes that are only available in a web-aware application context. These are less often used in practice:</p>
<p><a name="Request-Scope"></a></p>
<h4 id="Request-Scope"><a href="#Request-Scope" class="headerlink" title="Request Scope"></a>Request Scope</h4><p>The request scope creates a bean instance for a <strong>single HTTP request</strong>.</p>
<p>We can define the bean with request scope using the <code>@Scope</code> annotation:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> HelloMessageGenerator <span class="title">requestScopedBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HelloMessageGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>proxyMode</code> attribute is <strong>necessary here because</strong>, at the moment of the instantiation of the web application context, <strong>there is no active request</strong>. Spring will create a proxy to be injected as a dependency, and instantiate the target bean when it is needed in a request.</p>
<p>We can also use a <strong><code>@RequestScope</code> composed annotation that acts as a shortcut for the above definition</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@RequestScope</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HelloMessageGenerator <span class="title">requestScopedBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HelloMessageGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we can define <strong>a <code>controller</code> that has an injected reference to the <code>requestScopedBean</code></strong>. We need to access the same request twice in order to test the web specific scopes.</p>
<p>If we display the message each time the request is run, we can see that the value is reset to null, even though it is later changed in the method. This is because of <strong>a different bean instance being returned for each request</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopesController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"requestScopedBean"</span>)</span><br><span class="line">    HelloMessageGenerator requestScopedBean;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/scopes/request"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestScopeMessage</span><span class="params">(<span class="keyword">final</span> Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"previousMessage"</span>, requestScopedBean.getMessage());</span><br><span class="line">        requestScopedBean.setMessage(<span class="string">"Good morning!"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"currentMessage"</span>, requestScopedBean.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"scopesExample"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="Session-Scope"></a></p>
<h4 id="Session-Scope"><a href="#Session-Scope" class="headerlink" title="Session Scope"></a>Session Scope</h4><p>The session scope creates for <strong>an HTTP Session</strong>.</p>
<p>We can define the bean with session scope in a similar manner:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> HelloMessageGenerator <span class="title">sessionScopedBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HelloMessageGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s also a dedicated composed annotation we can use to simplify the bean definition:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HelloMessageGenerator <span class="title">sessionScopedBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HelloMessageGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we define a controller with a reference to the <code>sessionScopedBean</code>. Again, we need to run two requests in order to show that the value of the message field is the same for the session.</p>
<p>In this case, when the request is made for the first time, the value message is null. But once, it is changed, then that value is retained for subsequent requests as the same instance of the bean is returned for the entire session.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopesController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"sessionScopedBean"</span>)</span><br><span class="line">    HelloMessageGenerator sessionScopedBean;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/scopes/session"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSessionScopeMessage</span><span class="params">(<span class="keyword">final</span> Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"previousMessage"</span>, sessionScopedBean.getMessage());</span><br><span class="line">        sessionScopedBean.setMessage(<span class="string">"Good afternoon!"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"currentMessage"</span>, sessionScopedBean.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"scopesExample"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="Application-Scope"></a></p>
<h4 id="Application-Scope"><a href="#Application-Scope" class="headerlink" title="Application Scope"></a>Application Scope</h4><p>The application scope creates the bean instance for the <strong>lifecycle of a ServletContext</strong>.</p>
<p>This is similar to the singleton scope but there is a very important difference with regards to the scope of the bean.</p>
<p>When beans are application scoped the same instance of the bean is shared across multiple servlet-based applications running in the same ServletContext, while singleton-scoped beans are scoped to a single application context only.</p>
<p>Let’s create the bean with application scope:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(</span><br><span class="line">  value = WebApplicationContext.SCOPE_APPLICATION, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> HelloMessageGenerator <span class="title">applicationScopedBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HelloMessageGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Analogously as for the request and session scopes, we can use a shorter version:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ApplicationScope</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HelloMessageGenerator <span class="title">applicationScopedBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HelloMessageGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, let’s create a controller that references this bean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopesController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"applicationScopedBean"</span>)</span><br><span class="line">    HelloMessageGenerator applicationScopedBean;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/scopes/application"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getApplicationScopeMessage</span><span class="params">(<span class="keyword">final</span> Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"previousMessage"</span>, applicationScopedBean.getMessage());</span><br><span class="line">        applicationScopedBean.setMessage(<span class="string">"Good afternoon!"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"currentMessage"</span>, applicationScopedBean.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"scopesExample"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this case, value message once set in the applicationScopedBean will be retained for all subsequent requests, sessions and even for a different servlet application that will access this bean, provided it is running in the same ServletContext.</p>
<p><a name="Websocket-Scope"></a></p>
<h4 id="Websocket-Scope"><a href="#Websocket-Scope" class="headerlink" title="Websocket Scope"></a>Websocket Scope</h4><p>The websocket scope creates it for a particular <strong>WebSocket session</strong>.</p>
<p>Finally, let’s create the bean with websocket scope:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Scope(scopeName &#x3D; &quot;websocket&quot;, proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</span><br><span class="line">public HelloMessageGenerator websocketScopedBean() &#123;</span><br><span class="line">    return new HelloMessageGenerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebSocket-scoped beans when first accessed are stored in the WebSocket session attributes. The same instance of the bean is then returned whenever that bean is accessed during the entire WebSocket session.</p>
<p>We can also say that it exhibits singleton behavior but limited to a WebSocket session only.</p>
<h3 id="Specifying-Bean-Scope"><a href="#Specifying-Bean-Scope" class="headerlink" title="Specifying Bean Scope"></a>Specifying Bean Scope</h3><p>Spring includes the <code>@Scope</code> annotation so that you can specify the scope of a bean.</p>
<p>You can specify that your <strong>beans defined with the <code>@Bean</code> annotation should have a specific scope</strong>. You can use any of the standard scopes specified in the <a href="#Bean-Scopes">Bean Scopes</a> section above.</p>
<p>The default scope is singleton, but you can override this with the @Scope annotation, as the following example shows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Encryptor <span class="title">encryptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Method-Injection"><a href="#Method-Injection" class="headerlink" title="Method Injection"></a>Method Injection</h3><p>In most application scenarios, most beans in the container are singletons. When a singleton bean needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. <strong>A problem arises when the bean lifecycles are different</strong>. Suppose <strong>singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A</strong>. The container <strong>creates the singleton bean A only once, and thus only gets one opportunity to set the properties</strong>. The container cannot provide bean A with a new instance of bean B every time one is needed.</p>
<p>The solution is to use the <code>@Lookup</code>, namely, Method Injection.</p>
<h3 id="Using-Lookup-for-Method-Injection"><a href="#Using-Lookup-for-Method-Injection" class="headerlink" title="Using @Lookup for Method Injection"></a>Using @Lookup for Method Injection</h3><p><code>@Lookup</code> is a method annotated that tells <strong>Spring to return an instance of the method’s return type every time when we invoke it.</strong></p>
<p>First, let’s create a prototype bean that we will later inject into a singleton bean:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.mySpringProject.app.testIoC.MethodInjectionSamples;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Scope;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Scope(&quot;prototype&quot;)  &#x2F;&#x2F; so that everytime a bean of this is created, you get a new SchoolNotification</span><br><span class="line">public class SchoolNotification &#123;</span><br><span class="line">    static int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public SchoolNotification()&#123;</span><br><span class="line">        System.out.println(&quot;Notification &quot;+(++count) +&quot; created&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And if we create a singleton bean that uses <code>@Lookup</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.mySpringProject.app.testIoC.MethodInjectionSamples;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Lookup;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component	&#x2F;&#x2F; no @Scope specifed defaults it to a singleton</span><br><span class="line">public class StudentService &#123;</span><br><span class="line"></span><br><span class="line">    @Lookup  &#x2F;&#x2F; this will be overridden by the container, calling: beanFactory.getBean()(StudentNotification.class)</span><br><span class="line">    public SchoolNotification getSchoolNotification()&#123;  </span><br><span class="line">        return null;  &#x2F;&#x2F; therefore, whatever you have here doesn&#39;t really matter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using <code>@Lookup</code>, we can get an new instance of SchoolNotification through our singleton bean** everytime when the method <code>getSchoolNotification</code> is called** (assuming you have a <code>ScopeConfig</code> class with <code>@Configuration</code> and <code>ComponentScan</code> setup correctly):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.mySpringProject.app;</span><br><span class="line"></span><br><span class="line">import com.mySpringProject.app.testIoC.*;</span><br><span class="line">import com.mySpringProject.app.testIoC.AutowiredSamples.FooService;</span><br><span class="line">import com.mySpringProject.app.testIoC.MethodInjectionSamples.StudentService;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(ScopeConfig.class);</span><br><span class="line">        </span><br><span class="line">        StudentService stdsrv1 &#x3D; ctx.getBean(StudentService.class);</span><br><span class="line">        StudentService stdsrv2 &#x3D; ctx.getBean(StudentService.class);</span><br><span class="line">        StudentService stdsrv3 &#x3D; ctx.getBean(StudentService.class);</span><br><span class="line">        StudentService stdsrv4 &#x3D; ctx.getBean(StudentService.class);</span><br><span class="line"></span><br><span class="line">        stdsrv1.getSchoolNotification();</span><br><span class="line">        stdsrv2.getSchoolNotification();</span><br><span class="line">        stdsrv3.getSchoolNotification();</span><br><span class="line">        stdsrv4.getSchoolNotification();</span><br><span class="line">        stdsrv1.getSchoolNotification();	&#x2F;&#x2F; you will see that the count monotonously increases</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Customizing-the-Nature-of-Bean"><a href="#Customizing-the-Nature-of-Bean" class="headerlink" title="Customizing the Nature of Bean"></a>Customizing the Nature of Bean</h3><p>The Spring Framework provides a number of interfaces you can use to customize the nature of a bean. This section groups them as follows:</p>
<ul>
<li>Lifecycle Callbacks</li>
<li><code>ApplicationContextAware</code> and <code>BeanNameAware</code></li>
<li>Other <code>Aware</code> Interfaces</li>
</ul>
<h4 id="Lifecycle-Callbacks"><a href="#Lifecycle-Callbacks" class="headerlink" title="Lifecycle Callbacks"></a>Lifecycle Callbacks</h4><p>(additional reference: <a href="https://www.tutorialspoint.com/spring/spring_bean_life_cycle.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/spring/spring_bean_life_cycle.htm</a>; <a href="https://www.baeldung.com/running-setup-logic-on-startup-in-spring" target="_blank" rel="noopener">https://www.baeldung.com/running-setup-logic-on-startup-in-spring</a>)</p>
<p>The life cycle of a Spring bean is easy to understand. When a bean is instantiated, it may be required to perform some initialization to get it into a usable state. Similarly, when the bean is no longer required and is removed from the container, some cleanup may be required.</p>
<p>The whole concept of lifecycle callbacks is to solve the problem of handling too much control to the container. For example, We can’t simply include our logic in the beans’ constructors or call methods after instantiation of any object; we are simply not in control during those processes:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvalidInitExampleBean</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvalidInitExampleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        env.getActiveProfiles();  <span class="comment">// this could get called before Spring bean is fully initialized</span></span><br><span class="line">			                      <span class="comment">// namely, before env gets initialized and attached</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Therefore, this is problematic because calling not yet initialized fields will of course <strong>result in <code>NullPointerExceptions</code></strong>.</p>
<h5 id="Initialization-Callbacks"><a href="#Initialization-Callbacks" class="headerlink" title="Initialization Callbacks"></a>Initialization Callbacks</h5><p>The <code>org.springframework.beans.factory.InitializingBean</code> interface lets a bean perform initialization work after the container has set all necessary properties on the bean. The <strong><code>InitializingBean</code> interface specifies a single method</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>However, it is <strong>not recommend that you use the <code>InitializingBean</code> interface, because it unnecessarily couples the code to Spring</strong>. Alternatively, we suggest using the <code>@PostConstruct</code> annotation or specifying a POJO initialization method.</p>
<p>The <code>@PostConstruct</code> annotation can be used for annotating** a method that should be run once immediately after the bean’s initialization**. Keep in mind that the annotated method will be executed by Spring even if there is nothing to inject.</p>
<p>Here’s <code>@PostConstruct</code> in action:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostConstructExampleBean</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PostConstruct</span>  <span class="comment">// called immediately after successful initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">betterApproach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        env.getActiveProfiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the example above you can see that the Environment instance was <strong>safely injected and then called in the <code>@PostConstruct</code> annotated method without throwing a <code>NullPointerException</code></strong>.</p>
<h5 id="Destruction-Callbacks"><a href="#Destruction-Callbacks" class="headerlink" title="Destruction Callbacks"></a>Destruction Callbacks</h5><p>Implementing the <code>org.springframework.beans.factory.DisposableBean</code> interface lets a bean get a callback when the container that contains it is destroyed. The <strong><code>DisposableBean</code> interface specifies a single method</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>It is recommended that you <strong>do not use the <code>DisposableBean</code> callback interface</strong>, because it unnecessarily couples the code to Spring. Alternatively, we <strong>suggest using the <code>@PreDestroy</code> annotation</strong> or specifying a generic method that is supported by bean definitions.</p>
<p><strong>A method annotated with <code>@PreDestroy</code> runs only once, just before Spring removes our bean from the application context</strong>.</p>
<p>Same as with <code>@PostConstruct</code>, the methods annotated with <code>@PreDestroy</code> can have any access level but can’t be static.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> DbConnection dbConnection;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dbConnection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <strong>purpose of this method should be to release resources or perform any other cleanup tasks before the bean gets destroyed</strong>, for example closing a database connection.</p>
<blockquote>
<p>Note:</p>
<ul>
<li><input disabled type="checkbox"> Note that both <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations are part of Java EE. And since Java EE <strong>has been deprecated in Java 9 and removed in Java 11</strong> we have to add an additional dependency to use these annotations if you are using versions of Java beyond 11.</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.annotation&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.annotation-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Default-initMethod-and-destroyMethod"><a href="#Default-initMethod-and-destroyMethod" class="headerlink" title="Default initMethod and destroyMethod"></a>Default <code>initMethod</code> and <code>destroyMethod</code></h5><p>When you write initialization and destroy method callbacks that do not use the Spring-specific <code>InitializingBean</code> and <code>DisposableBean</code> callback interfaces, you <strong>should</strong> typically write methods with names such as <code>init()</code>, <code>initialize()</code>, <code>dispose()</code>, and so on. Ideally, the names of such lifecycle callback methods are <strong>standardized across a project so that all developers use the same method names and ensure consistency</strong>.</p>
<p>More importantly, you can <strong>specify a default <code>initMethod</code> property or a <code>destroyMethod</code></strong> that can be used to always execute a method <strong>after a bean’s initialization/before destruction</strong>.</p>
<p>Here’s what a bean looks like:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitMethodExampleBean</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some initialization work;</span></span><br><span class="line">		<span class="comment">// notice no interface nor annotation is used here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can notice that there are <strong>no special interfaces implemented nor any special annotations used</strong>.</p>
<p>Then, we can <strong>define the bean using the <code>@Bean(intiMethod=&quot;&lt;initMethodName&gt;&quot;)</code> annotation</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>)  <span class="comment">// the key step</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InitMethodExampleBean <span class="title">exBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InitMethodExampleBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And this is will be equivalent to the XML config:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"initMethodExampleBean"</span> <span class="attr">class</span>=<span class="string">"com.something.InitMethodExampleBean"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>The presence of the <code>initMethod=&quot;init&quot;</code> attribute on the top-level causes the <strong>Spring IoC container to recognize a method called <code>init</code> on the bean class as the initialization method callback</strong>. When a bean is created and assembled, if the bean class has such a method, it is invoked at the appropriate time.</p>
<p>You can configure destroy method callbacks similarly by using the <code>@Bean(destroyMethod=&quot;&lt;destroyMethoName&gt;&quot;)</code> attribute on the top-level.</p>
<h5 id="Combining-Lifecycle-Mechanisms"><a href="#Combining-Lifecycle-Mechanisms" class="headerlink" title="Combining Lifecycle Mechanisms"></a>Combining Lifecycle Mechanisms</h5><p>Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows <strong>in order</strong>:</p>
<ul>
<li>Methods annotated with <code>@PostConstruct</code></li>
<li><code>afterPropertiesSet()</code> as defined by the <code>InitializingBean</code> callback interface</li>
<li>A custom configured <code>init()</code> method</li>
</ul>
<p>Destroy methods are called in the same order:</p>
<ul>
<li>Methods annotated with <code>@PreDestroy</code></li>
<li><code>destroy()</code> as defined by the <code>DisposableBean</code> callback interface</li>
<li>A custom configured <code>destroy()</code> method</li>
</ul>
<h5 id="Startup-and-Shutdown-Callbacks"><a href="#Startup-and-Shutdown-Callbacks" class="headerlink" title="Startup and Shutdown Callbacks"></a>Startup and Shutdown Callbacks</h5><p>The <code>Lifecycle</code> interface defines the <strong>essential methods for any object that has its own lifecycle requirements</strong> (such as starting and stopping some background process):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Any Spring-managed object may implement the <code>Lifecycle</code> interface. Then, when the <code>ApplicationContext</code> itself receives start and stop signals (for example, <strong>for a stop/restart scenario at runtime</strong>), it <strong>cascades those calls to all <code>Lifecycle</code> implementations defined within that context</strong>. It does this by delegating to a <code>LifecycleProcessor</code>, shown in the following listing:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice that the <code>LifecycleProcessor</code> is itself an extension of the <code>Lifecycle</code> interface. It also <strong>adds two other methods for reacting to the context being refreshed and closed</strong>.</p>
<blockquote>
<p>Note:</p>
<ul>
<li><input disabled type="checkbox"> Note that the regular <code>org.springframework.context.Lifecycle</code> interface is a plain contract for explicit start and stop notifications and <strong>does not imply auto-startup at context refresh time</strong>. For fine-grained control over auto-startup of a specific bean (including startup phases), consider implementing <code>org.springframework.context.SmartLifecycle</code> instead.</li>
</ul>
</blockquote>
<h5 id="Order-of-Startup-and-Shutdown-with-Dependencies"><a href="#Order-of-Startup-and-Shutdown-with-Dependencies" class="headerlink" title="Order of Startup and Shutdown with Dependencies"></a>Order of Startup and Shutdown with Dependencies</h5><p>The order of startup and shutdown invocations can be important. If a “depends-on” relationship exists between any two objects, the dependent side starts after its dependency, and it stops before its dependency. However, sometimes you might not want this order of execution. In this case, you would need to use the <code>SmartLifeCycle</code> Interface:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and the <code>Phased</code> interface looks like:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When starting, the <strong>objects with the lowest phase start first</strong>. When <strong>stopping, the reverse order is followed</strong>. Therefore, an object that implements <code>SmartLifecycle</code> and whose <code>getPhase()</code> method returns <code>Integer.MIN_VALUE</code> would be among the first to start and the last to stop. At the other end of the spectrum, a phase value of <code>Integer.MAX_VALUE</code> would indicate that the object should be started last and stopped first (likely because it depends on other processes to be running). When considering the phase value, it is also important to know that the <strong>default phase for any “normal” Lifecycle object that does not implement <code>SmartLifecycle</code> is <code>0</code></strong>.</p>
<h5 id="Shuttingdown-a-Non-Web-application"><a href="#Shuttingdown-a-Non-Web-application" class="headerlink" title="Shuttingdown a Non-Web application"></a>Shuttingdown a Non-Web application</h5><p>If you use Spring’s IoC container in a non-web application environment (for example, in a rich client desktop environment), you should <strong>register a shutdown hook</strong> with the JVM. Doing so ensures a <strong>graceful shutdown and calls the relevant destroy methods on your singleton beans so that all resources are released</strong>. You must <strong>still configure and implement these destroy callbacks correctly</strong> (e.g. with <code>@Bean(destoryMethod=&quot;dispose&quot;)</code>, and implement the <code>dispose()</code> methods).</p>
<p>To register a shutdown hook, call the <code>registerShutdownHook()</code> method that is declared on the <code>ConfigurableApplicationContext</code> interface, as the following example shows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add a shutdown hook for the above context...</span></span><br><span class="line">        ctx.registerShutdownHook();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// app runs here...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// main method exits, hook is called prior to the app shutting down...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ApplicationContextAware-and-BeanNameAware"><a href="#ApplicationContextAware-and-BeanNameAware" class="headerlink" title="ApplicationContextAware and BeanNameAware"></a><code>ApplicationContextAware</code> and <code>BeanNameAware</code></h5><p>When an <strong><code>ApplicationContext</code> creates an object instance that implements the <code>org.springframework.context.ApplicationContextAware</code> interface</strong>, the <strong>instance is provided with a reference to that <code>ApplicationContext</code></strong>. This means that object could manipulate the container. The following listing shows the definition of the ApplicationContextAware interface:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thus, beans can programmatically manipulate the <code>ApplicationContext</code> that created them, through the <code>ApplicationContext</code> interface or by casting the reference to a known subclass of this interface (such as <code>ConfigurableApplicationContext</code>, which exposes additional functionality). One use would be the programmatic retrieval of other beans. Sometimes this capability is useful. <strong>However, in general, you should avoid it, because it couples the code to Spring and does not follow the Inversion of Control style</strong>, where collaborators are provided to beans as properties.</p>
<p>When an <code>ApplicationContext</code> creates a class that implements the <code>org.springframework.beans.factory.BeanNameAware</code> interface, <strong>the class is provided with a reference to the bean</strong> with name defined in its associated object definition. The following listing shows the definition of the BeanNameAware interface:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The callback is <strong>invoked after population of normal bean properties but before an initialization callback such as <code>InitializingBean</code>, <code>afterPropertiesSet</code>, or a custom <code>init-method</code></strong>.</p>
<h4 id="Bean-Definition-Inheritance"><a href="#Bean-Definition-Inheritance" class="headerlink" title="Bean Definition Inheritance"></a>Bean Definition Inheritance</h4><p>(additional reference: <a href="https://www.tutorialspoint.com/spring/spring_bean_definition_inheritance.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/spring/spring_bean_definition_inheritance.htm</a>)</p>
<p>A bean definition can contain a lot of configuration information, including constructor arguments, property values, and container-specific information, such as the initialization method, a static factory method name, and so on. <strong>A child bean definition inherits configuration data from a parent definition</strong>. The child definition can override some values or add others as needed. Using parent and child bean definitions can save a lot of typing. Effectively, this is a form of templating.</p>
<p>In Java, this should be simple enough to have the <code>extends</code> keyword for that specific class, and then use <code>@Bean</code> at the correct place. You could also inherit an <code>@Configuration</code> class, which will also inherit all the <code>@Bean</code> configurations with it.</p>
<p>Without using the XML file, it should be similar to the normal Java inheritance.</p>
<h4 id="Customizing-your-Container"><a href="#Customizing-your-Container" class="headerlink" title="Customizing your Container"></a>Customizing your Container</h4><p>Typically, an application developer does not need to subclass ApplicationContext implementation classes. Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces, or simply by using some anotations, in order to <strong>add some customized functionalities for the container (e.g. <code>@Autowired</code> is one example)</strong></p>
<h5 id="Using-Primary"><a href="#Using-Primary" class="headerlink" title="Using @Primary"></a>Using @Primary</h5><p>Because autowiring by type <strong>may lead to multiple candidates</strong>, it is often necessary to have more control over the selection process. One way to accomplish this is with Spring’s <code>@Primary</code> annotation. <code>@Primary</code> indicates that <strong>a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency</strong>. If exactly one primary bean exists among the candidates, it becomes the autowired value.</p>
<p>Consider the following configuration that defines <strong><code>firstMovieCatalog</code> as the primary <code>MovieCatalog</code></strong> if an <code>MovieCatalog</code> is to be autowired:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">firstMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">secondMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With the preceding configuration, the following <code>MovieRecommender</code> is autowired with the <code>firstMovieCatalog</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;  <span class="comment">// so that the firstMovieCatalog would be created</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Using-Qualifier"><a href="#Using-Qualifier" class="headerlink" title="Using @Qualifier"></a>Using @Qualifier</h5><p><code>@Primary</code> is an effective way to use autowiring by type with several instances when one primary candidate can be determined. When you need even more control over the selection process, for example <strong>letting each bean to be autowired in a different setting</strong>, you can use Spring’s <code>@Qualifier</code> annotation. <strong>You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument</strong>. In the simplest case, this can be a plain descriptive value, as shown in the following example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"main"</span>)</span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can also specify the <code>@Qualifier</code> annotation on individual constructor arguments or method parameters, as shown in the following example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(@Qualifier(<span class="string">"main"</span>)</span> MovieCatalog movieCatalog) </span>&#123;  <span class="comment">// specifies which MovieCatalog gets used</span></span><br><span class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Type-Matching-for-Generics"><a href="#Type-Matching-for-Generics" class="headerlink" title="Type Matching for Generics"></a>Type Matching for Generics</h5><p>In addition to the <code>@Qualifier</code> annotation, you can use <strong>Java generic types as an implicit form of qualification</strong>. For example, suppose you have the following configuration:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringStore <span class="title">stringStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringStore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IntegerStore <span class="title">integerStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntegerStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Assuming that the preceding beans <strong>implement a generic interface, (that is, <code>Store&lt;String&gt;</code> and <code>Store&lt;Integer&gt;</code>)</strong>, you can <code>@Autowire</code> the <code>Store</code> interface and the generic is used as a qualifier, as the following example shows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;String&gt; s1; <span class="comment">// equivalent as having a &lt;String&gt; qualifier, injects the stringStore bean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Store&lt;Integer&gt; s2; <span class="comment">// equivalent as having a &lt;Integer&gt; qualifier, injects the integerStore bean</span></span><br></pre></td></tr></table></figure>

<p>Generic qualifiers also apply when autowiring <code>List</code>s, <code>Map</code> instances and <code>Array</code>s. The following example autowires a generic List:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inject all Store beans as long as they have an &lt;Integer&gt; generic</span></span><br><span class="line"><span class="comment">// Store&lt;String&gt; beans will not appear in this list</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Store&lt;Integer&gt;&gt; s;</span><br></pre></td></tr></table></figure>

<h5 id="Using-Resource"><a href="#Using-Resource" class="headerlink" title="Using @Resource"></a>Using @Resource</h5><p>(additional reference: <a href="https://www.baeldung.com/spring-annotations-resource-inject-autowire" target="_blank" rel="noopener">https://www.baeldung.com/spring-annotations-resource-inject-autowire</a>)</p>
<p>The <code>@Resource</code> annotation is part of the JSR-250 annotation collection and is packaged with Jakarta EE. This is used for <strong>field or setter dependency injection</strong>. This annotation has the following execution order:</p>
<ul>
<li>Match by Name (if a name is specified as an argument to <code>@Resource</code>, so it resolves the bean with the name specified)</li>
<li>Match by Type (if a name is not specified as an argument to <code>@Resource</code>, so it resolves the name by type )</li>
<li>Match by Qualifier (if a name is specified as an argument to <code>@Resource</code>, but there is no bean with that name nor resolvable by type, then need to be resolved by <code>@Qualifier</code>)</li>
</ul>
<p>These execution paths are applicable to both setter and field injection.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/09/Spring-Framework-Guide/" data-id="ckb7qqory0001xworgz0y9qwv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/06/09/SpringBoot-Manual/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Spring Boot Manual</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/09/Spring-Framework-Guide/">Spring Framework Guide</a>
          </li>
        
          <li>
            <a href="/2020/06/09/SpringBoot-Manual/">Spring Boot Manual</a>
          </li>
        
          <li>
            <a href="/2020/06/02/Redis-Manual/">Redis Manual</a>
          </li>
        
          <li>
            <a href="/2020/05/26/MySQL-Manual/">MySQL Manual</a>
          </li>
        
          <li>
            <a href="/2020/05/25/Docker-Manual/">Docker Manual</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Xiao Yu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>