<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Docker Manual | From a Beginner to a Disaster</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IMPORTANT:Much of the content here is a personal summary&#x2F;abbrieviation of contents on the Offical Docker Guide. For more complete information, please refer to the offical site.  Docker IntroDocker pr">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker Manual">
<meta property="og:url" content="http://yoursite.com/2020/05/25/Docker-Manual/index.html">
<meta property="og:site_name" content="From a Beginner to a Disaster">
<meta property="og:description" content="IMPORTANT:Much of the content here is a personal summary&#x2F;abbrieviation of contents on the Offical Docker Guide. For more complete information, please refer to the offical site.  Docker IntroDocker pr">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-05-25T07:18:39.000Z">
<meta property="article:modified_time" content="2020-05-29T07:40:37.649Z">
<meta property="article:author" content="Xiao Yu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="From a Beginner to a Disaster" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">From a Beginner to a Disaster</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Xiao.Y</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Docker-Manual" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/25/Docker-Manual/" class="article-date">
  <time datetime="2020-05-25T07:18:39.000Z" itemprop="datePublished">2020-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Docker Manual
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p><strong>IMPORTANT</strong>:<br>Much of the content here is a personal summary/abbrieviation of contents on the <a href="https://docs.docker.com/get-started/" target="_blank" rel="noopener">Offical Docker Guide</a>. For more complete information, please refer to the offical site.</p>
<hr>
<h2 id="Docker-Intro"><a href="#Docker-Intro" class="headerlink" title="Docker Intro"></a>Docker Intro</h2><p>Docker provides the ability to package and run an application in a loosely isolated environment called a <strong><code>container</code></strong>, which <strong>separate your applications from your infrastructure</strong>. The <strong>isolation and security</strong> allow you to run many containers simultaneously on a given host.</p>
<p>The use of <code>container</code>s to deploy applications is called containerization. Containers are not new, but their use for easily deploying applications is.</p>
<p>Docker provides tooling and a platform to manage the lifecycle of your <code>container</code>s:</p>
<ul>
<li>Develop your application and its supporting components using <code>container</code>s.</li>
<li>The <code>container</code> becomes the unit for distributing and testing your application.</li>
<li>When you’re ready, deploy your application into your production environment, as a <code>container</code> or an orchestrated service. This works the same whether your production environment is a local data center, a cloud provider, or a hybrid of the two.</li>
</ul>
<h2 id="Docker-Basics"><a href="#Docker-Basics" class="headerlink" title="Docker Basics"></a>Docker Basics</h2><p><strong>Docker is mainly composed of the following elements</strong> (the first three is referred as Docker Engine by the official site): </p>
<ul>
<li><strong>A server</strong> (<code>docker daemon</code>) which is a type of long-running program called a daemon process (the <code>dockerd</code>command).</li>
<li><strong>A command line interface (CLI)</strong> client that is used by most users (the <code>docker</code>command).</li>
<li><strong>A REST API</strong> which specifies interfaces that <strong>CLI</strong> programs can use to <strong>talk to the daemon</strong> and <strong>instruct it what to do</strong>.</li>
<li><strong>A Docker registry</strong>, which stores Docker images. Docker Hub is a public registry that anyone can use, and Docker is configured to look for images on Docker Hub by default.</li>
</ul>
<p>So we see that Docker uses a client-server architecture. The <strong><code>docker client</code> talks to the <code>docker daemon</code></strong>, which does the heavy lifting of building, running, and distributing your Docker containers. The Docker <code>client</code> and <code>daemon</code> can run on the same system, or you can connect a Docker client to a remote Docker daemon.</p>
<h2 id="Docker-Architecture"><a href="#Docker-Architecture" class="headerlink" title="Docker Architecture"></a>Docker Architecture</h2><ul>
<li><p>The <strong>Docker <code>daemon</code></strong></p>
<ul>
<li>The Docker <code>daemon</code> (<code>dockerd</code>) listens for Docker API requests and manages Docker objects such as <code>images</code>, <code>container</code>s, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.</li>
</ul>
</li>
<li><p><strong>The Docker <code>client</code></strong></p>
<ul>
<li>The Docker <code>client</code> (<code>docker</code>) is the primary way that many Docker users interact with Docker. When you use commands such as <code>docker run</code>, the client sends these commands to <code>dockerd</code>, which carries them out. The docker command uses the Docker API. The Docker client can communicate with more than one daemon.</li>
</ul>
</li>
<li><p><strong>Docker registries</strong></p>
<ul>
<li>A Docker registry stores Docker <code>image</code>s. Docker Hub is a public registry that anyone can use, and Docker is configured to look for images on Docker Hub by default. You can even run your own private registry. If you use Docker Datacenter (DDC), it includes Docker Trusted Registry (DTR).</li>
</ul>
</li>
<li><p><strong>Docker objects</strong></p>
<ul>
<li>When you use Docker, you are creating and using <code>images</code>, <code>container</code>s, networks, volumes, plugins, and other objects. The section below is a brief overview of some of those objects.</li>
</ul>
</li>
</ul>
<h2 id="Docker-Objects"><a href="#Docker-Objects" class="headerlink" title="Docker Objects"></a>Docker Objects</h2><ul>
<li><p><code>IMAGE</code></p>
<ul>
<li>An <code>image</code> is a <strong>read-only template</strong> with <strong>instructions for creating a Docker <code>container</code></strong>. Often, an <code>image</code> is based on another <code>image</code>, with some additional customization. For example, you may build an image which is based on the ubuntu image, but installs the Apache web server and your application, as well as the configuration details needed to make your application run.</li>
</ul>
</li>
<li><p><code>CONTAINER</code></p>
<ul>
<li><p>A container is a <strong>runnable instance of an <code>image</code></strong>. You can create, start, stop, move, or delete a <code>container</code> using the Docker API or CLI. You can connect a <code>container</code> to one or more networks, attach storage to it, or even create a new image based on its current state.</p>
<p>Fundementally, a <strong><code>container</code> is nothing but a running process, with some added encapsulation features applied to it in order to keep it isolated from the host and from other containers</strong>. One of the most important aspects of container isolation is that each container interacts with its <strong>own private filesystem</strong>.</p>
<p>By default, a container is relatively well isolated from other <code>container</code>s and its host machine. You can control how isolated a container’s network, storage, or other underlying subsystems are from other containers or from the host machine.</p>
<p>A <code>container</code> is <strong>defined by its image as well as any configuration options you provide to it when you create or start it</strong>. When a container is <strong>removed</strong>, any changes to its state that are <strong>not stored in persistent storage</strong> disappear.</p>
</li>
</ul>
</li>
<li><p><code>SERVICE</code></p>
<ul>
<li><p>Services allow you to <strong>scale <code>container</code>s across multiple Docker <code>daemons</code></strong>, which all work together as a swarm with multiple managers and workers. Each member of a swarm is a Docker <code>daemon</code>, and all the daemons communicate using the Docker API. A <code>service</code> allows you to <strong>define states</strong>, such as the <strong>number of replicas of the service</strong> that must be available at any given time. </p>
<p>By default, the service is <strong>load-balanced across all worker nodes</strong>. To the consumer, the Docker service appears to be a single application. Docker Engine supports swarm mode in Docker 1.12 and higher.</p>
</li>
</ul>
</li>
</ul>
<h2 id="Installing-Docker"><a href="#Installing-Docker" class="headerlink" title="Installing Docker"></a>Installing Docker</h2><p>Please follow the <a href="#https://docs.docker.com/get-started/">Official Guide</a>.</p>
<h2 id="Basic-Workflow"><a href="#Basic-Workflow" class="headerlink" title="Basic Workflow"></a>Basic Workflow</h2><p>In general, the development workflow for containerized applications looks like this:</p>
<ol>
<li><strong>Create</strong> a Docker <code>image</code> containing the components of your application</li>
<li><strong>Test</strong> those components</li>
<li><strong>Assemble</strong> your containers using the <code>image</code> file and supporting infrastructure into a complete application</li>
<li>Test, share, and deploy your complete containerized application.</li>
</ol>
<h2 id="Quickstart-for-Building-an-Image-and-a-Container"><a href="#Quickstart-for-Building-an-Image-and-a-Container" class="headerlink" title="Quickstart for Building an Image and a Container"></a>Quickstart for Building an Image and a Container</h2><p>First, we could use an existing project to demonstrate some concepts mentioned above.</p>
<ol>
<li><p>Run:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;dockersamples&#x2F;node-bulletin-board</span><br><span class="line">cd node-bulletin-board&#x2F;bulletin-board-app</span><br></pre></td></tr></table></figure>

<p> Then you will see that there is a file called <strong><code>Dockerfile</code></strong>. <strong><code>Dockerfile</code></strong>s describe <strong>how to build an <code>image</code> and assemble a <code>container</code></strong> with a private filesystem, and can also contain some metadata describing <strong>how to run a <code>container</code></strong> based on this image. </p>
<p> The bulletin board app <strong><code>Dockerfile</code></strong> looks like this:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Use the official image as a parent image.</span><br><span class="line">FROM node:current-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory.</span><br><span class="line">WORKDIR &#x2F;usr&#x2F;src&#x2F;app</span><br><span class="line"></span><br><span class="line"># Copy the file from your host to your current location.</span><br><span class="line">COPY package.json .</span><br><span class="line"></span><br><span class="line"># Run the command inside your image filesystem.</span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"># Inform Docker that the container is listening on the specified port at runtime.</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"># Run the specified command within the container.</span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br><span class="line"></span><br><span class="line"># Copy the rest of your app&#39;s source code from your host to your image filesystem.</span><br><span class="line">COPY . .</span><br></pre></td></tr></table></figure>
<p> You can think of these <strong><code>Dockerfile</code></strong> commands as a step-by-step recipe on how to build up your <code>image</code>. </p>
</li>
<li><p>Make sure you’re in the directory <code>node-bulletin-board/bulletin-board-app</code> in a terminal or PowerShell using the cd command. Let’s build your bulletin board <code>image</code>:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --tag bulletinboard:1.0 .</span><br></pre></td></tr></table></figure>

<p> You’ll see <strong>Docker step through each instruction in your <code>Dockerfile</code></strong>, building up your <code>image</code> as it goes: </p>
<ul>
<li><p>Start <strong>FROM</strong> the pre-existing <code>node:current-slim</code> image. This is an official image, built by the node.js vendors and validated by Docker to be a high-quality image containing the Node.js Long Term Support (LTS) interpreter and basic dependencies.</p>
</li>
<li><p>Use <strong>WORKDIR</strong> to specify that all subsequent actions should be taken from the directory /usr/src/app in your image filesystem (never the host’s filesystem).</p>
</li>
<li><p><strong>COPY</strong> the file <code>package.json</code> from your host to the present location (<code>.</code>) in your image (so in this case, to /usr/src/app/package.json)</p>
</li>
<li><p><strong>RUN</strong> the command <code>npm install</code> inside your image filesystem (which will read <code>package.json</code> to determine your app’s node dependencies, and install them)</p>
</li>
<li><p><strong>COPY</strong> in the rest of your app’s source code from your host to your image filesystem.</p>
<p>If successful, the build process should end with a message <code>Successfully tagged bulletinboard:1.0</code>.</p>
<p>The steps above built up the filesystem of our image, but there are other lines in your <code>Dockerfile</code>.</p>
</li>
<li><p>The <strong>CMD</strong> directive is the first example of specifying some metadata in your <code>image</code> that <strong>describes how to run a container based on this image</strong>. In this case, it’s saying that the containerized process that this <code>image</code> is meant to support is <code>npm start</code>.</p>
</li>
<li><p>The <strong>EXPOSE</strong> <code>8080</code> informs Docker that the container is listening on port <code>8080</code> at runtime.</p>
</li>
</ul>
</li>
<li><p>Now you have an <code>image</code> and you can start a <code>container</code> based on the <code>image</code>:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --publish 8000:8080 --detach --name  bb bulletinboard:1.0</span><br></pre></td></tr></table></figure>

<p> This has a couple of common flags:</p>
<ul>
<li><code>--publish</code> asks Docker to <strong>forward traffic incoming on the host’s port 8000</strong>, <strong>to the container’s port 8080</strong>. Containers have their own private set of ports, so if you want to reach one from the network, you have to forward traffic to it in this way. Otherwise, firewall rules will prevent all network traffic from reaching your container, as a default security posture.</li>
<li><code>--detach</code> asks Docker to <strong>run this container in the background</strong>.</li>
<li><code>--name</code> specifies a <strong>name with which you can refer to your container in subsequent commands</strong>, in this case <code>bb</code>.</li>
</ul>
</li>
<li><p>Now, you can visit the application in a browser at <code>localhost:8000</code>. <strong>At this step</strong>, it would be the time to <strong>run unit tests</strong>, for example. You would normally do everything you could to ensure your container works the way you expected.</p>
<p> Once you’re satisfied that your bulletin board container works correctly, you can delete it:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm --force bb</span><br></pre></td></tr></table></figure>

<p> The <code>--force</code> option stops a running container, so it can be removed. If you stop the container running with <code>docker stop bb</code> first, then you do not need to use <code>--force</code> to remove it.</p>
</li>
</ol>
<p>At this point, you’ve successfully <strong>built an <code>image</code></strong>, <strong>performed a simple containerization of an application using that <code>image</code></strong>, and confirmed that your app runs successfully in its container.</p>
<h2 id="Quickstart-for-Sharing-Images-on-Docker-Hub"><a href="#Quickstart-for-Sharing-Images-on-Docker-Hub" class="headerlink" title="Quickstart for Sharing Images on Docker Hub"></a>Quickstart for Sharing Images on Docker Hub</h2><p>At this point, <strong>you’ve built a containerized application</strong>. The final step is to <strong>share your images on a <code>registry</code> like Docker Hub</strong>, so they can be easily downloaded and run on any destination machine. (first you need to have a Docker Hub account, if needed help, follow <a href="#https://docs.docker.com/get-started/part3/#set-up-your-docker-hub-account">this guide</a>)</p>
<ol>
<li><p>Once you have an account, you need to create a repository. At this point, you can only <strong>specify a repository name</strong>, for example, <code>bulletin</code>, and click create.</p>
</li>
<li><p>Now you are ready to share your <code>image</code> on Docker Hub, but there’s <strong>one thing you must do first</strong>: images must be <strong>namespaced correctly to share on Docker Hub</strong>. Specifically, you must name images like <code>&lt;Docker ID&gt;/&lt;Repository Name&gt;:&lt;tag&gt;</code>.</p>
<p> For example, if your username is <code>abc</code> and the name of your created repository is <code>bulletin</code>, then you <strong>need to tag your image to be: <code>abc/bulletin:&lt;whateverVersionHere&gt;</code></strong>. This is because, when you push in the next step, Docker will look up specifically at location <code>abc/bulletin</code> in Docker Hub. If you spelled something wrongly, it will not go to the correct location.</p>
</li>
<li><p>Finally, push your <code>image</code> to Docker Hub. For example, like this:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push abc&#x2F;bulletin:1.0</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Now that your image is available on Docker Hub, you’ll be able to run it anywhere. By moving images around in this way, you <strong>no longer need to install any dependencies except Docker on the machines</strong> you want to run your software on. The dependencies of containerized applications are completely encapsulated and isolated within your images, which you can share using Docker Hub as described above.</p>
<p>However, there is one thing to keep in mind: at the moment, you’ve only <strong>pushed your <code>image</code></strong> to Docker Hub; <strong>what about your <code>Dockerfile</code></strong>? A crucial best practice is to <strong>keep these in version control (e.g.  using <code>git</code>), perhaps alongside your source code for your application</strong>. You can add a link or note in your Docker Hub repository description indicating where these files can be found, preserving the record not only of how your image was built, but how it’s meant to be run as a full application.</p>
<h2 id="Starting-and-Stopping-Containers"><a href="#Starting-and-Stopping-Containers" class="headerlink" title="Starting and Stopping Containers"></a>Starting and Stopping Containers</h2><ul>
<li><p>To create a new <code>container</code> from an <code>image</code> and start it, use <code>docker run</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [options] &lt;image&gt; [command] [argument]</span><br></pre></td></tr></table></figure>

<p>  Usually, you would want to specify a name for your container, which means you add the <code>--name</code> option. For example:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ––name&#x3D;Ubuntu-Test ubuntu:14.04</span><br></pre></td></tr></table></figure>
<p>  where <code>ubuntu:14.04</code> would be the <code>ubuntu</code> image with version/tag <code>14.04</code>. However, if you do not define a name for your newly created container, the <code>deamon</code> will <strong>generate a random string name</strong>, which you can later check with the <code>docker ps</code> command (see the section <a href="#Viewing-and-Removing-Containers">Viewing and Removing Containers</a>)</p>
<p>  However, this would only start a <code>container</code>. If you would like to interact with it, you need to add the <code>–i</code> and <code>–t</code> options to enter the interative mode. For example, to enter the Ubuntu bash in the ubuntu container created in the above example, you could run:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run –it ––name&#x3D;Ubuntu_Test ubuntu:14.04</span><br></pre></td></tr></table></figure>
<p>  Instead of using <code>-i</code> or <code>-t</code> options, use the <code>attach</code> command to connect to a running container as well:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach container_id</span><br></pre></td></tr></table></figure>
<p>  (To <strong>exit the container</strong>, you can type <code>EXIT</code>)</p>
</li>
<li><p>To stop a <code>container</code>, you could use the <code>docker stop</code> command:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [option] &lt;container_id&gt;</span><br></pre></td></tr></table></figure>

<p>  By default, you get a 10 second grace period if you run <code>docker stop</code>. This means that the <code>stop</code> command instructs the <code>container</code> to <strong>stop services after that 10 seconds period</strong>. You can also use the <code>--time</code> option to define a different grace period expressed in seconds, for example:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop --time&#x3D;20 &lt;container_id&gt;</span><br></pre></td></tr></table></figure>

<p>  If you want to immediately kill a docker <code>container</code> without waiting for the grace period to end, use:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill [option] &lt;container_id&gt;</span><br></pre></td></tr></table></figure>

<p>  Additionally, a useful command is to <strong>stop (or kill) all running containers</strong>:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps –a –q)</span><br></pre></td></tr></table></figure>
<p>  If you want to <code>kill</code> those <code>container</code>s, just replace the <code>stop</code> with <code>kill</code>.</p>
</li>
</ul>
<h2 id="Viewing-and-Removing-Unwanted-Images"><a href="#Viewing-and-Removing-Unwanted-Images" class="headerlink" title="Viewing and Removing Unwanted Images"></a>Viewing and Removing Unwanted Images</h2><ul>
<li><p>To view the <code>image</code>s, you could use the command:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>  to provide you with a list of images that you have created. For example, they might look like this:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">bulletinboard                   1.0                 2cd431e8ee37        3 hours ago         182MB</span><br><span class="line">mysql                           8.0                 30f937e841c8        4 days ago          541MB</span><br><span class="line">node                            current-slim        8ec3841e41bb        4 days ago          165MB</span><br><span class="line">ubuntu                          latest              1d622ef86b13        4 weeks ago         73.9MB</span><br></pre></td></tr></table></figure></li>
<li><p>To remove an <code>image</code>, you need to specify <strong>both the name and the version</strong> (<code>tag</code>) in the format <code>&lt;name&gt;:&lt;version&gt;</code>. For example, to remove the <code>bulletinboard</code> image, you could do:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm -f bulletinboard:1.0</span><br></pre></td></tr></table></figure>

<p>  However, if it is at the <code>latest</code> version/tag, then you can just specify the name:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm -f ubuntu</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note:</p>
<ul>
<li><input disabled type="checkbox"> The <code>-f</code> or <code>--force</code> option is <strong>only necessay when you have the <code>container</code> running</strong>. If it is not running, it can be removed just by specifying <code>docker image rm</code></li>
</ul>
</blockquote>
</li>
</ul>
<p><a name="Viewing-and-Removing-Containers"></a></p>
<h2 id="Viewing-and-Removing-Containers"><a href="#Viewing-and-Removing-Containers" class="headerlink" title="Viewing and Removing Containers"></a>Viewing and Removing Containers</h2><ul>
<li><p>To list all <strong>running containers</strong>, you can use the command:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>  which, for example, could gives you:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                             PORTS                 NAMES</span><br><span class="line">a22b3d54d5f4        mysql&#x2F;mysql-server:latest   &quot;&#x2F;entrypoint.sh mysq…&quot;   18 seconds ago      Up 17 seconds (health: starting)   3306&#x2F;tcp, 33060&#x2F;tcp   test-sql-server</span><br></pre></td></tr></table></figure>

<p>  However, if you would like to see also stopped <code>container</code>s, you could use the <code>-a</code> or <code>--all</code> flag:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>  Some of the other <strong>useful options</strong> include:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>--filter</code> , <code>-f</code></td>
<td>-</td>
<td>Filter output based on conditions provided</td>
</tr>
<tr>
<td><code>--format</code></td>
<td>-</td>
<td>Pretty-print containers using a Go template</td>
</tr>
<tr>
<td><code>--last</code>, <code>-n</code></td>
<td>-1</td>
<td>Show n last created containers (includes all states)</td>
</tr>
<tr>
<td><code>--latest</code> , <code>-l</code></td>
<td>-</td>
<td>Show the latest created container (includes all states)</td>
</tr>
<tr>
<td><code>--no-trunc</code></td>
<td>-</td>
<td>Don’t truncate output</td>
</tr>
<tr>
<td><code>--quiet</code> , <code>-q</code></td>
<td>-</td>
<td>Only display numeric IDs</td>
</tr>
</tbody></table>
<p>  The <code>--filter</code> could be quite useful to select <code>container</code>s you want to see, for example, if you only want to see <code>container</code>s with name having the substring <code>test</code>, you could run:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps --filter &quot;name&#x3D;test&quot;</span><br></pre></td></tr></table></figure>

<p>  For a full list of examples using <code>--format</code>, please refer to the <a href="#https://docs.docker.com/engine/reference/commandline/ps/#filtering">Docker Doc here</a></p>
</li>
<li><p>On the other hand, to remove unwanted <code>container</code>s, you could use the command:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm &lt;container-id&gt;</span><br></pre></td></tr></table></figure>

<p>  where the <code>&lt;container-id&gt;</code> could be seen if you run the <code>docker ps</code> command shown above. If the container is running, you could also force remove it with the <code>--force</code> or <code>-f</code> option.</p>
<p>  For other commands/options related to <code>docker container -rm</code> please refer to the <a href="#https://docs.docker.com/engine/reference/commandline/container_rm/">Docker Doc here</a></p>
</li>
</ul>
<h2 id="Copying-Files-to-and-from-a-Container"><a href="#Copying-Files-to-and-from-a-Container" class="headerlink" title="Copying Files to and from a Container"></a>Copying Files to and from a Container</h2><ul>
<li><p>To copy local files to a container, you can use teh command:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;localPath&gt;&#x2F;&lt;fromFile&gt; &lt;container-id&gt;:&lt;pathInContainer&gt;&#x2F;&lt;toFile&gt;</span><br></pre></td></tr></table></figure>

<p>  For example:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp foo.txt test-container:~&#x2F;foo.txt</span><br></pre></td></tr></table></figure>
<p>  Then you can see the file <code>foo.txt</code> in your container at the path <code>root/foo.txt</code></p>
</li>
<li><p>Similarily, to copy a file from a container to your local machine, you can use:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;container-id&gt;:&lt;pathInContainer&gt;&#x2F;&lt;fromFile&gt; &lt;localPath&gt;&#x2F;&lt;toFile&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Configuring-your-Docker-Daemon"><a href="#Configuring-your-Docker-Daemon" class="headerlink" title="Configuring your Docker Daemon"></a>Configuring your Docker Daemon</h2><p>To configure the Docker daemon using a JSON file, create a file at <code>/etc/docker/daemon.json</code> on Linux systems, or <code>C:\ProgramData\docker\config\daemon.json</code> on Windows. On MacOS go to the whale in the <code>taskbar &gt; Preferences &gt; Daemon &gt; Advanced</code>.</p>
<p>For example, if you want your Docker daemon to run in <code>debug mode</code>, uses <code>TLS</code>, and listens for traffic routed to <code>192.168.59.3</code> on port <code>2376</code>, you would have the following configuration in your <code>daemon.json</code> ( You can learn what configuration options are available in the <a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file" target="_blank" rel="noopener">dockerd reference docs</a>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;debug&quot;: true,</span><br><span class="line">  &quot;tls&quot;: true,</span><br><span class="line">  &quot;tlscert&quot;: &quot;&#x2F;var&#x2F;docker&#x2F;server.pem&quot;,</span><br><span class="line">  &quot;tlskey&quot;: &quot;&#x2F;var&#x2F;docker&#x2F;serverkey.pem&quot;,</span><br><span class="line">  &quot;hosts&quot;: [&quot;tcp:&#x2F;&#x2F;192.168.59.3:2376&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, you could also manually start a daemon with the same configuration in your command line:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dockerd --debug \</span><br><span class="line">  --tls&#x3D;true \</span><br><span class="line">  --tlscert&#x3D;&#x2F;var&#x2F;docker&#x2F;server.pem \</span><br><span class="line">  --tlskey&#x3D;&#x2F;var&#x2F;docker&#x2F;serverkey.pem \</span><br><span class="line">  --host tcp:&#x2F;&#x2F;192.168.59.3:2376</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<ul>
<li><input disabled type="checkbox"> If you use a <code>daemon.json</code> file <strong>and also pass options to the <code>dockerd</code> command</strong> manually or using start-up scripts, and these options conflict, Docker fails to start with an error such as:</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unable to configure the Docker daemon with file &#x2F;etc&#x2F;docker&#x2F;daemon.json:</span><br><span class="line">the following directives are specified both as a flag and in the configuration</span><br><span class="line">file: hosts: (from flag: [unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock], from file: [tcp:&#x2F;&#x2F;127.0.0.1:2376])</span><br></pre></td></tr></table></figure>
<p>If you see an error similar to this one and you are starting the daemon manually with flags, you may need to <strong>adjust your flags or the daemon.json to remove the conflict</strong>.</p>
<p>This means if you want to enter the debug mode, you can set the <code>debug</code> key to <code>true</code> in the <code>daemon.json</code> file. This method works for every Docker platform and is recommended.</p>
<ul>
<li><p>If the file is empty, add the following:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;debug&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>If the file already contains JSON, just add the key <code>&quot;debug&quot;: true</code>, being careful to add a comma to the end of the line if it is not the last line before the closing bracket. Also <strong>verify that if the <code>log-level</code> key is set, it is set to either <code>info</code> or <code>debug</code></strong>. <code>info</code> is the default, and possible values are <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, <code>fatal</code>.</p>
</li>
<li><p>Send a HUP signal to the daemon to cause it to reload its configuration. </p>
<ul>
<li><p>On Linux hosts, use the following command.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo kill -SIGHUP $(pidof dockerd)</span><br></pre></td></tr></table></figure>
</li>
<li><p>On Windows hosts, restart Docker.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note:</p>
<ul>
<li><input disabled type="checkbox"> Instead of following this procedure, you can also <code>stop</code> the Docker <code>daemon</code> and <code>restart</code> it manually with the <code>debug flag -D</code>. However, this may result in Docker <strong>restarting with a different environment than the one the hosts’ startup scripts create</strong>, and this may make debugging more difficult.</li>
</ul>
</blockquote>
<h2 id="Starting-your-Docker-Daemon-Manually"><a href="#Starting-your-Docker-Daemon-Manually" class="headerlink" title="Starting your Docker Daemon Manually"></a>Starting your Docker Daemon Manually</h2><p>Once Docker is installed, <strong>you need to start the Docker daemon</strong>. Most Linux distributions use <code>systemctl</code> to start services. If you do not have <code>systemctl</code>, use the <code>service</code> command.</p>
<ul>
<li><p><code>systemctl</code>:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>service</code>:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker start</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Starting-your-Containers-Automatically"><a href="#Starting-your-Containers-Automatically" class="headerlink" title="Starting your Containers Automatically"></a>Starting your Containers Automatically</h2><p>Docker provides restart policies to <strong>control whether your containers start automatically when they exit, or when Docker restarts</strong>. Restart policies ensure that linked containers are started in the correct order. Docker recommends that you use restart policies, and avoid using process managers to start containers.</p>
<p>To configure the <strong>restart policy</strong> for a container, use the <code>--restart</code> flag when using the <code>docker run</code> command. The value of the <code>--restart</code> flag can be any of the following:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>no</code></td>
<td>Do not automatically restart the container. (the default)</td>
</tr>
<tr>
<td><code>on-failure</code></td>
<td>Restart the container <strong>if it exits due to an error</strong>, which manifests as a non-zero exit code.</td>
</tr>
<tr>
<td><code>always</code></td>
<td><strong>Always restart the container if it stops</strong>. <strong>If it is manually stopped</strong>, it is <strong>restarted only when Docker daemon restarts or the container itself is manually restarted</strong>. (See the second bullet listed in restart policy details)</td>
</tr>
<tr>
<td><code>unless-stopped</code></td>
<td>Similar to always, except that <strong>when the container is stopped (manually or otherwise)</strong>, it is <strong>not restarted even after Docker daemon restarts</strong>.</td>
</tr>
</tbody></table>
<p>The following example starts a Redis container and configures it to always restart unless it is explicitly stopped or Docker is restarted.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --restart unless-stopped redis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<ul>
<li><input disabled type="checkbox"> A restart policy <strong>only takes effect after a container starts successfully (when you run the command specifying the restart policy)</strong>. In this case, starting successfully means that the container is up for at least 10 seconds and Docker has started monitoring it. This <strong>prevents a container</strong> which does not start at all from going <strong>into a restart loop</strong>.</li>
<li><input disabled type="checkbox"> <strong>If you manually stop a container</strong>, <strong>its restart policy is ignored until the Docker daemon restarts or the container is manually restarted</strong>. This is another attempt to <strong>prevent a restart loop</strong>.</li>
<li><input disabled type="checkbox"> Restart policies <strong>only apply to containers</strong>. Restart policies for swarm services are configured differently. See the flags related to service restart.</li>
</ul>
</blockquote>
<h2 id="Keep-Containers-Alive-during-Daemon-Downtime"><a href="#Keep-Containers-Alive-during-Daemon-Downtime" class="headerlink" title="Keep Containers Alive during Daemon Downtime"></a>Keep Containers Alive during Daemon Downtime</h2><p><strong>By default</strong>, when the <strong>Docker daemon terminates</strong>, it <strong>shuts down running containers</strong>. Starting with Docker Engine 1.12, you can <strong>configure the daemon so that containers remain running if the daemon becomes unavailable</strong>. This functionality is called <code>live restore</code>. </p>
<p>There are <strong>two ways to enable the <code>live restore</code> setting</strong> to <strong>keep containers alive when the daemon becomes unavailable</strong>. <strong>Only do one of the following</strong>.</p>
<ul>
<li><p>Add the configuration to the daemon configuration file. On Linux, this defaults to <code>/etc/docker/daemon.json</code>. On Docker Desktop for Mac or Docker Desktop for Windows, select the Docker icon from the task bar, then click Preferences -&gt; Daemon -&gt; Advanced.</p>
<ul>
<li><p>Use the following JSON to enable live-restore.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"live-restore"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Then, restart the Docker daemon. <strong>On Linux</strong>, you can avoid a restart (and avoid any downtime for your containers) by <strong>reloading the Docker daemon</strong>. If you use <code>systemd</code>, then use the command <code>systemctl reload docker</code>. Otherwise, send a SIGHUP signal to the dockerd process.</p>
</li>
</ul>
</li>
<li><p>The other way is to use the <code>--live-restore</code> flag <strong>when you start the dockerd process manually with the <code>--live-restore</code> flag</strong>. This approach is <strong>not recommended because it does not set up the environment that systemd or another process manager would use when starting the Docker process</strong>. This can cause unexpected behavior.</p>
</li>
</ul>
<blockquote>
<p>Note:</p>
<ul>
<li><input disabled type="checkbox"> The live restore option <strong>only works to restore containers if the daemon options</strong>, such as bridge IP addresses and graph driver, <strong>did not change</strong>. If any of these <strong>daemon-level configuration options have changed, the live restore may not work and you may need to manually start the containers</strong>.</li>
<li><input disabled type="checkbox"> If the daemon is down <strong>for a long time</strong>, <strong>running containers may fill up the FIFO log the daemon normally reads</strong>. A full log blocks containers from logging more data. The default buffer size is 64K. <strong>If the buffers fill, you must restart the Docker daemon to flush them</strong>.</li>
</ul>
<p><strong>On Linux</strong>, you can modify the kernel’s buffer size by changing <code>/proc/sys/fs/pipe-max-size</code>. You cannot modify the buffer size on Docker Desktop for Mac or Docker Desktop for Windows.</p>
<ul>
<li><input disabled type="checkbox"> The live restore option <strong>only pertains to standalone containers, and not to swarm services</strong>. Swarm services are managed by <strong>swarm managers</strong>. If swarm managers are not available, swarm services continue to run on worker nodes but cannot be managed until enough swarm managers are available to maintain a quorum.</li>
</ul>
</blockquote>
<h2 id="Running-Multiple-Services-in-a-Container"><a href="#Running-Multiple-Services-in-a-Container" class="headerlink" title="Running Multiple Services in a Container"></a>Running Multiple Services in a Container</h2><p>This involves writing scripts and editing the Dockerfile. For details please refer to <a href="https://docs.docker.com/config/containers/multi-service_container/" target="_blank" rel="noopener">this link</a>.</p>
<h2 id="Viewing-Runtime-metrics-for-a-Container"><a href="#Viewing-Runtime-metrics-for-a-Container" class="headerlink" title="Viewing Runtime metrics for a Container"></a>Viewing Runtime metrics for a Container</h2><p>There are a couple of ways where you can view the current runtime metrics for your container.</p>
<ol>
<li><p>You can use the <code>docker stats</code> command to <strong>live stream a container’s runtime metrics</strong>. The command supports CPU, memory usage, memory limit, and network IO metrics.</p>
<p> The following is a sample output from the docker stats command:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker stats redis1 redis2</span><br><span class="line"></span><br><span class="line">CONTAINER           CPU %               MEM USAGE &#x2F; LIMIT     MEM %               NET I&#x2F;O             BLOCK I&#x2F;O</span><br><span class="line">redis1              0.07%               796 KB &#x2F; 64 MB        1.21%               788 B &#x2F; 648 B       3.568 MB &#x2F; 512 KB</span><br><span class="line">redis2              0.07%               2.746 MB &#x2F; 64 MB      4.29%               1.266 KB &#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Using Linux Control Groups</p>
<p> <strong><em>Q: What is a Linux Control Group?</em></strong></p>
<p> Truth be told, certain <strong>software applications in the wild may need to be controlled or limited—at least for the sake of stability and, to some degree, security</strong>. Far too often, <strong>a bug or just bad code</strong> can disrupt an entire machine and <strong>potentially cripple an entire ecosystem</strong>. Fortunately, a way exists to keep those same applications in check. <strong>Control groups (cgroups) is a kernel feature that limits, accounts for and isolates the CPU, memory, disk I/O and network’s usage of one or more processes</strong>.</p>
<p> The primary design goal for cgroups was to provide a unified interface to manage processes or whole operating-system-level virtualization, including Linux Containers, or LXC (a topic I plan to revisit in more detail in a follow-up article). The cgroups framework provides the following:</p>
<ul>
<li><p>Resource limiting: a group can be configured not to exceed a specified memory limit or use more than the desired amount of processors or be limited to specific peripheral devices.</p>
</li>
<li><p>Prioritization: one or more groups may be configured to utilize fewer or more CPUs or disk I/O throughput.</p>
</li>
<li><p>Accounting: a group’s resource usage is monitored and measured.</p>
</li>
<li><p>Control: groups of processes can be frozen or stopped and restarted.</p>
<p>For more details, please visit this <a href="https://www.linuxjournal.com/content/everything-you-need-know-about-linux-containers-part-i-linux-control-groups-and-process" target="_blank" rel="noopener">site</a>.</p>
<p>Now, <strong>for each container, one cgroup is created in each hierarchy</strong>. On older systems with older versions of the LXC userland tools, the name of the cgroup is the name of the container. With more recent versions of the LXC tools, the cgroup is <code>lxc/&lt;container_name&gt;</code>.</p>
</li>
</ul>
<p> <strong>For Docker containers using cgroups, the container name is the full ID or long ID of the container</strong>. If a container shows up as <code>ae836c95b4c3</code> in <code>docker ps</code>, its long ID might be something like <code>ae836c95b4c3c9e9179e0e91015512da89fdec91612f63cebae57df9a5444c79</code>. You can look it up with <code>docker inspect</code> or <code>docker ps --no-trunc</code>.</p>
<p> Putting everything together to look at the memory metrics for a Docker container, take a look at <code>/sys/fs/cgroup/memory/docker/&lt;longid&gt;/</code>, where for each subsystem (memory, CPU, and block I/O), <strong>one or more pseudo-files exist and contain statistics:</strong></p>
<pre><code>- **MEMORY METRICS: `MEMORY.STAT`**
- **CPU metrics: `cpuacct.stat`**
- **Network metrics** those are not directly exposed by the control group, but information can be gathered from other sources. For details, please follow the link below.</code></pre><p> For a detailed explaination of what you see in all those files, please refer to the <a href="https://docs.docker.com/config/containers/runmetrics/#metrics-from-cgroups-memory-cpu-block-io" target="_blank" rel="noopener">Offical Docker Documentation</a></p>
</li>
</ol>
<h2 id="View-Logs-for-a-Particular-Container-or-Service"><a href="#View-Logs-for-a-Particular-Container-or-Service" class="headerlink" title="View Logs for a Particular Container or Service"></a>View Logs for a Particular Container or Service</h2><p>The <code>docker logs</code> command <strong>shows information logged by a running container</strong>. The <code>docker service logs</code> command <strong>shows information logged by all containers participating in a service</strong>. The information that is logged and the format of the log depends almost entirely on the container’s endpoint command.</p>
<p>By default, <code>docker logs</code> or <code>docker service logs</code> <strong>shows the command’s output just as it would appear if you ran the command interactively in a terminal</strong>. UNIX and Linux commands typically open three I/O streams when they run, called <code>STDIN</code>, <code>STDOUT</code>, and <code>STDERR</code>. </p>
<ul>
<li><code>STDIN</code> is the <strong>command’s input stream</strong> (i.e. user input), which may include input from the keyboard or input from another command. </li>
<li><code>STDOUT</code> is usually a <strong>command’s normal output</strong></li>
<li><code>STDERR</code> is typically used to <strong>output error messages</strong>. </li>
</ul>
<p><strong>By default, <code>docker logs</code> shows the command’s <code>STDOUT</code> and <code>STDERR</code>.</strong> </p>
<p>However, in some cases, <strong><code>docker logs</code> may not show useful information unless you take additional steps</strong>.</p>
<ul>
<li><strong>If you use a logging driver</strong> which <strong>sends logs to a file</strong>, an external host, a database, or another logging back-end, docker logs may not show useful information.<ul>
<li>In this case, <strong>your logs are processed in other ways and you may choose not to use docker logs (continue to the section <a href="#Configuring-Logging-Drivers">Configure logging drivers</a>).</strong></li>
</ul>
</li>
<li><strong>If your image runs a non-interactive process</strong> such as a web server or <strong>a database</strong>, that application may <strong>send its output to log files instead of STDOUT and STDERR</strong>.<ul>
<li>In this case, the <strong>official <code>nginx</code> image shows one workaround</strong>, and the <strong>official <code>Apache httpd</code> image shows another</strong>.<ul>
<li>The official nginx image creates a symbolic link from <code>/var/log/nginx/access.log</code> to <code>/dev/stdout</code>, and creates another symbolic link from <code>/var/log/nginx/error.log</code> to <code>/dev/stderr</code>, <strong>overwriting the log files and causing logs to be sent to the relevant special device instead</strong>. See this <a href="https://github.com/nginxinc/docker-nginx/blob/8921999083def7ba43a06fabd5f80e4406651353/mainline/jessie/Dockerfile#L21-L23" target="_blank" rel="noopener">Dockerfile</a>.</li>
<li>The official httpd driver <strong>changes the httpd application’s configuration to write its normal output directly to /proc/self/fd/1</strong> (which is <code>STDOUT</code>) and <strong>its errors to /proc/self/fd/2</strong> (which is <code>STDERR</code>). See this <a href="https://github.com/docker-library/httpd/blob/b13054c7de5c74bbaa6d595dbe38969e6d4f860c/2.2/Dockerfile#L72-L75" target="_blank" rel="noopener">Dockerfile</a>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="Configuring-Logging-Drivers"></a></p>
<h2 id="Configuring-Logging-Drivers"><a href="#Configuring-Logging-Drivers" class="headerlink" title="Configuring Logging Drivers"></a>Configuring Logging Drivers</h2><p>Docker includes multiple logging mechanisms to help you get information from running containers and services. These mechanisms are called <strong>logging drivers</strong> (I interpret them as driving your logs to a specific place with a specific format).</p>
<p><strong>By default, Docker uses the <code>json</code> file to log all the outputs</strong>. The file of a container’s logs can be found in (if you use the default log format which is <code>json</code>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;&lt;container id&gt;&#x2F;&lt;container id&gt;-json.log</span><br></pre></td></tr></table></figure>
<p>This will contain the same log output as you will see if you run <code>docker logs &lt;container-id&gt;</code>. If you do not specify a logging driver, the default is json-file. Thus, the default output for commands such as <code>docker inspect &lt;CONTAINER&gt;</code> is also <code>JSON</code>.</p>
<p>To <strong>configure the Docker daemon from the default to a specific logging driver</strong>, set the <strong>value of <code>log-driver</code> to the name of the logging driver</strong> in the <strong><code>daemon.json</code> file</strong>, which is located in <code>/etc/docker/</code> on Linux hosts or <code>C:\ProgramData\docker\config\</code> on Windows server hosts.The following example explicitly sets the default logging driver to <code>syslog</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;syslog&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>If the logging driver has configurable option</strong>s, you can set them in the <code>daemon.json</code> file as a <code>JSON</code> object <strong>with the key <code>log-opts</code></strong>. The following example sets two configurable options on the json-file logging driver:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;10m&quot;,</span><br><span class="line">    &quot;max-file&quot;: &quot;3&quot;,</span><br><span class="line">    &quot;labels&quot;: &quot;production_status&quot;,</span><br><span class="line">    &quot;env&quot;: &quot;os,customer&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and you can also specify directly for a particular container (this will overwrite the JSON file):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name&#x3D;&lt;container-name&gt; \</span><br><span class="line">--log-driver json-file \</span><br><span class="line">--log-opt max-size&#x3D;10m --log-opt max-file&#x3D;3 --log-opt labels&#x3D;production_status --log-opt env&#x3D;os,customer \</span><br><span class="line">&lt;yourImage&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>
<p>where:</p>
<ul>
<li><code>max-size</code><ul>
<li>The <strong>maximum size of the log before it is rolled</strong>. A positive integer plus a modifier representing the unit of measure (k=kb, m=mb, or g=gb). Defaults to -1 (unlimited).    </li>
<li>Example: <code>--log-opt max-size=10m</code></li>
</ul>
</li>
<li><code>max-file</code> <ul>
<li>The <strong>maximum number of log files that can be present</strong>. <strong>If rolling the logs creates excess files, the oldest file is removed</strong>. Only effective when max-size is also set. A positive integer. <strong>Defaults to 1</strong>.</li>
<li>Example: <code>--log-opt max-file=3</code></li>
</ul>
</li>
<li><code>labels</code><ul>
<li>Applies when starting the Docker daemon. A comma-separated list of <strong>logging-related labels</strong> this daemon accepts. <strong>Used for advanced log tag options</strong>.    </li>
<li>Example: <code>--log-opt labels=production_status,geo</code></li>
</ul>
</li>
<li><code>env</code><ul>
<li>Applies when starting the Docker daemon. A comma-separated list of <strong>logging-related environment variables</strong> this daemon accepts. <strong>Used for advanced log tag options</strong>.    </li>
<li>Example: <code>--log-opt env=os,customer</code></li>
</ul>
</li>
</ul>
<p>For more details on the JSON File logging driver, please visit <a href="https://docs.docker.com/config/containers/logging/json-file/" target="_blank" rel="noopener">this link</a></p>
<blockquote>
<p>Note:</p>
<ul>
<li><input disabled type="checkbox"> <code>log-opts</code> <strong>configuration options</strong> in the <code>daemon.json</code> configuration file <strong>must be provided as strings</strong>. Boolean and numeric values (such as the value for max-file in the example above) must therefore be enclosed in quotes (<code>&quot;</code>).</li>
</ul>
</blockquote>
<p>Now, To <strong>find the current default logging driver for the Docker daemon</strong>, run <code>docker info</code> and search for Logging Driver. You can use the following command on Linux, macOS, or PowerShell on Windows:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker info --format &#39;&#123;&#123;.LoggingDriver&#125;&#125;&#39;</span><br><span class="line"></span><br><span class="line">json-file</span><br></pre></td></tr></table></figure>

<p>To find the <strong>current logging driver for a running container</strong>, if the daemon is using the json-file logging driver, run the following docker inspect command, substituting the container name or ID for <code>&lt;CONTAINER&gt;</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect -f &#39;&#123;&#123;.HostConfig.LogConfig.Type&#125;&#125;&#39; &lt;CONTAINER&gt;</span><br><span class="line"></span><br><span class="line">json-file</span><br></pre></td></tr></table></figure>

<h2 id="Use-environment-variables-or-labels-with-logging-drivers"><a href="#Use-environment-variables-or-labels-with-logging-drivers" class="headerlink" title="Use environment variables or labels with logging drivers"></a>Use environment variables or labels with logging drivers</h2><p>Some logging drivers add the value of a container’s <code>--env|-e</code> or –label flags to the container’s logs. This example starts a container using the Docker daemon’s default logging driver (let’s assume json-file) but sets the environment variable os=ubuntu.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit --label production_status&#x3D;testing -e os&#x3D;ubuntu alpine sh</span><br></pre></td></tr></table></figure>

<p>If the logging driver supports it, this adds additional fields to the logging output. The following output is generated by the json-file logging driver:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;attrs&quot;:&#123;&quot;production_status&quot;:&quot;testing&quot;,&quot;os&quot;:&quot;ubuntu&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Supported-Logging-Drivers"><a href="#Supported-Logging-Drivers" class="headerlink" title="Supported Logging Drivers"></a>Supported Logging Drivers</h2><p>The following logging drivers are supported. If you are using logging driver plugins, you may see more options.</p>
<table>
<thead>
<tr>
<th>Driver</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>No logs are available for the container and docker logs does not return any output.</td>
</tr>
<tr>
<td><code>local</code></td>
<td>Logs are stored in a custom format designed for minimal overhead.</td>
</tr>
<tr>
<td><code>json-file</code></td>
<td>The logs are formatted as JSON. The default logging driver for Docker.</td>
</tr>
<tr>
<td><code>syslog</code></td>
<td>Writes logging messages to the syslog facility. The syslog daemon must be running on the host machine.</td>
</tr>
<tr>
<td><code>journald</code></td>
<td>Writes log messages to journald. The journald daemon must be running on the host machine.</td>
</tr>
<tr>
<td><code>gelf</code></td>
<td>Writes log messages to a Graylog Extended Log Format (GELF) endpoint such as Graylog or Logstash.</td>
</tr>
<tr>
<td><code>fluentd</code></td>
<td>Writes log messages to fluentd (forward input). The fluentd daemon must be running on the host machine.</td>
</tr>
<tr>
<td><code>awslogs</code></td>
<td>Writes log messages to Amazon CloudWatch Logs.</td>
</tr>
<tr>
<td><code>splunk</code></td>
<td>Writes log messages to splunk using the HTTP Event Collector.</td>
</tr>
<tr>
<td><code>etwlogs</code></td>
<td>Writes log messages as Event Tracing for Windows (ETW) events. Only available on Windows platforms.</td>
</tr>
<tr>
<td><code>gcplogs</code></td>
<td>Writes log messages to Google Cloud Platform (GCP) Logging.</td>
</tr>
<tr>
<td><code>logentries</code></td>
<td>Writes log messages to Rapid7 Logentries.</td>
</tr>
</tbody></table>
<p>However, there are <strong>limitations for using logging drivers in general</strong> as well:</p>
<ul>
<li>Users of <strong>Docker Enterprise can make use of “dual logging”</strong>, which enables you to use the docker logs command for any logging driver. Refer to reading logs when using remote logging drivers for information about using docker logs to read container logs locally for many third party logging solutions, including:<ul>
<li><code>syslog</code></li>
<li><code>gelf</code></li>
<li><code>fluentd</code></li>
<li><code>awslogs</code></li>
<li><code>splunk</code></li>
<li><code>etwlogs</code></li>
<li><code>gcplogs</code></li>
<li><code>Logentries</code></li>
</ul>
</li>
<li>When using <strong>Docker Community Engine</strong>, the docker logs command is only available on the following drivers:<br>local<ul>
<li><code>json-file</code></li>
<li><code>journald</code></li>
</ul>
</li>
<li>Reading log information <strong>requires decompressing rotated log files</strong>, which <strong>causes a temporary increase in disk usage</strong> (until the log entries from the rotated files are read) and an increased CPU usage while decompressing.</li>
<li>The capacity of the host storage where the Docker data directory resides determines the maximum size of the log file information.</li>
</ul>
<h2 id="Using-a-Logging-Driver-Plugin"><a href="#Using-a-Logging-Driver-Plugin" class="headerlink" title="Using a Logging Driver Plugin"></a>Using a Logging Driver Plugin</h2><p>Docker logging plugins allow you to extend and customize Docker’s logging capabilities beyond those of the built-in logging drivers. <strong>A logging service provider can implement their own plugins and make them available on Docker Hub, or a private registry</strong>.</p>
<ol>
<li><p>First, you need to install the logging driver plugin</p>
<ul>
<li>To install a logging driver plugin, use <code>docker plugin install &lt;org/image&gt;</code>, using the information provided by the plugin developer.</li>
</ul>
</li>
<li><p>You can <strong>list all installed plugins</strong> using <code>docker plugin ls</code>, and you can <strong>inspect a specific plugin</strong> using <code>docker inspect</code>.</p>
</li>
<li><p>If you wan to configure the plugin <strong>as the default logging driver</strong>:</p>
<ul>
<li>After the plugin is installed, you can configure the Docker daemon to use it as the default by setting the plugin’s name as the value of the <code>log-driver</code> key in the <code>daemon.json</code>, as detailed in the previous section. If the logging driver supports additional options, you can set those as the values of the <code>log-opts</code> array in the same file.</li>
</ul>
</li>
<li><p>If you want to configure <strong>a container to use the plugin</strong> as the logging driver:</p>
<ul>
<li>After the plugin is installed, you can configure a container to use the plugin as its logging driver by <strong>specifying the <code>--log-driver</code> flag to <code>docker run</code></strong>, as detailed in the previous section. If the logging driver supports additional options, you can specify them using one or more <code>--log-opt</code> flags with the option name as the key and the option value as the value.</li>
</ul>
</li>
</ol>
<h2 id="Customizing-the-Logging-Driver-Tag"><a href="#Customizing-the-Logging-Driver-Tag" class="headerlink" title="Customizing the Logging Driver Tag"></a>Customizing the Logging Driver Tag</h2><p>The tag log option specifies how to format a tag that identifies the container’s log messages. By default, the system uses the first 12 characters of the container ID. To override this behavior, specify a tag option:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --log-driver&#x3D;fluentd --log-opt fluentd-address&#x3D;myhost.local:24224 --log-opt tag&#x3D;&quot;testTag&quot;</span><br></pre></td></tr></table></figure>

<p>Often, you would like to use a special template markup:  --log-opt tag=".ImageName/.Name/.ID"  value yields syslog log lines like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aug  7 18:33:19 HOSTNAME hello-world&#x2F;foobar&#x2F;5790672ab6a0[9103]: Hello from Docker.</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Markup</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>{{.ID}}</td>
<td>The first 12 characters of the container ID.</td>
</tr>
<tr>
<td>{{.FullID}}</td>
<td>The full container ID.</td>
</tr>
<tr>
<td>{{.Name}}</td>
<td>The container name.</td>
</tr>
<tr>
<td>{{.ImageID}}</td>
<td>The first 12 characters of the container’s image ID.</td>
</tr>
<tr>
<td>{{.ImageFullID}}</td>
<td>The container’s full image ID.</td>
</tr>
<tr>
<td>{{.ImageName}}</td>
<td>The name of the image used by the container.</td>
</tr>
<tr>
<td>{{.DaemonName}}</td>
<td>The name of the docker program (docker).</td>
</tr>
</tbody></table>
<p><a name="MySQL-in-Docker"></a></p>
<h2 id="Using-MySQL-Server-in-Docker"><a href="#Using-MySQL-Server-in-Docker" class="headerlink" title="Using MySQL Server in Docker"></a>Using MySQL Server in Docker</h2><ol>
<li>You need to first setup your SQL server in docker via this <a href="https://dev.mysql.com/doc/mysql-installation-excerpt/8.0/en/docker-mysql-getting-started.html" target="_blank" rel="noopener">Official Guide</a></li>
<li>Then refer to <a href="https://jasonyux.github.io/2020/05/26/MySQL-Manual" target="_blank" rel="noopener">MySQL Manual</a> for further reference on using MySQL</li>
</ol>
<h2 id="Creating-and-Mounting-a-Volume-to-MySQL-data"><a href="#Creating-and-Mounting-a-Volume-to-MySQL-data" class="headerlink" title="Creating and Mounting a Volume to MySQL data"></a>Creating and Mounting a Volume to MySQL data</h2><ol>
<li><p>First, to create a volume, you need to run:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create &lt;my-vol&gt;</span><br></pre></td></tr></table></figure>

<p> This will create a volume at your local directory <code>/var/lib/docker/volumes/&lt;my-vol&gt;/_data</code></p>
</li>
<li><p>You can list the volumes you have with:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br></pre></td></tr></table></figure>

<p> At this point, if you see some other volumes that are temporary created and you don’t want them, you can use:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm &lt;my-vol&gt;</span><br></pre></td></tr></table></figure>

<p> or use the <code>prune</code> keyword which will delete volumes that are not used by any containers:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure>
</li>
<li><p>Now, you can mount a volume to your container with either the <code>-v</code> or <code>--mount</code> option. To store mount volumes to directory where <code>mysql</code> stores its data, you need to mount to <code>/var/opt/mssql</code>. Examples below produce the same result (this example uses the image called <code>mysql:latest</code> and creates a container <code>devtest</code>). </p>
<ul>
<li><p><code>--mount</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  --mount source&#x3D;myvol2,target&#x3D;&#x2F;var&#x2F;opt&#x2F;mssql \</span><br><span class="line">  mysql:latest</span><br></pre></td></tr></table></figure></li>
<li><p><code>-v</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v myvol2:&#x2F;var&#x2F;opt&#x2F;mssql \</span><br><span class="line">  mysql:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>To mount multiple volumes, you can do:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">  --name devtest \</span><br><span class="line">  -v myvol2:&#x2F;var&#x2F;opt&#x2F;mssql \</span><br><span class="line">  -v myvol3:&#x2F;var \</span><br><span class="line">  mysql:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note:</p>
<ul>
<li><input disabled type="checkbox"> If the name of the volume you specified does not exist, <code>docker</code> will create one with that name for you.</li>
<li><input disabled type="checkbox"> It is also allowed to mount multiple containers to the same volume.</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>You can then use <code>docker inspect devtest</code> to verify that the volume was created and mounted correctly. Look for the Mounts section:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;myvol2&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;myvol2&#x2F;_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;&#x2F;app&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p> This shows that the mount is a volume, it shows the correct source and destination, and that the mount is read-write.</p>
</li>
<li><p>If you want to remove a volume, you need to <strong>stop and remove the container, and then remove the volume</strong>. Note volume removal is a separate step.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop devtest</span><br><span class="line"></span><br><span class="line">$ docker container rm devtest</span><br><span class="line"></span><br><span class="line">$ docker volume rm myvol2</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Use-a-Volume-for-Read-Only-Purpose"><a href="#Use-a-Volume-for-Read-Only-Purpose" class="headerlink" title="Use a Volume for Read-Only Purpose"></a>Use a Volume for Read-Only Purpose</h2><p>For some development applications, the container needs to write into the bind mount so that changes are propagated back to the Docker host. At other times, the container <strong>only needs read access to the data</strong>. Remember that multiple containers can mount the same volume, and it can be mounted read-write for some of them and read-only for others, at the same time.</p>
<p>Suppose you want to access the data in the volume <code>nginx-vol</code> for the following examples.</p>
<p>The following modifies the one above but <strong>mounts the directory as a read-only volume</strong>, by adding <code>readonly</code> or <code>ro</code> to the (empty by default) list of options, after the mount point within the container. If multiple options are present, separate them by commas.</p>
<p>The <code>--mount</code> and <code>-v</code> examples have the same result.</p>
<ul>
<li><p><code>--mount</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">  --name&#x3D;nginxtest \</span><br><span class="line">  --mount source&#x3D;nginx-vol,destination&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html,readonly \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>-v</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">  --name&#x3D;nginxtest \</span><br><span class="line">  -v nginx-vol:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html:ro \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Now you can use <code>docker inspect nginxtest</code> to <strong>verify that the readonly mount was created correctly</strong>. Look for the Mounts section, where you see <code>&quot;RW&quot;: false</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;nginx-vol&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;nginx-vol&#x2F;_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: false,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/25/Docker-Manual/" data-id="ckamcbohu000060orfr6dh1u8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/05/26/MySQL-Manual/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          MySQL Manual
        
      </div>
    </a>
  
  
    <a href="/2020/05/22/Apache-Manual-md/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Apache Maven Manual</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/26/MySQL-Manual/">MySQL Manual</a>
          </li>
        
          <li>
            <a href="/2020/05/25/Docker-Manual/">Docker Manual</a>
          </li>
        
          <li>
            <a href="/2020/05/22/Apache-Manual-md/">Apache Maven Manual</a>
          </li>
        
          <li>
            <a href="/2020/05/20/Git-Summary/">Git Manual</a>
          </li>
        
          <li>
            <a href="/2020/05/19/MarkDown-Summary/">MarkDown Manual</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Xiao Yu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>