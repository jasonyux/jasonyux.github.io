<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>From a Beginner to a Disaster</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="From a Beginner to a Disaster">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="From a Beginner to a Disaster">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xiao Yu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="From a Beginner to a Disaster" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">From a Beginner to a Disaster</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Xiao.Y</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-MarkDown-Summary" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/19/MarkDown-Summary/" class="article-date">
  <time datetime="2020-05-19T12:33:09.205Z" itemprop="datePublished">2020-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/19/MarkDown-Summary/">MarkDown-Summary</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Line-Breaks-and-Indentation"><a href="#Line-Breaks-and-Indentation" class="headerlink" title="Line Breaks and Indentation"></a>Line Breaks and Indentation</h3><p>The content is basically the same as that of the Jupyter notebook</p>
<p>There will be a space between the previous line</p>
<p>This will be no space if I add two or more spaces at the end of this line<br>see, no space between a new line</p>
<p>This is is how to do block quotes</p>
<blockquote>
<p>A: quote 1<br>You could also have paragraphs in a block quote if you add the symbol &gt; in front</p>
<p>Here is a new line</p>
</blockquote>
<h3 id="Links-and-Images"><a href="#Links-and-Images" class="headerlink" title="Links and Images"></a>Links and Images</h3><p>This is how you add and image (the label will show if the image is not properly loaded): </p>




<p>This is how you create a link:<br><a href="http://jasonyux.github.io" target="_blank" rel="noopener">My Blog</a></p>
<h3 id="Code-Snippets"><a href="#Code-Snippets" class="headerlink" title="Code Snippets"></a>Code Snippets</h3><h5 id="From-now-on-it-is-only-supported-in-Github-Flavored-Markdown"><a href="#From-now-on-it-is-only-supported-in-Github-Flavored-Markdown" class="headerlink" title="From now on it is only supported in Github Flavored Markdown"></a>From now on it is only supported in Github Flavored Markdown</h5><p>This is how you create a code snippet:<br><code>main()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Strike-Through-text"><a href="#Strike-Through-text" class="headerlink" title="Strike-Through text"></a>Strike-Through text</h3><p><del>this</del></p>
<p><a href="https://github.com/jlord/sheetsee.js/issues/26" target="_blank" rel="noopener">https://github.com/jlord/sheetsee.js/issues/26</a></p>
<h3 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h3><p>A standard table:</p>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content cell 1</td>
<td>Content cell 2</td>
</tr>
<tr>
<td>Content column 1</td>
<td>Content column 2</td>
</tr>
</tbody></table>
<p>A table with different alignments: </p>
<table>
<thead>
<tr>
<th align="left">Left-aligned</th>
<th align="center">Center-aligned</th>
<th align="right">Right-aligned</th>
</tr>
</thead>
<tbody><tr>
<td align="left">git status</td>
<td align="center">git status</td>
<td align="right">git status</td>
</tr>
<tr>
<td align="left">git diff</td>
<td align="center">git diff</td>
<td align="right">git diff</td>
</tr>
</tbody></table>
<h3 id="Task-Lists"><a href="#Task-Lists" class="headerlink" title="Task Lists"></a>Task Lists</h3><ul>
<li><input disabled="" type="checkbox"> @mentions, #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported</li>
<li><input checked="" disabled="" type="checkbox"> list syntax required (any unordered or ordered list supported)</li>
<li><input checked="" disabled="" type="checkbox"> this is a complete item</li>
<li><input disabled="" type="checkbox"> this is an incomplete item</li>
</ul>
<p><a name="myAnchor1"></a></p>
<h3 id="Internal-Links-Anchors"><a href="#Internal-Links-Anchors" class="headerlink" title="Internal Links/ Anchors"></a>Internal Links/ Anchors</h3><p><a href="#myAnchor1">Link back to myAncho1</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/19/MarkDown-Summary/" data-id="ckafcv7d00000h0t6df4nfrcz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Git-Summary" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/07/13/Git-Summary/" class="article-date">
  <time datetime="2013-07-13T12:46:25.000Z" itemprop="datePublished">2013-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/13/Git-Summary/">Git Intro</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Git-Intro"><a href="#Git-Intro" class="headerlink" title="Git Intro"></a>Git Intro</h2><ul>
<li>Version Control<ul>
<li>Version control is a <strong>system</strong> that records and manages changes for a file or a set of file, so that you could later revert those changes if needed</li>
</ul>
</li>
<li>Why Version Control<ul>
<li>Many default version-control method of choice is to simply copy files into another directory, and renaming them somehow to keep track of the changes</li>
<li>however, this could be inconvenient and error prone</li>
</ul>
</li>
<li>Solutions<ul>
<li>One of the most popular <strong>VCS</strong> tools was a system called <strong>RCS</strong>, which is still distributed with many computers today. <strong>RCS</strong> works by <strong>keeping patch sets</strong> (that is, the differences between files) <strong>in a special format on disk</strong>; it can then re-create what any file looked like at any point in time by adding up all the patches.<ul>
<li><em>Problem</em><ul>
<li>The next major issue that people encounter is that they need to collaborate with developers on other systems.</li>
</ul>
</li>
</ul>
</li>
<li>Centralized Version Control Systems (<strong>CVCSs</strong>) were developed as a solution to the problem above. These systems (such as CVS, Subversion, and Perforce) have <strong>a single server that contains all the versioned files</strong>, and <strong>a number of clients that check out files from that central place</strong>. For many years, this has been the standard for version control.<ul>
<li><em>Advantages</em><ul>
<li>everyone knows to a certain degree what everyone else on the project is doing. Administrators have fine-grained control over who can do what, and it’s far easier to administer a CVCS than it is to deal with local databases on every client.</li>
</ul>
</li>
<li><em>Problems</em><ul>
<li>If that server goes down for an hour, then during that hour nobody can collaborate at all or save versioned changes to anything they’re working on. If the hard disk the central database is on becomes corrupted, and proper backups haven’t been kept, you lose absolutely everything — the entire history of the project except whatever single snapshots people happen to have on their local machines.</li>
</ul>
</li>
</ul>
</li>
<li>Here Distributed Version Control Systems (<strong>DVCSs</strong>) step in. In a DVCS (such as Git, Mercurial, Bazaar or Darcs), clients don’t just check out the latest snapshot of the files; rather, they <strong>fully mirror the repository, including its full history</strong>. Thus, if any server dies, and these systems were collaborating via that server, <strong>any of the client repositories can be copied back up to the server to restore it</strong>. Every clone is really a full backup of all the data.<ul>
<li><em>Advantages</em><ul>
<li>you can collaborate with different groups of people in different ways simultaneously within the same project. This allows you to set up several types of workflows that aren’t possible in centralized systems, such as hierarchical models.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Git-Setup"><a href="#Git-Setup" class="headerlink" title="Git Setup"></a>Git Setup</h2><h2 id="Getting-Help-in-Git"><a href="#Getting-Help-in-Git" class="headerlink" title="Getting Help in Git"></a>Getting Help in Git</h2><p>To get more information about a command in Git, use any of the three below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git help &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure>
<p>It is recommended to use <code>git &lt;verb&gt; --help</code> because it sticks to the pattern of command line code. For example, for a quick refresher on the available options for a Git command, you do <code>git &lt;verb&gt; -h</code></p>
<ul>
<li><em>Notice</em><ul>
<li>Those commands are accessible even offline</li>
</ul>
</li>
</ul>
<h2 id="Git-Basics"><a href="#Git-Basics" class="headerlink" title="Git Basics"></a>Git Basics</h2><ul>
<li><p><strong>Getting a Git Repository</strong><br>This can be done in two ways</p>
<ol>
<li>take a local directory that is currently <strong>not under version control</strong> and turn it into a Git repository</li>
<li><code>clone</code> an existing Git repository from elsewhere</li>
</ol>
<p>Then you will end up with a Git repo on your local machine</p>
</li>
</ul>
<ol>
<li><p>To do achieve the <strong>first option</strong>, you need to first go to the project directory (for Windows):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd your_path</span><br></pre></td></tr></table></figure>
<p>Then type:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>This creates a new subdirectory named <strong>.git</strong> that contains all of your necessary repository files — a Git repository skeleton. At this point, <strong>nothing in your project is tracked yet</strong>.</p>
<p>To start version-controlling, you need to <code>git add</code> your file that you need to control, and then <code>git commit</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add yourFile1</span><br><span class="line">$ git add yourFile2</span><br><span class="line">$ git commit -m &#39;Initial project version&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>To achieve the <strong>second option</strong>, for example, a project you’d like to contribute to — the command you need is <code>git clone</code>, so that Git receives <strong>a full copy of nearly all data that the server has</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;url&gt;</span><br></pre></td></tr></table></figure>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;libgit2&#x2F;libgit2 mylibgit</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p><em>Notice</em></p>
<ul>
<li>you can <code>clone</code> a <strong>Git linkable library</strong> only</li>
<li>The above command will <strong>create a directory named libgit2</strong> under the <strong>current directory</strong>, initializes a .git directory inside it, pulls down all the data for that repository, and checks out a working copy of the latest version. </li>
<li>Git has a number of <strong>different transfer protocols you can use</strong>. The previous example uses the <code>https://</code> protocol, but you may also see <code>git://</code> or <code>user@server:path/to/repo.git</code>, which uses the SSH transfer protocol.</li>
</ul>
<p>If you want to <strong>clone the repository into a directory named something other than libgit2</strong>, you can specify the new directory name as an additional argument:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;libgit2&#x2F;libgit2 customizedName</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Recording-Changes"><a href="#Recording-Changes" class="headerlink" title="Recording Changes"></a>Recording Changes</h2><p>Typically, you’ll want to <strong>start making changes</strong> and <strong>committing snapshots of those changes</strong> (i.e. recording/saving those changes) into your repository each time the project reaches a state you want to record.</p>
<p>As you edit files, Git sees them as <strong>modified</strong>, because you’ve changed them since your last commit. As you work, you selectively <strong>stage these modified files</strong> and then <strong>commit/save all those staged changes</strong>, and the cycle repeats.</p>
<ul>
<li><em>Note</em><ul>
<li>Not all files under the directory will be <strong>tracked</strong>, and only <strong>tracked</strong> files will Git know about</li>
<li>once you <code>git add</code> to start your file to start tracking. Then it will be <strong>snapedshotted</strong> if you then call <code>git commit</code></li>
</ul>
</li>
</ul>
<h2 id="Checking-File-Status"><a href="#Checking-File-Status" class="headerlink" title="Checking File Status"></a>Checking File Status</h2><p>The main tool you use to <strong>determine which files are in which state</strong> is the <code>git status</code> command. </p>
<p>For example, if you see:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#39;origin&#x2F;master&#39;.</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>A <strong>clean working directory</strong> means <strong>none of your tracked files are modified</strong>.</p>
<ul>
<li><em>Note</em><ul>
<li>this command can also show <strong>untracked</strong> files under the <strong>current directory</strong></li>
<li>if you want to <strong>start tracking</strong> those, you can call <code>git add fileNeedsToBeTracked</code></li>
</ul>
</li>
</ul>
<h2 id="Modifying-a-Tracked-File"><a href="#Modifying-a-Tracked-File" class="headerlink" title="Modifying a Tracked File"></a>Modifying a Tracked File</h2><p>There are three status that a tracked file can be at <strong>after being modified</strong>:</p>
<ol>
<li><strong>Unstaged and uncomitted</strong><ul>
<li>This happens <strong>right after</strong> you have <strong>modified a tracked file</strong>. At this point, if you did not call <code>git add thatFile</code> again, Git will only know about the previous checkpoint.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   firstFile.txt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>Staged but uncommitted</strong><ul>
<li>This happens when you have modified a tracked file and called <code>git add thatFile</code>. Now, <strong>Git knows about it and it is thrown into the staging area</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   LICENSE</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>Staged and committed</strong><ul>
<li>This happens when you call <code>git commit yourFile</code>, so that the <strong>changes move from the stanging area to be saved in your local repository</strong></li>
</ul>
</li>
</ol>
<h2 id="Difference-between-git-add-and-git-commit"><a href="#Difference-between-git-add-and-git-commit" class="headerlink" title="Difference between git add and git commit"></a>Difference between <code>git add</code> and <code>git commit</code></h2><ul>
<li><strong><em>Q: why add and commit as two functions? They seem to be two repeated checkpoint procedures.</em></strong></li>
</ul>
<p>The <code>git add</code> command adds a <strong>change in the working directory to the staging area</strong>. It tells Git that you want to include updates to a particular file in the next commit. However, <code>git add</code> doesn’t really affect the repository in any significant way—changes are not actually recorded until you run git commit.</p>
<p>The command <code>git commit</code> takes <strong>all changes in the Staging Area</strong>, wraps them together and** puts them in your Local Repository<strong>. A commit is simply a checkpoint telling git to track all changes that have occurred up to this point using our last commit as a comparison. **After committing, your Staging Area will be empty</strong>.</p>
<h2 id="Abbreviated-version-for-git-status"><a href="#Abbreviated-version-for-git-status" class="headerlink" title="Abbreviated version for git status"></a>Abbreviated version for <code>git status</code></h2><p>To quickly view which file is at which status, you can execute <code>git status -s</code> to see <strong>each file under the current directory with their status</strong></p>
<p>For example, you could see</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MM LICENSE.txt</span><br><span class="line">AM README.md</span><br><span class="line">M  firstFile.txt</span><br><span class="line">A  justTracked.txt</span><br><span class="line">?? unTracked.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>A</code> stands for files just added after <strong>.git</strong> existed or <code>git init</code> was called</li>
<li><code>M</code> stands for files being modified<ul>
<li>a green <code>M</code> (at position 0) means it is <strong>modified and staged</strong></li>
<li>a red <code>M</code> (at position 1, if there is) means it is <strong>modified but unstaged</strong></li>
</ul>
</li>
<li><code>??</code> stands for files <strong>not being tracked</strong> by Git</li>
</ul>
<ul>
<li>[x]<em>Note</em><ul>
<li>Although it is not shown above, but the first letter will be green, and if there is a second letter, it will be red.</li>
</ul>
</li>
</ul>
<h2 id="Ignoring-Files"><a href="#Ignoring-Files" class="headerlink" title="Ignoring Files"></a>Ignoring Files</h2><p>A <strong>gitignore file</strong> specifies intentionally <strong>untracked files</strong> that Git should ignore. Files already tracked by Git are not affected.</p>
<p><strong>Each line in a gitignore file</strong> specifies a pattern. When deciding whether to ignore a path, Git normally checks gitignore patterns from multiple sources, with the following order of precedence, from highest to lowest.</p>
<ol>
<li>First, you need to have/create a <strong>.gitignore</strong> file under the repository. This can be simply done by <code>touch .gitignore</code></li>
<li>Then, you need to add texts to that file to specify rules for ignoring files. This can be done by <code>cat &gt;&gt; .gitgnore</code>, where <code>&gt;&gt;</code> means append. Then you press enter and start typing texts/rules, and when you finish, enter <code>Ctrl-D</code> to save.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt;&gt; .gitignore</span><br><span class="line">unTracked.txt</span><br><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure>
(alternatively, you could use <code>&gt;</code> instead of <code>&gt;&gt;</code>, which will override the content)<br>Now, since <strong>unTracked.txt</strong> was not tracked, it will be ignored and <strong>will not appear</strong> if you execute <code>git status</code></li>
</ol>
<ul>
<li><em>Note</em><ul>
<li><code>*</code> matches anything except a slash</li>
<li><code>?</code> matches any one character except “/“</li>
<li><code>[a-zA-Z]</code>is the range notation, which can be used to match <strong>one of the characters</strong> in a range.</li>
<li><code>!</code> negates a pattern. Put a backslash <code>\</code> in front of the first <code>!</code> for patterns that begin with a literal <code>!</code>, for example, <code>\!important.txt</code></li>
<li><code>**/someDirectory</code> means match in all directories named [someDirectory]. For example, <code>**/foo</code> matches file or directory “foo” anywhere</li>
<li><code>someDirectory/**</code> matches everything <strong>inside [someDirectory]</strong>. For example, <code>abc/**</code> matches all files inside directory [abc], relative to the location of the [.gitignore] file</li>
<li><code>someDirectory/**/otherDirectory</code> matches neted directories between [someDirectory] and [otherDirectory]</li>
</ul>
</li>
</ul>
<h2 id="Knowing-the-Modifications"><a href="#Knowing-the-Modifications" class="headerlink" title="Knowing the Modifications"></a>Knowing the Modifications</h2><ol>
<li><p>By just executing <code>git diff</code> will compare what is in your <strong>working directory</strong> with what is in your <strong>staging area</strong>. The result tells you the <strong>changes you’ve made that you haven’t yet staged</strong>.</p>
<p>For example:  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">warning: LF will be replaced by CRLF in firstFile.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">diff --git a&#x2F;firstFile.txt b&#x2F;firstFile.txt</span><br><span class="line">index 640bb73..caada99 100644</span><br><span class="line">--- a&#x2F;firstFile.txt</span><br><span class="line">+++ b&#x2F;firstFile.txt</span><br><span class="line">@@ -1,3 +1,5 @@</span><br><span class="line"> hello</span><br><span class="line"> hello</span><br><span class="line"> hello</span><br><span class="line">+</span><br><span class="line">+aa</span><br></pre></td></tr></table></figure>
<p>The <code>+</code> and <code>+aa</code> lines in the end means those are the lines added to the file, but <strong>not being staged yet.</strong></p>
</li>
<li><p>By executing <code>git diff --staged</code> will compare changes of the files between the <strong>staged</strong> state and the <strong>last committed</strong> state.</p>
<p>For example:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --staged</span><br><span class="line">diff --git a&#x2F;firstFile.txt b&#x2F;firstFile.txt</span><br><span class="line">index e69de29..640bb73 100644</span><br><span class="line">--- a&#x2F;firstFile.txt</span><br><span class="line">+++ b&#x2F;firstFile.txt</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+hello</span><br><span class="line">+hello</span><br><span class="line">+hello</span><br></pre></td></tr></table></figure>
<p>Notice that the last two lines <code>+</code> and <code>+aa</code> are not present.</p>
</li>
</ol>
<h2 id="Committing-Changes"><a href="#Committing-Changes" class="headerlink" title="Committing Changes"></a>Committing Changes</h2><p>Now if you want to commit to those changes, you can execute <code>git commit</code>. However, this will <strong>only commit changes that are staged</strong>, so <strong>modified yet unstaged</strong> changes will not be recorded.</p>
<p>After executing <code>git commit</code>, it will bring up your editor of choice, which can be chosen when you setup your Git.</p>
<p>For example</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br><span class="line">[master 2031fb7] first commit made</span><br><span class="line"> 4 files changed, 11 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE.txt</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line"> create mode 100644 justTracked.txt</span><br></pre></td></tr></table></figure>

<ul>
<li><em>Note</em><ul>
<li>the <strong>first line will be intentionally made blank</strong>, which is for you to write/describe what has been changed.</li>
<li>you can use the command <code>git commit -v</code> to also have the <strong>difference shown in the editor</strong> as well, so you know exactly what you have done</li>
<li>for a quick commit, you can do <code>git commit -m &quot;yourMessageHere&quot;</code>, which finishes the commit without even opening the editor</li>
<li>you also see which <strong>branch you committed to</strong> (<code>master</code>), what <strong>SHA-1 checksum</strong> the commit has (<code>2031fb7</code>)</li>
</ul>
</li>
</ul>
<p>After you have made a commmit, <strong>all the tracked file will not appear</strong> if you execute <code>git status -s</code></p>
<h2 id="Committing-and-Skipping-the-Staging"><a href="#Committing-and-Skipping-the-Staging" class="headerlink" title="Committing and Skipping the Staging"></a>Committing and Skipping the Staging</h2><p> If you want to skip the staging area, Git provides a simple shortcut. Adding the <code>-a</code> option to the <code>git commit</code> command makes Git automatically <strong>stage every file that is already tracked</strong> before doing the commit, letting you skip the <code>git add</code> part.</p>
<p>Though this is convenient, but be careful; sometimes this flag will cause you to include unwanted changes.</p>
<h2 id="Removing-Tracked-File-Untracking-File"><a href="#Removing-Tracked-File-Untracking-File" class="headerlink" title="Removing Tracked File/ Untracking File"></a>Removing Tracked File/ Untracking File</h2><ul>
<li><p>If you want to <strong>remove a tracked file</strong>, meaning you want to delete the file, you need to execute <code>git rm yourFile</code>. This will:</p>
<ol>
<li>remove the file from the <strong>current working directory</strong></li>
<li>remove the file from the <strong>staging area</strong></li>
</ol>
<p>Now, the <strong>next time you commit</strong>, it will be <strong>no longer tracked</strong> by Git since it will be completely removed.</p>
</li>
<li><p>If you want to <strong>untrack a tracked file</strong>, you execute <code>git rm --cached yourFile</code>. This will keep the file in your directory, but removed from the Git.</p>
<p>Now, same as before, you will still need to execute <code>git commit</code> to complete the removal from the Git</p>
</li>
</ul>
<h2 id="Renaming-a-File"><a href="#Renaming-a-File" class="headerlink" title="Renaming a File"></a>Renaming a File</h2><p>If you rename a file, and wants it still being tracked by Git properly, you should do<br><code>git mv myFile myNewFile</code></p>
<p>Now, if you call <code>git status</code>, you will see:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git mv README.md README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#39;origin&#x2F;master&#39;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure>

<p>This is also equivalent of doing seperately three lines:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure>

<h2 id="Viewing-Commits"><a href="#Viewing-Commits" class="headerlink" title="Viewing Commits"></a>Viewing Commits</h2><p>You can see all commits in a repo by:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure>
<p>By default, with no arguments, <code>git log</code> lists the commits made in that repository in <strong>reverse chronological order</strong></p>
<ul>
<li><p>Useful options for <code>git log</code></p>
<ul>
<li><p><code>git log -p -2</code> will display <strong>2 most recent commits</strong>, and also showing the <strong>patches/changes made</strong></p>
</li>
<li><p><code>git log --stat</code> helps you quickly browse what happened during a series of commits that a collaborator has added. It will show additional information such as: <strong>a list of modified files</strong>, <strong>how many files were changed</strong>, and <strong>how many lines in those files were added and removed</strong>. It also puts a <strong>summary of the information at the end</strong>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ git log --stat</span><br><span class="line">commit cae63d011d113c1d45818de4bec434216e10e9ef (HEAD -&gt; master)</span><br><span class="line">Author: Xiao Yu &lt;jasonyux17@gmail.com&gt;</span><br><span class="line">Date:   Wed May 20 10:59:55 2020 +0800</span><br><span class="line"></span><br><span class="line">    tested git file removal and untracking</span><br><span class="line"></span><br><span class="line"> firstFile.txt   | 6 ------</span><br><span class="line"> justTracked.txt | 0</span><br><span class="line"> 2 files changed, 6 deletions(-)</span><br><span class="line"></span><br><span class="line">commit 0e6428a6389d7748a0da2f0798be94999ce8c248</span><br><span class="line">Author: Xiao Yu &lt;jasonyux17@gmail.com&gt;</span><br><span class="line">Date:   Wed May 20 10:34:31 2020 +0800</span><br><span class="line"></span><br><span class="line">    second commit made</span><br><span class="line"></span><br><span class="line"> firstFile.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">commit 2031fb7fd0a90cf62d1c13d7cfb972e1ce10ad30</span><br><span class="line">Author: Xiao Yu &lt;jasonyux17@gmail.com&gt;</span><br><span class="line">Date:   Wed May 20 10:28:14 2020 +0800</span><br><span class="line"></span><br><span class="line">    first commit made</span><br><span class="line"></span><br><span class="line"> LICENSE.txt     | 5 +++++</span><br></pre></td></tr></table></figure></li>
<li><p><code>git log --pretty=oneline</code> This option <strong>changes the log output to formats</strong> other than the default. A few prebuilt options are available for you to use. The <code>oneline</code> option <strong>prints each commit on a single line</strong>, which is useful if you’re looking at a lot of commits.</p>
</li>
<li><p><code>git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</code> This is customizing the format of the commit output. For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty&#x3D;format:&quot;%h - %an - %ar, commit: %s&quot;</span><br><span class="line">cae63d0 - Xiao Yu - 23 minutes ago, commit: tested git file removal and untracking</span><br><span class="line">0e6428a - Xiao Yu - 49 minutes ago, commit: second commit made</span><br><span class="line">2031fb7 - Xiao Yu - 55 minutes ago, commit: first commit made</span><br><span class="line">75d2c61 - Xiao Yu - 18 hours ago, commit: Initial project version</span><br></pre></td></tr></table></figure>
<p>So we can have options such as:</p>
<ul>
<li><code>%h</code> Abbreviated commit hash</li>
<li><code>%an</code> author name</li>
<li><code>%ar</code> author date, relative to now</li>
<li><code>%s</code> subject/commit message</li>
</ul>
</li>
<li><p><code>git log --since=&quot;2008-10-01&quot;</code> Limit the commits to those made after the specified date. You can also put “2.weeks” or “2 years 1 day 3 minutes ago”</p>
</li>
<li><p><code>git log --before=&quot;2008-10-01&quot;</code> Limit the commits to those made before the specified date.</p>
</li>
<li><p><code>git log --author=&quot;Xiao Yu&quot;</code> Only show commits in which the author entry matches the specified string.</p>
</li>
<li><p><code>git log --committer=&quot;Xiao Yu&quot;</code> Only show commits in which the committer entry matches the specified string.</p>
</li>
<li><p><code>git log --no-merges</code> to prevent the display of merge commits cluttering up your log history, which usually are not informative</p>
</li>
</ul>
</li>
</ul>
<h2 id="Changing-your-Commit-Stage"><a href="#Changing-your-Commit-Stage" class="headerlink" title="Changing your Commit/Stage"></a>Changing your Commit/Stage</h2><ol>
<li><p>If you forget to do some small changes, but you have just committed, you can easily “re-commit” by</p>
<ul>
<li>first make those additional changes you forgot</li>
<li>then <strong>stage them</strong></li>
<li>then <strong>committ again</strong> using <code>git commit --amend</code> to automatically include the new changes <strong>into the previous commit</strong></li>
</ul>
</li>
<li><p>If you want to “re-stage” a file for making additional changes, you use <code>git restore --staged &lt;file&gt;</code>. In fact, this adviced by the command <code>git status</code> as well:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        modified:   README.md</span><br></pre></td></tr></table></figure>
<p>Now, the file [README.md] is unstaged and you can add changes to it and restage.</p>
</li>
<li><p>If you want to <strong>revert the file to its previous committed state</strong> (you cannot revert to those added state), you execute <code>git restore &lt;file&gt;</code>. In fact, this is also adviced by the command <code>git status</code> <strong>if the file is in the unstaged area</strong></p>
<blockquote>
<p>Note:</p>
<ul>
<li><input disabled="" type="checkbox"> If you use the <code>restore</code> command, <strong>any local changes you made to that file are gon</strong>e — Git just <strong>replaced that file with the most recently-committed version</strong>. Don’t ever use this command unless you absolutely know that you don’t want those unsaved local changes.</li>
</ul>
</blockquote>
<p> If you would like to <strong>keep the changes</strong> you’ve made to that file but <strong>still need to get it out of the way for now</strong>, we’ll go over stashing and branching in <a href="#gitbranching">Git Branching</a>; these are generally better ways to go.</p>
</li>
</ol>
<h2 id="Working-with-Remotes"><a href="#Working-with-Remotes" class="headerlink" title="Working with Remotes"></a>Working with Remotes</h2><p>To be able to collaborate on any Git project, you need to know how to <strong>manage your remote repositories</strong>. Remote repositories are <strong>versions of your project that are hosted on the Internet or network somewhere</strong>. Managing these remote repositories involves <strong>pushing and pulling data to and from them</strong> when you need to share work.</p>
<ul>
<li>To show the remote server for repo in the current  directory, you can execute <code>git remote</code>, or <code>git remote -v</code> to see the URLs stored as well.</li>
<li>To add a remote server, you can execute <code>git remote add &lt;shortname&gt; &lt;url&gt;</code>, which will configure the <strong>shortname/nickname</strong> for that repo. Then you can <strong>use that shortname to access that repo</strong>.<blockquote>
<p>Note:</p>
<ul>
<li><input disabled="" type="checkbox"> You can only add remote repo in an existing repo</li>
<li><input disabled="" type="checkbox"> Executing <code>git clone &lt;url&gt;</code> will give you a default shortname of <code>origin</code></li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Difference-between-git-clone-and-git-remote-add"><a href="#Difference-between-git-clone-and-git-remote-add" class="headerlink" title="Difference between git clone and git remote add"></a>Difference between <code>git clone</code> and <code>git remote add</code></h2><ul>
<li><p><code>git remote add</code> just creates an entry in your git config that specifies a name for a particular URL. You must have an existing git repo to use this. You will not see a folder or any file from that repo. To get them, you need to use <code>git pull &lt;shortname&gt; &lt;branch&gt;</code></p>
</li>
<li><p><code>git clone</code> creates a new git repository by copying an existing one located at the URL you specify. This will be physical.</p>
</li>
</ul>
<h2 id="Fetching-and-Pulling-from-Remote-Repos"><a href="#Fetching-and-Pulling-from-Remote-Repos" class="headerlink" title="Fetching and Pulling from Remote Repos"></a>Fetching and Pulling from Remote Repos</h2><ol>
<li><code>git fetch &lt;remote&gt;</code> This command goes out to that remote project and <strong>pulls down all the data from that remote project that you don’t have yet</strong>. After you do this, you should have references to all the branches from that remote, which you can merge in or inspect at any time (merge operations will be discussed in <a href="#gitbranching">Git Branching</a>).</li>
<li>If you <strong>cloned a repository</strong>, the command  <code>git fetch origin</code> fetches <strong>any new work that has been pushed to that server</strong> since you cloned (or last fetched from) it<blockquote>
<p>Note:</p>
<ul>
<li><input disabled="" type="checkbox"> <code>git fetch</code> command only <strong>downloads the data to your local repository</strong> — it <strong>doesn’t automatically merge it</strong> with any of your work <strong>or modify what you’re currently working on</strong>. You have to merge it manually into your work when you’re ready</li>
<li><input disabled="" type="checkbox"> <code>get pull</code> will <strong>fetch and merge the remote branches into your current branch</strong>. More covered in <a href="#gitbranching">Git Branching</a></li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="Pushing-Sharing-to-Your-Remote"><a href="#Pushing-Sharing-to-Your-Remote" class="headerlink" title="Pushing/Sharing to Your Remote"></a>Pushing/Sharing to Your Remote</h2><p>When you have your project at a point that you want to share, you have to push it upstream. The command for this is simple: <code>git push &lt;remote&gt; &lt;branch&gt;</code>. If you want to <strong>push your master branch to your origin server</strong> (again, cloning generally sets up both of those names for you automatically), then you can run this to <strong>push any commits you’ve done</strong> back up to the server:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note:</p>
<ul>
<li><input disabled="" type="checkbox"> This command works only <strong>if you cloned from a server</strong> to which you <strong>have write access</strong> and <strong>if nobody has pushed in the meantime</strong>. If someone else if pushing, your push will be rejected and you will have to <strong>fetch their work first and incorporate it into yours</strong> before you’ll be allowed to push. </li>
</ul>
</blockquote>
<h2 id="Renaming-or-Removing-Remote-Repo"><a href="#Renaming-or-Removing-Remote-Repo" class="headerlink" title="Renaming or Removing Remote Repo"></a>Renaming or Removing Remote Repo</h2><ol>
<li>If you want to rename a shorthand for a remote repo, you can execute <code>git remote rename &lt;originalName&gt; &lt;newName&gt;</code> to change a remote’s shortname.</li>
<li>If you want to <strong>remove a remote for some reason</strong> — you’ve moved the server or are no longer using a particular mirror, or perhaps a contributor isn’t contributing anymore, you can use <code>git remote remove &lt;shortname&gt;</code></li>
</ol>
<h2 id="Inspecting-a-Remote-for-Pushing-and-Pulling-Information"><a href="#Inspecting-a-Remote-for-Pushing-and-Pulling-Information" class="headerlink" title="Inspecting a Remote for Pushing and Pulling Information"></a>Inspecting a Remote for Pushing and Pulling Information</h2><p>If you want to see more information about a particular remote, you can use the <code>git remote show &lt;remote&gt;</code> command</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show pb</span><br><span class="line">* remote pb</span><br><span class="line">  Fetch URL: https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit</span><br><span class="line">  Push  URL: https:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master tracked</span><br><span class="line">    ticgit tracked</span><br><span class="line">  Local ref configured for &#39;git push&#39;:</span><br><span class="line">    master pushes to master (local out of date)</span><br></pre></td></tr></table></figure>
<p>It lists the URL for the remote repository as well as the tracking branch information. The command helpfully tells you that if you’re on the master branch and you run git pull, it will automatically merge in the master branch on the remote after it fetches all the remote references. It also lists all the remote references it has pulled down.</p>
<p>In general, it will show you:</p>
<ul>
<li>which <strong>branch is automatically pushed to when you run <code>git push</code> while on certain branches</strong></li>
<li>which <strong>remote branches on the server you don’t yet have</strong></li>
<li>which <strong>remote branches you have but have been removed from the server</strong></li>
<li>multiple <strong>local branches that are able to merge</strong> automatically with their remote-tracking branch when you run <code>git pull</code></li>
</ul>
<h2 id="Tagging"><a href="#Tagging" class="headerlink" title="Tagging"></a>Tagging</h2><p>Git has the ability to <strong>tag specific points in a repository’s history as being important</strong>. Typically, people use this functionality to mark release points (<code>v1.0</code>, <code>v2.0</code> and so on).</p>
<h2 id="Listing-the-Tags-of-a-Repo"><a href="#Listing-the-Tags-of-a-Repo" class="headerlink" title="Listing the Tags of a Repo"></a>Listing the Tags of a Repo</h2><p>You can list <strong>all the tags</strong> by calling:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note:</p>
<ul>
<li><input disabled="" type="checkbox"> this command lists the tags in <strong>alphabetical order</strong>; the order in which they are displayed <strong>has no real importance</strong>.</li>
</ul>
</blockquote>
<p>You can also filter the tags by using the optional <code>-l</code> or <code>--list</code>, for example</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -l &quot;v1.8.5*&quot;</span><br></pre></td></tr></table></figure>
<p>This will list all the tags that *<em>starts with *</em><code>v1.8.5</code></p>
<h2 id="Creating-Tags"><a href="#Creating-Tags" class="headerlink" title="Creating Tags"></a>Creating Tags</h2><p>You can have two types of tags:</p>
<ol>
<li><p>a <strong>lightweight tag</strong></p>
<ul>
<li>it’s just a pointer to a specific commit. It <strong>does not have much information</strong> attached to it. (It does have a <strong>Checksum</strong>, and includes the <strong>author information</strong>) It is often used as a <strong>temporary tag</strong>.</li>
</ul>
</li>
<li><p>an <strong>annotated tag</strong></p>
<ul>
<li>stored as full objects in the Git database. They’re <strong>checksummed</strong>; contain the <strong>tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG)</strong>. It’s generally recommended that you create annotated tags so you can have all this information</li>
</ul>
</li>
</ol>
<blockquote>
<p>Note:</p>
<ul>
<li><input disabled="" type="checkbox"> Those tags will be attached to the <strong>lastest committed version</strong> of your repo</li>
</ul>
</blockquote>
<h2 id="Creating-a-Lightweight-Tag"><a href="#Creating-a-Lightweight-Tag" class="headerlink" title="Creating a Lightweight Tag"></a>Creating a Lightweight Tag</h2><p> This is basically the commit checksum stored in a file — no other information is kept. To create a lightweight tag, <strong>don’t supply</strong> any of the <code>-a</code>, <code>-s</code>, or <code>-m</code> options, just provide a tag name.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag &lt;tag-id&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Creating-an-Annotated-Tag"><a href="#Creating-an-Annotated-Tag" class="headerlink" title="Creating an Annotated Tag"></a>Creating an Annotated Tag</h2><p>This is created by </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a &lt;tag-id&gt; -m &quot;yourMessage&quot;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">- &#96;-a&#96;, &#96;-s&#96;, or &#96;-u&#96; &#96;&lt;keyid&gt;&#96; is passed, the command **creates a tag object**, and **requires a tag message**. Unless &#96;-m &lt;msg&gt;&#96; or &#96;-F &lt;file&gt;&#96; is given, **an editor is started for the user to type in the tag message**.</span><br><span class="line"></span><br><span class="line">Then to see the message in that tag, use</span><br></pre></td></tr></table></figure>
<p>$ git show <tag-id></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; Note:</span><br><span class="line">&gt; - [ ] Don&#39;t be mistaken to execute &#96;git tag show &lt;tag-id&gt;&#96;!</span><br><span class="line"></span><br><span class="line">## Tagging Previous Commits</span><br><span class="line">To **tag any specific commit**, you specify the **commit checksum (or part of it)** at the end of the command:</span><br></pre></td></tr></table></figure>
<p>$ git tag -a <tag-id> -m “yourMessage” <commit-checksum></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Sharing Tags</span><br><span class="line">By default, the &#96;git push&#96; command **doesn’t transfer tags to remote servers**. You will have to explicitly push tags to a shared server after you have created them. This process is just like sharing remote branches — you can run</span><br></pre></td></tr></table></figure>
<p>$ git push <repo-shortname> <tagname></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To push **all the tags**, you run</span><br></pre></td></tr></table></figure>
<p>$ git push <repo-shortname> –tags</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Deleting Tags</span><br><span class="line">You can use</span><br></pre></td></tr></table></figure>
<p>$ git tag -d <tag-id></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">to delete a specific tag. However, this does not remove the tag from the remote servers.</span><br><span class="line"></span><br><span class="line">To delete the tag from the server, you could either use:</span><br></pre></td></tr></table></figure>
<p>$ git push origin –delete <tag-id></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">or, the slightly less intuitive command</span><br></pre></td></tr></table></figure>
<p>$ git push origin :refs/tags/v1.4-lw</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">which means the **null value before the colon** is being pushed to the **remote tag name**, effectively deleting it.</span><br><span class="line"></span><br><span class="line">## Viewing Files at a Different State using Tag</span><br><span class="line">You can view the different versions of files by using its tag. This is done by a &#96;git checkout&#96; of that tag, although this puts your repository in “detached HEAD” state, (which has some ill side effects)</span><br><span class="line">-  in a detached-head state, if you **make changes and then create a commit**, the tag will stay the same, but your **new commit won’t belong to any branch and will be unreachable**, except by the exact commit hash. Thus, if you need to make changes — say you’re fixing a bug on an older version, for instance — you will **generally want to create a branch** (covered more in [Git Branching](#gitbranching))</span><br><span class="line"></span><br><span class="line">***Q: What does &#96;git checkout&#96; mean?***</span><br><span class="line"></span><br><span class="line">If you call &#96;git log&#96;, you will see something called &#96;HEAD&#96;. &#96;HEAD&#96; is a label noting where you are in the **commit tree**. It moves with you when you **move from one commit to another**. &#96;git checkout &lt;commit&gt;&#96; is the basic mechanism for **moving around in the commit tree, moving your focus (HEAD) to the specified commit**.</span><br><span class="line"></span><br><span class="line">The commit can be specified by any of a number of ways, **commit hash**, **branch name**, **tag name**, the relative syntax (HEAD^, HEAD~1, etc.) and so on. (It is often useful to consider a checkout to be changing branches)</span><br><span class="line"></span><br><span class="line">## Git Alias</span><br><span class="line">Alias can be understood as shortcuts to execute commands. They can be setup by using the &#96;git config&#96; command.</span><br><span class="line"></span><br><span class="line">For example:</span><br></pre></td></tr></table></figure>
<p>$ git config –global alias.co checkout<br>$ git config –global alias.br branch<br>$ git config –global alias.ci commit<br>$ git config –global alias.st status</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">This means that </span><br><span class="line">- &#96;git checkout&#96; becomes &#96;git co&#96;</span><br><span class="line">- &#96;git branch&#96; becomes &#96;git br&#96;</span><br><span class="line">- &#96;git commit&#96; becomes &#96;git ci&#96;</span><br><span class="line">- &#96;git status&#96; becomes &#96;git st&#96;</span><br><span class="line"></span><br><span class="line">&gt; Note:</span><br><span class="line">&gt; - [ ] &#96;global&#96; means access for **one user** (yourself) in **all the repos**. In comparison, &#96;local&#96; means for **one user** in this **specific repo**. &#96;system&#96; means for **all users** in **all repos**.</span><br><span class="line"></span><br><span class="line">Some useful **alias** include:</span><br></pre></td></tr></table></figure>
<p>$ git config –global alias.last ‘log -1 HEAD’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">So you can see the last commit easily:</span><br></pre></td></tr></table></figure>
<p>$ git last<br>commit e946cadfbd3b378582b0be5e5385a7702d1d10da (HEAD -&gt; master, tag: v1.0)<br>Author: Xiao Yu <a href="mailto:&#106;&#97;&#x73;&#x6f;&#x6e;&#121;&#x75;&#x78;&#49;&#55;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;">&#106;&#97;&#x73;&#x6f;&#x6e;&#121;&#x75;&#x78;&#49;&#55;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#109;</a><br>Date:   Wed May 20 10:59:55 2020 +0800</p>
<pre><code>amended: edited AND deleted file removal and untracking</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Resetting the Alias</span><br><span class="line">If you find certain alias used before as a bad idea, you can do</span><br></pre></td></tr></table></figure>
<p>$ git config –global –unset alias.<yourAlias></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">You can also directly edit in the config file to change the alias by:</span><br></pre></td></tr></table></figure>
<p>$ git config –global –edit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">which will open the default text editor and then you can edit your alias directly (delete it if not needed).</span><br><span class="line"></span><br><span class="line">## Git Branching</span><br><span class="line"> Git doesn’t store data as a series of changesets or differences, but instead as a **series of snapshots**.</span><br><span class="line"></span><br><span class="line">When you **make a commit**, Git stores a **commit object that contains a pointer to the snapshot** of the content you staged. This object also contains the author’s name and email address, the message that you typed, and **pointers to the commit or commits that directly came before this commit** (its parent or parents): **zero parents for the initial commit**, **one parent for a normal commit**, and **multiple parents for a commit that results from a merge of two or more branches**.</span><br><span class="line"></span><br><span class="line">1. When you staged a file&#x2F;files</span><br><span class="line">   - Staging the files computes a **checksum for each one** (the SHA-1 hash we mentioned in Getting Started)</span><br><span class="line">   - then **stores that version of the file in the Git repository** (Git refers to them as **blobs**)</span><br><span class="line">   - finally **adds that checksum to the staging area**</span><br><span class="line">2. When you commit by running &#96;git commit&#96;</span><br><span class="line">	- Git **checksums each subdirectory** (in this case, just the root project directory) </span><br><span class="line">	- stores them as a **tree object** in the Git repository. </span><br><span class="line">	- Git then creates a commit object that has the metadata and a **pointer to the root project tree** so it can re-create that snapshot when needed.</span><br><span class="line"></span><br><span class="line">If you had 3 files that were staged, and you committed them, you will get in totl five objects: **three blobs** (each representing the contents of one of the three files), **one tree** that lists the contents of the directory and specifies which file names are stored as which blobs, and **one commit** with the pointer to that root tree and all the commit metadata.</span><br><span class="line"></span><br><span class="line">If you make some changes and commit again, the next **commit object** stores a **(parent) pointer** to the **commit object** that came immediately before it. Essentially it is like a linked list of **commit objects**.</span><br><span class="line"></span><br><span class="line">**A branch in Git is simply a lightweight movable pointer to one of these commits objects**. The default branch name in Git is **master** (default when you run &#96;git init&#96;). As you start making commits, you’re given a master branch that **points to the last commit you made**. Every time you commit, the master branch pointer moves forward automatically.</span><br><span class="line"></span><br><span class="line">## Create a New Branch</span><br><span class="line"> Creating a new branch means **creating a new pointer for you to move around**. Let’s say you want to create a new branch called testing. You do this with the git branch command:</span><br></pre></td></tr></table></figure>
<p>$ git branch <newBranchName></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; Note:</span><br><span class="line">&gt; - [ ] this new branch will by default point to the **current commit object (the head)** you are working on.</span><br><span class="line">&gt; - [ ] you can see the head commit object by running &#96;git log&#96;</span><br><span class="line"></span><br><span class="line">## Switching Branches</span><br><span class="line">To switch to an existing branch, you run the &#96;git checkout&#96; command.</span><br></pre></td></tr></table></figure>
<p>$ git checkout <branchName></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">For example, if you have another branch called &#96;testing&#96;, you switch to that by &#96;git checkout testing&#96;.</span><br><span class="line"></span><br><span class="line">This will move the **head** to the **new branch you are at**. This means that now, if you make modifications and commit, you will create a **new commit object that the head&#x2F;your current branch points to**, but **the other branch still points to the original commit object**.</span><br><span class="line"></span><br><span class="line">&gt; Note:</span><br><span class="line">&gt; - [ ] Now, if you run &#96;git log&#96;, you will **not see the new commit object that is made by the testing branch**. By default, git log will only show commit history below the branch you’ve checked out.</span><br><span class="line">&gt; - [ ] In general, if you move backward in the tree, you will not be able to see future **commit objects** by running &#96;git log&#96;</span><br><span class="line">&gt; - [ ] To **show commit history for the desired branch** you have to explicitly specify it: &#96;git log &lt;branchName&gt;&#96;. To **show all of the branches**, run &#96;git log --all&#96;.</span><br><span class="line">&gt; - [ ] You can actually create a new branch and switching to it at the same time — this can be done in one operation with &#96;git checkout -b &lt;newBranchName&gt;&#96;</span><br><span class="line"></span><br><span class="line">However, if you have made some changes in this new branch and **switched back to the old branch**, your current working directory will be **reverted back to the snapshot that old branch points to**. Now, if you make some changes on the old branch, the **two branch will diverge**:</span><br><span class="line">- the new branch does not know that change made in the old branch</span><br><span class="line">- the old branch cannot go forward directly to the new branch because **a commit object** that both shared has been changed now</span><br><span class="line">- basically, you will have two different commit objects, one for the **old branch**, and another for the **new branch**, both links to the same parent. </span><br><span class="line"></span><br><span class="line">But don&#39;t worry, **in the end you can merge them together when you’re ready**.</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">**Making a Disaster**:</span><br><span class="line">1. You can create a branch that points to the current **head** position, and then switch to the **master** branch. Then you can move the **head** using the checksum of the first commit by doing</span><br></pre></td></tr></table></figure>
<p>git checkout <checkSum></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Now, the master head will point to the inital commit. If your friend is also working on this branch, they will be dismayed as thinking somehow all the progress is lost, but in fact it is kept by the other branch that you just created.</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## Viewing the Diversion Tree</span><br><span class="line">The entire tree for all branches can be seen by running</span><br></pre></td></tr></table></figure>
<p>$ git log –oneline –graph –all</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For example, it can look like this:</span><br></pre></td></tr></table></figure>
<p>$ git log –oneline –graph –all</p>
<ul>
<li>ae182e6 (HEAD, testing) first commit made now more with the new testing branch<br>| * e946cad (tag: v1.0, master) amended: edited AND deleted file removal and untracking<br>| * 0e6428a second commit made<br>| * 2031fb7 (tag: v0.1) first commit made<br>|/</li>
<li>75d2c61 Initial project version</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">So we see that the two branches are diverged at the first **commit object**.</span><br><span class="line"></span><br><span class="line">## Merging Different Branches</span><br><span class="line">There are basically two cases: </span><br><span class="line">1. You have **two diverged branches**, but **they used different files**, or, to put it more suggestively, the **file they shared are the same**. In this case, it is simple for Git to figure out how to merge (basically just putting all the files together), and you run:</span><br><span class="line">![Picture from git-scm.com, figure 25](Git-Summary&#x2F;mergingCase1.png)</span><br></pre></td></tr></table></figure>
<pre><code>$ git checkout master
$ git merge testing
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	&gt; Note:</span><br><span class="line">	&gt; - [ ] This means that you are merging files **from the testing branch to the master branch**</span><br><span class="line">	&gt; - [ ] The merge operation will only be allowed if you have **committed in the testing branch**&#x2F;current working directory</span><br><span class="line"></span><br><span class="line">2. You have **two diverged branches**, and they **share a file that is modified differently in both branches**. Now, if you want to merge them, Git will show you:</span><br></pre></td></tr></table></figure>
$ git merge testing
Auto-merging firstFile.txt
CONFLICT (content): Merge conflict in firstFile.txt
Automatic merge failed; fix conflicts and then commit the result.
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  In this example, [firstFile.txt] is modified for both branches, and they both depend on it. Therefore, the merging cannot be completed, and you will need to **manually edit that file**.</span><br><span class="line"></span><br><span class="line">  When you finish editing that file, you run &#96;git add &lt;thatFile&gt;&#96; to **mark it as resolved**, and then call &#96;git commit&#96; to **complete the merge**.</span><br><span class="line"></span><br><span class="line">In the end, when you have finished all the work, you can delete the branch you don&#39;t need by:</span><br></pre></td></tr></table></figure></code></pre><p>$ git branch -d <branchName></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Branch Management</span><br><span class="line">There are a handful of commands with &#96;git branch&#96; that is useful for branch management:</span><br><span class="line">- &#96;git branch&#96; This will show you a list of branches that yuo have, with an asterisk &#96;*&#96; in front of the current branch you are on.</span><br><span class="line">- &#96;git branch -v&#96; Shows you a list of branches with their last commit message </span><br><span class="line">- &#96;git branch --merged&#96; shows you branches that have been merged</span><br><span class="line">- &#96;git branch --unmerged&#96; shows you branches that have not been merged</span><br><span class="line"></span><br><span class="line">&gt; Note</span><br><span class="line">&gt; - [ ] Each of the command above shows the information **relative to the current branch**. To specify which branch you want to know, you can do, for example, &#96;git branch --no-merged testing&#96; (to get information **relative to the testing branch**)</span><br><span class="line"></span><br><span class="line">## Typical WorkFlow Using Git Branches</span><br><span class="line">Usually, people tend to put **code that is entirely stable in their master branch** — possibly only code that has been or will be released. They have another parallel branch named **develop** or **next** that they work from or use to test stability — it isn’t necessarily always stable, but whenever it gets to a **stable state, it can be merged into master**.</span><br><span class="line">  </span><br><span class="line">  In general, for some larger projects, you will want your branches are at various levels of stability, ordered from most stable top branch (**master**) to the least stable bottom branch(**topic**, for example); when they reach a **more stable level, they’re merged into the branch above them**.</span><br><span class="line"></span><br><span class="line">![picture from https:&#x2F;&#x2F;git-scm.com&#x2F;book&#x2F;en&#x2F;v2&#x2F;Git-Branching-Branching-Workflows](Git-Summary&#x2F;branchManagement.png)</span><br><span class="line"></span><br><span class="line">&gt; Note:</span><br><span class="line">&gt; - [ ] It’s important to remember when you’re doing all this that **these branches are completely local**. When you’re branching and merging, **everything is being done only in your Git repository** — there is no communication with the server, for now.</span><br><span class="line"></span><br><span class="line">## Remote Branches</span><br><span class="line">**Remote-tracking branches** are references to the state of remote branches. They’re **local references that you can’t move**; **Git moves them for you whenever you do any network communication**, to make sure they accurately represent the state of the remote repository. Think of them as bookmarks, to remind you where the branches in your remote repositories were the last time you connected to them.</span><br><span class="line"></span><br><span class="line">**Remote-tracking branch names** take the form &#96;&lt;remoteShortName&gt;&#x2F;&lt;branch&gt;&#96;. For instance, if you wanted to see what the &#96;master&#96; branch on your &#96;origin&#96; remote looked like as of the last time you communicated with it, you would check the &#96;origin&#x2F;master&#96; branch. This means that, if you were working on an issue with a partner and they **pushed up an &#96;iss53&#96; branch**, but **you also have your own local &#96;iss53&#96; branch**, the branch on the server would be represented by the remote-tracking branch &#96;origin&#x2F;iss53&#96; **updated with your friend&#39;s version**</span><br><span class="line"></span><br><span class="line">Now, to synchronize your work with a given remote, you run</span><br></pre></td></tr></table></figure>
<p>$ git fetch <remoteShortName> command</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This command looks up which server “&#96;origin&#96;” is (for example, it might be cloned from &#96;git.ourcompany.com&#96;), **fetches any data from it that you don’t yet have**, and updates your local database, moving your &#96;origin&#x2F;master&#96; pointer to its new, more up-to-date position, but your **current &#96;master&#96; pointer is still the same as you were working with**.</span><br><span class="line"></span><br><span class="line">## Colaborating with Multiple Repos</span><br><span class="line"></span><br><span class="line">Say you have a main repo that you have cloned, with the shortname &#96;origin&#96; at &#96;git.outcompany.com&#96;, and you have another team working on that repo as well, with their repo being at &#96;git team1.ourcompany.com&#96;</span><br><span class="line"></span><br><span class="line">![Picture from https:&#x2F;&#x2F;git-scm.com&#x2F;book&#x2F;en&#x2F;v2&#x2F;Git-Branching-Remote-Branches, Figure 33](Git-Summary&#x2F;remoteBranches1.png)</span><br><span class="line"></span><br><span class="line">You can add their work to your current repo by</span><br></pre></td></tr></table></figure>
<p>$ git remote add git.team1.ourcompany.com teamone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Now, you have their repo with the shortname &#96;teamone&#96;. You can fetch their progress to your local machine by:</span><br></pre></td></tr></table></figure>
<p>$ git fetch teamone</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In this case, since &#96;teamone&#96; actually didn&#39;t have anything more than the server had, nothing will be fecthed, but you will still obtain a **branch &#96;teamone&#96; that marks their progress**</span><br><span class="line"></span><br><span class="line">![Picture from https:&#x2F;&#x2F;git-scm.com&#x2F;book&#x2F;en&#x2F;v2&#x2F;Git-Branching-Remote-Branches, Figure 34](Git-Summary&#x2F;remoteBranches2.png)</span><br><span class="line"></span><br><span class="line">&gt; Note:</span><br><span class="line">&gt; - [ ] At this point, if all you have called is &#96;fetch&#96;, you will **not have a physical copy of their work on your local machine**, but just a **unmovable pointer**. To get their work to your local machine and work on it, you need to call &#96;git merge teamone&#x2F;master&#96; and switch to that, or &#96;git checkout -b teamone teamone&#x2F;master&#96;, which creates a new **local branch called &#96;teamone&#96; that has all the progress on the server of &#96;teamone&#96;**.</span><br><span class="line"></span><br><span class="line">## Pushing Your Branch to the Server</span><br><span class="line"> Your **local branches aren’t automatically synchronized** to the remotes you write to — you have to explicitly push the branches you want to share. That way, you can use private branches for work you don’t want to share, and **push up only the topic branches you want to collaborate on**.</span><br><span class="line"></span><br><span class="line">To do this, you run:</span><br></pre></td></tr></table></figure>
<p>$ git push <remoteShortName> <yourBranchName></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">For example, you want to push up a branch &#96;serverfix&#96; to the server with shortname &#96;origin&#96;, you run:</span><br></pre></td></tr></table></figure>
<p>$ git push origin serverfix<br>Counting objects: 24, done.<br>Delta compression using up to 8 threads.<br>Compressing objects: 100% (15/15), done.<br>Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.<br>Total 24 (delta 2), reused 0 (delta 0)<br>To <a href="https://github.com/schacon/simplegit" target="_blank" rel="noopener">https://github.com/schacon/simplegit</a></p>
<ul>
<li>[new branch]      serverfix -&gt; serverfix<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; Note:</span><br><span class="line">&gt; - [ ] The command &#96;git push origin serverfix&#96; is a bit of a shortcut. The slightly more complete version is &#96;git push origin serverfix:serverfix&#96;, which means to **push the &#96;serverfix&#96; branch of the local machine (left side of colon) to the &#96;serverfix&#96; branch of the server (right side of colon)**. This means you could also push to have **different names** by &#96;git push origin serverfix:anotherNameOnServer&#96;</span><br><span class="line"></span><br><span class="line">## Tracking Branches</span><br><span class="line">Checking out a **local branch from a remote-tracking branch automatically creates what is called a “tracking branch”** (and the branch it tracks is called an “upstream branch”). Tracking branches are local branches that have a **direct relationship to a remote branch**. If you’re on a tracking branch and type &#96;git pull&#96;, Git automatically knows which server to &#96;fetch&#96; from and which branch to merge in.</span><br><span class="line"></span><br><span class="line">For example, when you made a &#96;clone&#96; from the server with shorthand &#96;origin&#96;, you made a **tracking branch** with a **master** branch that **tracks** the **origin&#x2F;master** branch.</span><br><span class="line"></span><br><span class="line">In general, when you do</span><br></pre></td></tr></table></figure>
$ git checkout -b <branchName> <remoteShortName>/<branchName><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">You create a tracking branch of &#96;&lt;branchName&gt;&#96; tracking the &#96;&lt;remoteShortName&gt;&#x2F;&lt;branchName&gt;&#96;</span><br><span class="line"></span><br><span class="line">In fact, this is so common that you could do the **same thing** by running, more explicitly:</span><br></pre></td></tr></table></figure>
$ git checkout –track origin/serverfix<br>Branch serverfix set up to track remote branch serverfix from origin.<br>Switched to a new branch ‘serverfix’<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">But this will setup the **same branchname as the branchname on the remote**. If you want to **change the local branchname**, use the first one &#96;git checkout -b &lt;branchName&gt; &lt;remoteShortName&gt;&#x2F;&lt;branchName&gt;&#96;</span><br><span class="line"></span><br><span class="line">## Difference between &#96;git fetch&#96; and &#96;git pull&#96;</span><br><span class="line">&#96;git fetch&#96; only gets you information on what their progess is, but **does not have a physical copy** of their work. &#96;git pull&#96; gets you both the information about their progess **and a physical copy on your local machine** of their work on server. </span><br><span class="line"></span><br><span class="line">&#96;git pull&#96;  is essentially a &#96;git fetch&#96; immediately followed by a &#96;git merge&#96; in most cases. If you **have a tracking branch set up** as demonstrated in the last section, either by explicitly setting it or by having it created for you by the clone or checkout commands, &#96;git pull&#96; **will look up what server and branch your current branch is tracking**, **fetch from that server and then try to merge in that remote branch for you**.</span><br><span class="line"></span><br><span class="line">## Viewing the Current Tracking Branch</span><br><span class="line">You can view the current tracking branches by:</span><br></pre></td></tr></table></figure>
$ git fetch –all<br>$ git branch -vv<br>iss53     7e424c3 [origin/iss53: ahead 2] Add forgotten brackets<br>master    1ae2a45 [origin/master] Deploy index fix<ul>
<li>serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] This should do it<br>testing   5ea463a Try something new<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">So here we can see that:</span><br><span class="line">- &#96;iss53&#96; branch is tracking &#96;origin&#x2F;iss53&#96; and is “ahead” by two, meaning that we have **two commits locally that are not pushed to the server**. </span><br><span class="line">- &#96;master&#96; branch is tracking &#96;origin&#x2F;master&#96; and is up to date. </span><br><span class="line">- &#96;serverfix&#96; branch is tracking the &#96;server-fix-good&#96; branch on our teamone server and is ahead by three and behind by one, meaning that there is **one commit on the server we haven’t merged in** yet and three commits locally that we haven’t pushed. </span><br><span class="line">- &#96;testing&#96; branch is **not tracking any remote branch**.</span><br><span class="line">&gt; Note:</span><br><span class="line">&gt; - [ ] We ran &#96;git fetch --all&#96; before to make sure the **data we have locally about the server is up-to-date**. This means that &#96;git branch --vv&#96; will only **compare the cached data from the server, and it does not update from the server if there are any changes**.</span><br><span class="line"></span><br><span class="line">## Switching a Tracking Branch</span><br><span class="line">If you have a **local branch that you want to track another branch on the server**, you can use the &#96;-u&#96; or &#96;--set-upstream-to&#96; option to &#96;git branch&#96; to explicitly set your **current branch** at any time:</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>$ git branch -u <remoteShortName>/<branchName></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Deleting a Remote Branch</span><br><span class="line">Suppose you’re **done with a remote branch** — say you and your collaborators are finished with a feature and have **merged it into your remote’s master branch** (or whatever branch your stable codeline is in). You can delete a remote branch using the</span><br></pre></td></tr></table></figure>
<p>git push <remoteShortName> –delete <remoteBranchName></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; Note:</span><br><span class="line">&gt; - [ ] You don&#39;t need to use &#96;--delete &lt;remoteShortName&gt;&#x2F;&lt;remoteBranchName&gt;&#96;, because it is repetitive</span><br><span class="line">&gt; - [ ] This operation **does not remove the branch in the server immediately**. All this does is **remove the pointer from the server**. The Git server will generally keep the data there for a while **until a garbage collection runs**, so if it was accidentally deleted, it’s often easy to recover.</span><br><span class="line"></span><br><span class="line">## Rebasing</span><br><span class="line">In Git, there are **two main ways to integrate changes from one branch into another**: the &#96;merge&#96; and the &#96;rebase&#96;. </span><br><span class="line"></span><br><span class="line">This second operation &#96;rebase&#96; basically stand from the fact that &#96;merge&#96; does a three-way-merge, so that in all case, even if two branches had **modification on completely different files**.</span><br><span class="line"></span><br><span class="line">So if you &#96;rebase&#96;, what you want to do is actually this:</span><br><span class="line"></span><br><span class="line">![Picture from https:&#x2F;&#x2F;git-scm.com&#x2F;book&#x2F;en&#x2F;v2&#x2F;Git-Branching-Rebasing, Figure 37](Git-Summary&#x2F;rebase1.png)</span><br><span class="line"></span><br><span class="line">So, you can take the **patch of the change that was introduced in C4** and **reapply** it on top of C3. With the &#96;rebase&#96; command, you can take all the changes that were committed on one branch and **replay them on a different branch**.</span><br><span class="line"></span><br><span class="line">To place &#96;experiment&#96; on top of &#96;master&#96;, you run:</span><br></pre></td></tr></table></figure>
<p>$ git checkout experiment<br>$ git rebase master</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">By **replaying the changes**, it means that this &#96;rebase&#96; operation does:</span><br><span class="line">- going to the common ancestor of the two branches (the one you’re on and the one you’re rebasing onto) </span><br><span class="line">- getting the **diff introduced by each commit of the branch you’re on**, **saving those diffs** to temporary files, **resetting the current branch to the same commit as the branch you are rebasing onto**, and finally **applying each change in turn**</span><br><span class="line"></span><br><span class="line">Finally, if you want to put your **master** in place of the head of the same branch as **experiment**, you need to switch back to **master** and **merge**. This time, it is guaranteed to have no conflicts because the diversion will be eliminated as the changes are **replayed** and the **ancestors will become the same**.</span><br><span class="line"></span><br><span class="line">&gt; Note:</span><br><span class="line">&gt; - [ ] The end product from &#96;merge&#96; and &#96;rebase&#96; will be the same, but rebasing makes for a **cleaner history**. If you examine the &#96;log&#96; of a rebased branch, it looks like a **linear history**: it appears that all the work happened in series, even when it originally happened in parallel.</span><br><span class="line">&gt; - [ ] Of course, do not rebase commits that exist outside your repository and that **people may have based work on**, because the changes are applied to that branch and it might **destory their work**.</span><br><span class="line"></span><br><span class="line">## A More Complicated Rebase</span><br><span class="line">Conside the case:</span><br><span class="line">![Picture from https:&#x2F;&#x2F;git-scm.com&#x2F;book&#x2F;en&#x2F;v2&#x2F;Git-Branching-Rebasing#rebasing-merging-example, Figure 39](Git-Summary&#x2F;complicatedRebase.png)</span><br><span class="line">And you want to rebase the **client** branch to go from the **master** branch. This can be done simply using one line:</span><br></pre></td></tr></table></figure>
<p>git rebase –onto master server client</p>
<p>```</p>
<p>This means to take the <strong>client</strong> branch, figure out the <strong>patches since it diverged from the server branch</strong>, and <strong>replay these patches in the client branch as if it was based directly off the master branch instead.</strong></p>
<hr>
<p><strong>Making a Disaster</strong></p>
<hr>
<h2 id="A-Disasterous-Case"><a href="#A-Disasterous-Case" class="headerlink" title="A Disasterous Case"></a>A Disasterous Case</h2><p>Consider if the server side actually <code>rebased</code> their <code>master</code> branch, and your work depends on it, and you did a <code>pull</code>, which automatically <code>merges</code> so it looks like this:<br><img src="Git-Summary/rebase2.png" alt="Picture from https://git-scm.com/book/en/v2/Git-Branching-Rebasing#rebasing-merging-example, Figure 46"></p>
<p>However, since we know that <code>C4</code> and <code>C6</code> are deleted/rebased because they are useless, we would also want <code>C4</code> and <code>C6</code> become removed. This can be done by <code>git pull --rebase</code> instead of <code>git pull</code>, which automatically successfully figure out what is <strong>uniquely yours</strong> and apply them back <strong>on top of the new branch</strong>.</p>
<blockquote>
<p>Note:</p>
<ul>
<li><input disabled="" type="checkbox"> If you are using <code>git pull</code> and want to make <code>--rebase</code> the <strong>default</strong>, you can set the <code>pull.rebase config</code> value with something like <code>git config --global pull.rebase true</code>.</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/07/13/Git-Summary/" data-id="ckafcy8bg0000u8t6de8p3ofz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/19/MarkDown-Summary/">MarkDown-Summary</a>
          </li>
        
          <li>
            <a href="/2013/07/13/Git-Summary/">Git Intro</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Xiao Yu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>